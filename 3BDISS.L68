0000140E Starting Address
Assembler used: EASy68K Editor/Assembler v5.13.01
Created On: 12/6/2013 12:43:28 AM

00000000                             1          INCLUDE 'TEST.x68'
00007000                             2      ORG    $7000
00007000                             3  
00007000  =000000FA                  4  VHEX1   EQU $FA
00007000  =0000DADA                  5  VHEX2   EQU $DADA
00007000  =ADADDADA                  6  VHEX3   EQU $ADADDADA
00007000  =00000045                  7  VHEX4   EQU $45
00007000  =00000000                  8  CBITS   EQU $00000000
00007000  =FFCFCFCF                  9  VBIN1   EQU %11111111110011111100111111001111
00007000                            10  
00007000                            11  
00007000                            12  
00007000                            13  
00007000  18B6 200C                 14      MOVE.B  (6*2,A6,D2),(A4)     (d8,An,Xn),(An)
00007004  3A76 904F                 15      MOVE.W  (79,A6,A1),A5        (d8,An,Xn),An
00007008  2C30 2805                 16      MOVE.L  (5,A0,D2.L),D6       (d8,An,Xn.SIZE),Dn
0000700C                            17      
0000700C                            18  
0000700C  1038 00FA                 19      MOVE.B  VHEX1, D0           <ea>,Dn
00007010  3239 0000DADA             20      MOVE.W  VHEX2, D1
00007016  243C ADADDADA             21      MOVE.L  #VHEX3, D2
0000701C                            22      
0000701C  10B8 00FA                 23      MOVE.B  VHEX1, (A0)         <ea>,(An)
00007020  32BC DADA                 24      MOVE.W  #VHEX2, (A1)
00007024  24B9 ADADDADA             25      MOVE.L  VHEX3, (A2)
0000702A                            26      
0000702A  16FC 00FA                 27      MOVE.B  #VHEX1, (A3)+       <ea>,(An)+
0000702E  38F9 0000DADA             28      MOVE.W  VHEX2, (A4)+
00007034  2AF9 ADADDADA             29      MOVE.L  VHEX3, (A5)+
0000703A                            30      
0000703A  1138 00FA                 31      MOVE.B  VHEX1, -(A0)        <ea>,-(An)
0000703E  3539 0000DADA             32      MOVE.W  VHEX2, -(A2)
00007044  293C ADADDADA             33      MOVE.L  #VHEX3, -(A4)
0000704A                            34              
0000704A  13F8 00FA 0000DADA        35      MOVE.B  VHEX1, VHEX2        <ea>,(xxx).W
00007052  33F9 0000DADA ADADDADA    36      MOVE.W  VHEX2, VHEX3        <ea>,(xxx).L
0000705C  23F8 0000 00F00200        37      MOVE.L  CBITS, $00F00200    <ea>,#<data>
00007064                            38      
00007064  13C0 0000DADA             39      MOVE.B  D0, VHEX2           Dn,<ea>
0000706A  33C1 00F00210             40      MOVE.W  D1, $00F00210
00007070  22C2                      41      MOVE.L  D2, (A1)+
00007072                            42      
00007072  13D1 0000FF00             43      MOVE.B  (A1),$FF00          (An),<ea>
00007078  3613                      44      MOVE.W  (A3),D3
0000707A  2315                      45      MOVE.L  (A5),-(A1)
0000707C                            46      
0000707C  2488                      47      MOVE.L  A0, (A2)            An,<ea>
0000707E  36C9                      48      MOVE.W  A1, (A3)+
00007080  23CA ADADDADA             49      MOVE.L  A2, VHEX3
00007086                            50      
00007086  13E0 0000DADA             51      MOVE.B  -(A0),VHEX2         -(An),<ea>
0000708C  3221                      52      MOVE.W  -(A1),D1
0000708E  24E2                      53      MOVE.L  -(A2),(A2)+
00007090                            54      
00007090  3239 0000DADA             55      MOVE.W  VHEX2, D1           (xxx).W, <ea>
00007096  23F9 ADADDADA 0000DADA    56      MOVE.L  VHEX3, VHEX2        (xxx).L, <ea>
000070A0  23FC 000013CF ADADDADA    57      MOVE.L  #%0001001111001111, VHEX3   #<data>,<ea>
000070AA                            58      
000070AA                            59  
000070AA  1F38 00FA                 60      MOVE.B  VHEX1, -(SP)        <ea>, -(SP)
000070AE  34A9 00FA                 61      MOVE.W  (VHEX1,A1),(A2)     (d16,An),<ea>
000070B2  333A 6A26                 62      MOVE.W  (VHEX2,PC),-(A1)    (d16,PC),<ea>
000070B6  261F                      63      MOVE.L  (SP)+, D3           (SP)+, <ea>
000070B8  70FA                      64      MOVEQ.L #VHEX1,D0           MOVEQ
000070BA                            65      
000070BA                            66  
000070BA                            67  
000070BA  3040                      68      MOVEA.W  D0,A0              Dn,An
000070BC  2248                      69      MOVEA.L  A0,A1              An,An
000070BE  2451                      70      MOVEA.L  (A1),A2            (An),An
000070C0                            71      
000070C0  265A                      72      MOVEA.L  (A2)+,A3           (An)+,An
000070C2  3863                      73      MOVEA.W  -(A3),A4           -(An),An
000070C4  3A79 0000DADA             74      MOVEA.W  VHEX2,A5            (xxx).W,An
000070CA                            75      
000070CA  2079 ADADDADA             76      MOVEA.L   VHEX3,A0           (xxx).L,An
000070D0  227C 0000DADA             77      MOVEA.L  #VHEX2,A1           #<data>,An
000070D6  2C79 FFCFCFCF             78      MOVEA.L   VBIN1,A6            (xxx).L,An
000070DC                            79  
000070DC  3C6D 00FA                 80      MOVEA.W  (VHEX1,A5),A6        (d16,An),An
000070E0  3E7A 69F8                 81      MOVEA.W  (VHEX2,PC),A7        (d16,PC),An
000070E4  70FA                      82      MOVEQ.L   #VHEX1, D0           MOVEQ
000070E6  72FA                      83      MOVEQ.L   #VHEX1, D1           MOVEQ
000070E8                            84      
000070E8                            85  
000070E8                            86  
000070E8  4890 020E                 87      MOVEM.W     D1-D3/A1, (A0)      <list>,(An)
000070EC  48B9 0302 0000DADA        88      MOVEM.W     D1/A0-A1, VHEX2     <list>,(xxx).W
000070F4  48E1 F8F8                 89      MOVEM.L     D0-D4/A0-A4, -(A1)  <list>,-(An)
000070F8  48F9 101C ADADDADA        90      MOVEM.L     D2-D4/A4, VHEX3     <list>,(xxx).L
00007100                            91      
00007100  4C91 020E                 92      MOVEM.W     (A1),D1-D3/A1       (An),<list>
00007104  4CB9 0302 0000DADA        93      MOVEM.W     VHEX2, D1/A0-A1     (xxx).W,<list>
0000710C  4CDA 1F1F                 94      MOVEM.L     (A2)+, D0-D4/A0-A4  (An)+,<list>
00007110  4CF9 101C ADADDADA        95      MOVEM.L     VHEX3, D2-D4/A4     (xxx).L,<list>
00007118                            96      
00007118                            97  
00007118  48A8 0306 00FA            98      MOVEM.W     D1-D2/A0-A1, (VHEX1,A0) <list>,(d16,An)
0000711E  48E9 0306 00FA            99      MOVEM.L     D1-D2/A0-A1, (VHEX1,A1) <list>,(d16,An)
00007124  4CAA 0306 00FA           100      MOVEM.W     (VHEX1,A2),D1-D2/A0-A1  (d16,An),<list>
0000712A  4CFA 0306 69AC           101      MOVEM.L     (VHEX2,PC),D1-D2/A0-A1  (d16,PC),<list>
00007130                           102      
00007130                           103  
00007130  D200                     104      ADD.B       D0,D1       Dn,Dn
00007132  D441                     105      ADD.W       D1,D2
00007134  D682                     106      ADD.L       D2,D3
00007136                           107      
00007136  D249                     108      ADD.W       A1,D1       An,Dn
00007138  D48A                     109      ADD.L       A2,D2
0000713A  DA8B                     110      ADD.L       A3,D5
0000713C                           111      
0000713C  D410                     112      ADD.B       (A0),D2     (An),Dn
0000713E  D651                     113      ADD.W       (A1),D3
00007140  D892                     114      ADD.L       (A2),D4
00007142                           115      
00007142  D01B                     116      ADD.B       (A3)+,D0    (An)+,Dn
00007144  D25C                     117      ADD.W       (A4)+,D1
00007146  D49D                     118      ADD.L       (A5)+,D2
00007148                           119      
00007148  D620                     120      ADD.B       -(A0),D3    -(An),Dn
0000714A  D861                     121      ADD.W       -(A1),D4    
0000714C  DAA2                     122      ADD.L       -(A2),D5
0000714E                           123      
0000714E  D039 0000DADA            124      ADD.B       VHEX2,D0    (xxx).W,Dn
00007154  D279 ADADDADA            125      ADD.W       VHEX3,D1    (xxx).L,Dn
0000715A  0683 000000FA            126      ADD.L       #VHEX1,D3   #<data>,Dn
00007160                           127      
00007160                           128  
00007160  D2C0                     129      ADD.W       D0,A1       Dn,An
00007162  D4C1                     130      ADD.W       D1,A2
00007164  D7C2                     131      ADD.L       D2,A3
00007166                           132      
00007166  D714                     133      ADD.B       D3,(A4)     Dn,(An)
00007168  D955                     134      ADD.W       D4,(A5) 
0000716A  DB96                     135      ADD.L       D5,(A6)
0000716C                           136      
0000716C  D118                     137      ADD.B       D0,(A0)+    Dn,(An)+
0000716E  D359                     138      ADD.W       D1,(A1)+
00007170  D59A                     139      ADD.L       D2,(A2)+
00007172                           140      
00007172  D723                     141      ADD.B       D3,-(A3)    Dn,-(An)
00007174  D964                     142      ADD.W       D4,-(A4)
00007176  DBA5                     143      ADD.L       D5,-(A5)
00007178                           144      
00007178  D339 0000DADA            145      ADD.B       D1,VHEX2    Dn,(xxx).W
0000717E  D5B9 ADADDADA            146      ADD.L       D2,VHEX3    Dn,(xxx).L
00007184  D779 FFCFCFCF            147      ADD.W       D3,VBIN1    Dn,(xxx).L
0000718A                           148      
0000718A                           149  
0000718A  D029 00FA                150      ADD.B       (VHEX1,A1),D0   (d16,An),Dn
0000718E  D27A 694A                151      ADD.W       (VHEX2,PC),D1   (d16,PC),Dn
00007192  D7A9 00FA                152      ADD.L       D3,(VHEX1,A1)   Dn,(d16,An)
00007196                           153  
00007196                           154  
00007196  D0C0                     155      ADDA.W       D0,A0           Dn,An
00007198  D3C1                     156      ADDA.L       D1,A1   
0000719A                           157      
0000719A  D7CA                     158      ADDA.L       A2,A3           An,An
0000719C  D8CB                     159      ADDA.W       A3,A4
0000719E                           160      
0000719E  D0D0                     161      ADDA.W       (A0),A0         (An),An
000071A0  D5D2                     162      ADDA.L       (A2),A2
000071A2                           163      
000071A2  D3D9                     164      ADDA.L       (A1)+,A1        (An)+,An
000071A4  D4DA                     165      ADDA.W       (A2)+,A2
000071A6                           166     
000071A6  D4E3                     167      ADDA.W       -(A3),A2        -(An),An
000071A8  D7E2                     168      ADDA.L       -(A2),A3
000071AA                           169      
000071AA  D1F9 0000DADA            170      ADDA.L       VHEX2,A0        (xxx).W,An
000071B0  D4F9 0000DADA            171      ADDA.W       VHEX2,A2    
000071B6                           172      
000071B6  D6F9 ADADDADA            173      ADDA.W       VHEX3,A3        (xxx).L,An
000071BC  D9F9 ADADDADA            174      ADDA.L       VHEX3,A4
000071C2                           175      
000071C2  DBFC FFCFCFCF            176      ADDA.L       #VBIN1,A5       #<data>,An
000071C8                           177  
000071C8                           178  
000071C8  D2EA 00FA                179      ADDA.W       (VHEX1,A2),A1   (d16,An),An
000071CC  D7FA 690C                180      ADDA.L       (VHEX2,PC),A3   (d16,PC),An
000071D0  D7EB 00FA                181      ADDA.L       (VHEX1,A3),A3   (d16,An),An
000071D4                           182  
000071D4                           183  
000071D4  5201                     184      ADDQ.B      #$1,D1       #<data>,Dn
000071D6  5442                     185      ADDQ.W      #$2,D2
000071D8  5683                     186      ADDQ.L      #3,D3
000071DA                           187      
000071DA  5848                     188      ADDQ.W      #$4,A0       #<data>,An
000071DC  5A89                     189      ADDQ.L      #$5,A1
000071DE  5C8A                     190      ADDQ.L      #$6,A2
000071E0                           191      
000071E0  5E10                     192      ADDQ.B      #$7,(A0)     #<data>,(An)
000071E2  5051                     193      ADDQ.W      #$8,(A1)
000071E4  5292                     194      ADDQ.L      #1,(A2)
000071E6                           195      
000071E6  541A                     196      ADDQ.B      #$2,(A2)+    #<data>,(An)+
000071E8  565B                     197      ADDQ.W      #$3,(A3)+
000071EA  589C                     198      ADDQ.L      #$4,(A4)+
000071EC                           199      
000071EC  5A25                     200      ADDQ.B      #$5,-(A5)    #<data>,-(An)
000071EE  5C66                     201      ADDQ.W      #6,-(A6)
000071F0  5EA7                     202      ADDQ.L      #$7,-(A7)
000071F2                           203      
000071F2  5239 0000DADA            204      ADDQ.B      #1,VHEX2     #<data>,(xxx).W
000071F8  54B9 ADADDADA            205      ADDQ.L      #2,VHEX3     #<data>,(xxx).L
000071FE  5879 FFCFCFCF            206      ADDQ.W      #$4,VBIN1    #<data>,(xxx).L
00007204                           207      
00007204  506A 00FA                208      ADDQ.W      #8,(VHEX1,A2)   #<data>,(d16,An)
00007208  0640 00FA                209      ADDI.W      #VHEX1,D0       ADDI
0000720C  D380                     210      ADDX.L      D0,D1           ADDX
0000720E                           211      
0000720E                           212  
0000720E                           213  
0000720E  9200                     214      SUB.B       D0,D1       Dn,Dn
00007210  9642                     215      SUB.W       D2,D3
00007212                           216      
00007212  9089                     217      SUB.L       A1,D0       An,Dn
00007214  964C                     218      SUB.W       A4,D3
00007216                           219      
00007216  9613                     220      SUB.B       (A3),D3     (An),Dn
00007218  9092                     221      SUB.L       (A2),D0
0000721A                           222      
0000721A  9218                     223      SUB.B       (A0)+,D1    (An)+,Dn
0000721C  945B                     224      SUB.W       (A3)+,D2
0000721E                           225      
0000721E  94A1                     226      SUB.L       -(A1),D2    -(An),Dn
00007220  9222                     227      SUB.B       -(A2),D1    
00007222                           228      
00007222  9079 0000DADA            229      SUB.W       VHEX2,D0    (xxx).W,Dn
00007228  94B9 FFCFCFCF            230      SUB.L       VBIN1,D2    (xxx).L,Dn
0000722E  0404 00F0                231      SUB.B       #$F0,D4     #<data>,Dn
00007232                           232      
00007232                           233  
00007232  92C0                     234      SUB.W       D0,A1       Dn,An
00007234  99C3                     235      SUB.L       D3,A4
00007236                           236      
00007236  9713                     237      SUB.B       D3,(A3)     Dn,(An)
00007238  9152                     238      SUB.W       D0,(A2)
0000723A                           239      
0000723A  9398                     240      SUB.L       D1,(A0)+    Dn,(An)+
0000723C  951B                     241      SUB.B       D2,(A3)+
0000723E                           242      
0000723E  9561                     243      SUB.W       D2,-(A1)    Dn,-(An)
00007240  93A2                     244      SUB.L       D1,-(A2)
00007242                           245      
00007242  9139 0000DADA            246      SUB.B       D0,VHEX2    Dn,(xxx).W
00007248  9579 FFCFCFCF            247      SUB.W       D2,VBIN1    Dn,(xxx).L
0000724E  97B9 ADADDADA            248      SUB.L       D3,VHEX3    Dn,(xxx).L
00007254                           249      
00007254                           250  
00007254  902A 00FA                251      SUB.B       (VHEX1,A2),D0   (d16,An),Dn
00007258  927A 6880                252      SUB.W       (VHEX2,PC),D1   (d16,PC),Dn
0000725C  93A9 00FA                253      SUB.L       D1, (VHEX1,A1)  Dn,(d16,An)
00007260                           254      
00007260                           255  
00007260                           256  
00007260  90C0                     257      SUBA.W      D0,A0       Dn,An
00007262  93C1                     258      SUBA.L      D1,A1
00007264                           259      
00007264  94C9                     260      SUBA.W      A1,A2       An,An
00007266  97CA                     261      SUBA.L      A2,A3
00007268                           262      
00007268  96D3                     263      SUBA.W      (A3),A3     (An),An
0000726A  99D4                     264      SUBA.L      (A4),A4
0000726C                           265      
0000726C  90DD                     266      SUBA.W      (A5)+,A0    (An)+,An
0000726E  93DE                     267      SUBA.L      (A6)+,A1
00007270                           268      
00007270  94E0                     269      SUBA.W      -(A0),A2    -(An),An
00007272  97E1                     270      SUBA.L      -(A1),A3
00007274                           271      
00007274  98F9 0000DADA            272      SUBA.W      VHEX2,A4    (xxx).W,An
0000727A  9BF9 ADADDADA            273      SUBA.L      VHEX3,A5    (xxx).L,An
00007280  9DFC FFCFCFCF            274      SUBA.L      #VBIN1,A6   #<data>,An
00007286                           275      
00007286                           276  
00007286  98E9 0F0F                277      SUBA.W      ($F0F,A1),A4   (d16,An),An
0000728A  95FA 9E85                278      SUBA.L      ($1111,PC),A2  (d16,PC),An
0000728E                           279      
0000728E                           280  
0000728E  0400 00FA                281      SUBI.B      #VHEX1,D0       #<data>,Dn
00007292  0442 DADA                282      SUBI.W      #VHEX2,D2
00007296                           283      
00007296  0492 ADADDADA            284      SUBI.L      #VHEX3,(A2)       #<data>,(An)
0000729C  0411 000A                285      SUBI.B      #10,(A1)
000072A0                           286      
000072A0  0458 0000                287      SUBI.W      #CBITS,(A0)+      #<data>,(An)+
000072A4  049A ADADDADA            288      SUBI.L      #VHEX3,(A2)+
000072AA                           289      
000072AA  0424 000A                290      SUBI.B      #10,-(A4)            #<data>,-(An)
000072AE  0461 000F                291      SUBI.W      #$F,-(A1)
000072B2                           292      
000072B2  04B9 0000DADA 0000DADA   293      SUBI.L      #VHEX2,VHEX2        #<data>,(xxx).W
000072BC  0439 0009 ADADDADA       294      SUBI.B      #09,VHEX3        #<data>,(xxx).L
000072C4                           295      
000072C4                           296  
000072C4  0469 0009 0030           297      SUBI.W      #9,($30,A1)         #<data>,(d16,An)
000072CA  5380                     298      SUBQ.L      #1,D0           SUBQ
000072CC                           299      
000072CC                           300     
000072CC                           301  
000072CC                           302  
000072CC  C2C0                     303      MULU.W      D0,D1           Dn,Dn
000072CE  C2D0                     304      MULU.W      (A0),D1         (An),Dn
000072D0  C4DA                     305      MULU.W      (A2)+,D2        (An)+,Dn
000072D2  C6E3                     306      MULU.W      -(A3),D3        -(An),Dn
000072D4  C8F9 0000DADA            307      MULU.W      VHEX2,D4        (xxx).W,Dn
000072DA  CAF9 ADADDADA            308      MULU.W      VHEX3,D5        (xxx).L,Dn
000072E0  CCFC 2345                309      MULU.W      #$2345,D6       #<data>,Dn
000072E4                           310      
000072E4                           311  
000072E4  C0EA 0032                312      MULU.W      ($32,A2),D0     (d16,An),Dn
000072E8  C2FA 9D16                313      MULU.W      ($1000,PC),D1   (d16,PC),Dn
000072EC                           314      
000072EC                           315      
000072EC                           316  
000072EC  85C1                     317      DIVS.W      D1,D2           Dn,Dn
000072EE  85D1                     318      DIVS.W      (A1),D2         (An),Dn
000072F0  87DA                     319      DIVS.W      (A2)+,D3        (An)+,Dn
000072F2  89E3                     320      DIVS.W      -(A3),D4        -(An),Dn
000072F4  8BF9 0000DADA            321      DIVS.W      VHEX2,D5        (xxx).W,Dn
000072FA  8DF9 ADADDADA            322      DIVS.W      VHEX3,D6        (xxx).L,Dn
00007300  8FFC FF00                323      DIVS.W      #$FF00,D7       #<data>,Dn
00007304                           324      
00007304                           325  
00007304  83EB 0401                326      DIVS.W      ($401,A3),D1     (d16,An),Dn
00007308  85FA AF07                327      DIVS.W      ($2211,PC),D2    (d16,PC),Dn
0000730C                           328      
0000730C                           329     
0000730C                           330  
0000730C  B101                     331      EOR.B       D0,D1           Dn,Dn
0000730E  B342                     332      EOR.W       D1,D2
00007310                           333      
00007310  B592                     334      EOR.L       D2,(A2)         Dn,(An)
00007312  B713                     335      EOR.B       D3,(A3)
00007314                           336      
00007314  B95C                     337      EOR.W       D4,(A4)+        Dn,(An)+
00007316  BB9D                     338      EOR.L       D5,(A5)+
00007318                           339      
00007318  BD26                     340      EOR.B       D6,-(A6)        Dn,-(An)
0000731A  BF67                     341      EOR.W       D7,-(A7)
0000731C                           342      
0000731C  B1B9 0000DADA            343      EOR.L       D0,VHEX2        Dn,(xxx).W
00007322  B339 ADADDADA            344      EOR.B       D1,VHEX3        Dn,(xxx).L
00007328                           345  
00007328                           346  
00007328  B56C 0101                347      EOR.W       D2,($101,A4)    Dn,(d16,An)
0000732C  0A3C 0001                348      EORI.B      #$1,CCR         EORI to CCR
00007330                           349      
00007330                           350  
00007330                           351  
00007330  0A00 00FA                352      EORI.B      #VHEX1,D0       #<data>,Dn
00007334  0A41 000A                353      EORI.W      #10,D1
00007338                           354      
00007338  0A91 ADADDADA            355      EORI.L      #VHEX3,(A1)     #<data>,An
0000733E  0A13 0012                356      EORI.B      #$12,(A3)
00007342                           357      
00007342  0A5A DADA                358      EORI.W      #VHEX2,(A2)+    #<data>,(An)+
00007346  0A9C FFCFCFCF            359      EORI.L      #VBIN1,(A4)+
0000734C                           360      
0000734C  0A20 00FF                361      EORI.B      #$FF, -(A0)     #<data>,-(An)
00007350  0A65 1222                362      EORI.W      #$1222,-(A5)
00007354                           363      
00007354  0AB9 0000DADA 0000DADA   364      EORI.L      #VHEX2,VHEX2    #<data>,(xxx).W
0000735E  0A39 0011 ADADDADA       365      EORI.B      #$11, VHEX3     #<data>,(xxx).L
00007366                           366      
00007366                           367  
00007366  0A6A 000A 0011           368      EORI.W      #10, ($11,A2)   #<data>,(d16,An)
0000736C  C342                     369      EXG.L       D1,D2           EXG
0000736E                           370      
0000736E                           371  
0000736E                           372  
0000736E  C200                     373      AND.B       D0,D1           Dn,Dn
00007370  C451                     374      AND.W       (A1),D2         (An),Dn
00007372  C69A                     375      AND.L       (A2)+,D3        (An)+,Dn
00007374  C823                     376      AND.B       -(A3),D4        -(An),Dn
00007376  CA79 0000DADA            377      AND.W       VHEX2,D5        (xxx).W,Dn
0000737C  CCB9 ADADDADA            378      AND.L       VHEX3,D6        (xxx).L,Dn
00007382  CE3C 00FF                379      AND.B       #$FF,D7         #<data>,Dn
00007386                           380      
00007386                           381  
00007386  C151                     382      AND.W       D0,(A1)         Dn,(An)
00007388  C39A                     383      AND.L       D1,(A2)+        Dn,(An)+
0000738A  C523                     384      AND.B       D2,-(A3)        Dn,-(An)
0000738C  C779 0000DADA            385      AND.W       D3,VHEX2        Dn,(xxx).W
00007392  C9B9 FFCFCFCF            386      AND.L       D4,VBIN1        Dn,(xxx).L
00007398                           387      
00007398                           388  
00007398  C42A 0012                389      AND.B       ($12,A2),D2     (d16,An),Dn
0000739C  C67A 9D83                390      AND.W       ($1121,PC),D3   (d16,PC),Dn
000073A0  C9AC 0112                391      AND.L       D4, ($112,A4)   Dn,(d16,An)
000073A4                           392      
000073A4                           393  
000073A4  0000 00F1                394      ORI.B       #$F1,D0         #<data>,Dn
000073A8  0052 DADA                395      ORI.W       #VHEX2,(A2)     #<data>,(An)
000073AC  009B ADADDADA            396      ORI.L       #VHEX3,(A3)+    #<data>,(An)+
000073B2  0024 0011                397      ORI.B       #$11,-(A4)      #<data>,-(An)
000073B6  0079 0062 0000DADA       398      ORI.W       #98,VHEX2       #<data>,(xxx).W
000073BE  00B9 00000064 ADADDADA   399      ORI.L       #100,VHEX3      #<data>,(xxx).L
000073C8                           400      
000073C8                           401  
000073C8  002A 0004 00FF           402      ORI.B       #4,($FF,A2)     #<data>,(d16,An)
000073CE  8441                     403      OR.W        D1,D2           OR
000073D0                           404      
000073D0                           405  
000073D0  E121                     406      ASL.B       D0,D1       Dx,Dy
000073D2  E562                     407      ASL.W       D2,D2       
000073D4  E982                     408      ASL.L       #4,D2       #<data>,Dy
000073D6  E1D2                     409      ASL.W       (A2)        (An)
000073D8  E1DB                     410      ASL.W       (A3)+       (An)+
000073DA  E1E4                     411      ASL.W       -(A4)       -(An)
000073DC  E1F9 0000DADA            412      ASL.W       VHEX2       (xxx).W
000073E2  E1F9 ADADDADA            413      ASL.W       VHEX3       (xxx).L
000073E8                           414      
000073E8                           415  
000073E8  E1EC 0022                416      ASL.W       ($22,A4)    (d16,An)
000073EC  E0F9 0000DADA            417      ASR.W       VHEX2       ASR
000073F2                           418      
000073F2  E029                     419      LSR.B       D0,D1       Dx,Dy
000073F4  E46A                     420      LSR.W       D2,D2       
000073F6  E88A                     421      LSR.L       #4,D2       #<data>,Dy
000073F8  E2D2                     422      LSR.W       (A2)        (An)
000073FA  E2DB                     423      LSR.W       (A3)+       (An)+
000073FC  E2E4                     424      LSR.W       -(A4)       -(An)
000073FE  E2F9 0000DADA            425      LSR.W       VHEX2       (xxx).W
00007404  E2F9 ADADDADA            426      LSR.W       VHEX3       (xxx).L
0000740A                           427      
0000740A                           428  
0000740A  E2EC 0022                429      LSR.W       ($22,A4)    (d16,An)
0000740E  E3F9 0000DADA            430      LSL.W       VHEX2       LSL
00007414                           431      
00007414                           432  
00007414  0101                     433      BTST.L      D0, D1      Dn,Dn
00007416  0311                     434      BTST.B      D1,(A1)     Dn,(An)
00007418  051A                     435      BTST.B      D2,(A2)+    Dn,(An)+
0000741A  0723                     436      BTST.B      D3,-(A3)    Dn,-(An)
0000741C  0939 0000DADA            437      BTST.B      D4,VHEX2    Dn,(xxx).W
00007422  0B38 0045                438      BTST.B      D5,VHEX4    Dn,(xxx).L
00007426  0D3C 0004                439      BTST.B      D6,#4       Dn,#<data>
0000742A                           440      
0000742A                           441  
0000742A  0800 00DA                442      BTST.L      #VHEX2,D0       #<data>,Dn
0000742E  0810 00FA                443      BTST.B      #VHEX1,(A0)     #<data>,(An)
00007432  0818 00DA                444      BTST.B      #VHEX3,(A0)+    #<data>,(An)+
00007436  0824 00CF                445      BTST.B      #VBIN1,-(A4)    #<data>,-(An)
0000743A  0839 0011 0000DADA       446      BTST.B      #$11,VHEX2      #<data>,(xxx).W
00007442  0839 0099 ADADDADA       447      BTST.B      #$99,VHEX3      #<data>,(xxx).L
0000744A                           448      
0000744A                           449  
0000744A  0F2B 0011                450      BTST.B      D7, ($11,A3)    Dn,(d16,An)
0000744E  0D3A 8C5A                451      BTST.B      D6, ($AA,PC)    Dn,(d16,PC)
00007452  082A 0057 00BB           452      BTST.B      #1111,($BB,A2)  #<data>,(d16,An)
00007458                           453      
00007458  B001                     454      CMP.B       D1,D0       Dn,Dn
0000745A  6700 0002                455      BEQ         B1a
0000745E                           456  B1a    
0000745E  B24A                     457      CMP.W       A2,D1       An,Dn
00007460  6700 0002                458      BEQ         B2a
00007464                           459  B2a
00007464  B493                     460      CMP.L       (A3),D2     (An),Dn
00007466  6D00 0002                461      BLT         B3
0000746A                           462  B3
0000746A  B61C                     463      CMP.B       (A4)+,D3    (An)+,Dn
0000746C  6600 0002                464      BNE         B4
00007470                           465  B4
00007470  B865                     466      CMP.W       -(A5),D4    -(An),Dn
00007472  6200 0002                467      BHI         B5
00007476                           468  B5
00007476  BAB9 0000DADA            469      CMP.L       VHEX2,D5    (xxx).W,Dn
0000747C  BC39 ADADDADA            470      CMP.B       VHEX3,D6    (xxx).L,Dn
00007482  BEBC FFCFCFCF            471      CMP.L       #VBIN1,D7   #<data>,Dn
00007488                           472  
00007488                           473  
00007488  B028 00FF                474      CMP.B       ($FF,A0),D0     (d16,An),Dn
0000748C  B47A 9833                475      CMP.W       ($CC1,PC),D2    (d16,PC),Dn
00007490                           476      
00007490                           477  
00007490  B0C0                     478      CMPA.W      D0,A0       Dn,An
00007492  B3C8                     479      CMPA.L      A0,A1       An,An
00007494  6700 0002                480      BEQ         Ba1
00007498                           481  Ba1
00007498  B4D1                     482      CMPA.W      (A1),A2     (An),An
0000749A  6D00 0002                483      BLT         Ba2
0000749E                           484  Ba2
0000749E  B7DA                     485      CMPA.L      (A2)+,A3    (An)+,An
000074A0  6600 0002                486      BNE         Ba3
000074A4                           487  Ba3
000074A4  B8E3                     488      CMPA.W      -(A3),A4    -(An),An
000074A6  6200 0002                489      BHI         Ba4
000074AA                           490  Ba4
000074AA  BBF9 0000DADA            491      CMPA.L      VHEX2,A5    (xxx).W,An
000074B0  BCF9 ADADDADA            492      CMPA.W      VHEX3,A6    (xxx).L,An
000074B6  BFFC 000004D2            493      CMPA.L      #1234,A7    #<data>,An
000074BC                           494      
000074BC                           495  
000074BC  B0E9 0033                496      CMPA.W      ($33,A1),A0     (d16,An),An
000074C0  B5FA 8B4F                497      CMPA.L      ($11,PC),A2     (d16,PC),An
000074C4                           498      
000074C4                           499  
000074C4  0C00 00FA                500      CMPI.B      #VHEX1,D0       #<data>,Dn
000074C8  6700 0002                501      BEQ         Bb1
000074CC                           502  Bb1
000074CC  0C51 DADA                503      CMPI.W      #VHEX2,(A1)     #<data>,(An)
000074D0  6600 0002                504      BNE         Bb2
000074D4                           505  Bb2
000074D4  0C9A ADADDADA            506      CMPI.L      #VHEX3,(A2)+    #<data>,(An)+
000074DA  6200 0002                507      BHI         Bb3
000074DE                           508  Bb3
000074DE  0C23 0012                509      CMPI.B      #$12,-(A3)      #<data>,-(An)
000074E2  6D00 000A                510      BLT         Bb4
000074E6  0C79 1234 0000DADA       511      CMPI.W      #$1234,VHEX2    #<data>,(xxx).W
000074EE                           512  Bb4
000074EE  0CB9 FFCFCFCF ADADDADA   513      CMPI.L      #VBIN1,VHEX3    #<data>,(xxx).L
000074F8                           514      
000074F8                           515  
000074F8  0C2A 00FF 0099           516      CMPI.B      #$FF,($99,A2)       #<data>,(d16,An)
000074FE  B30A                     517      CMPM.B      (A2)+,(A1)+         CMPM
00007500                           518      
00007500                           519  
00007500  41D1                     520      LEA     (A1),A0         (An),An
00007502  43F9 0000DADA            521      LEA     VHEX2,A1        (xxx).W,An
00007508  45F9 ADADDADA            522      LEA     VHEX3,A2        (xxx).L,An
0000750E                           523   
0000750E                           524  
0000750E  43E9 0010                525      LEA     ($10,A1),A1     (d16,An),An
00007512  45FA 9485                526      LEA     ($999,PC),A2    (d16,PC),An
00007516                           527      
00007516  4EB9 00007532            528      JSR     JUMP
0000751C  4E91                     529      JSR     (A1)        (An)
0000751E  4EB9 0000DADA            530      JSR     VHEX2       (xxx).W
00007524  4EB9 ADADDADA            531      JSR     VHEX3       (xxx).L
0000752A  4EAA 0019                532      JSR     ($19,A2)    (d16,An)
0000752E  4EBA 8BD0                533      JSR     ($100,PC)   (d16,PC)
00007532                           534      
00007532                           535  JUMP    *For JSR & RTS test
00007532  1201                     536          MOVE.B  D1, D1
00007534  4E75                     537          RTS
00007536  4E71                     538          NOP         NOP
00007538                           539  
00007538                           540  
00007538                           541  
00007538                           542  
00007538                           543  
00007538                           544  
00007538                           545  
00007538                           546  
00007538                           547  
00007538                           548  
00007538                           549  -------------------- end include --------------------
00007538                           550  *----------------------------------------------------------------------------
00007538                           551  * Title      : 3B Disassembler
00007538                           552  * Written by : The Three Bears: Joseph Schooley, Nguyen Tong, Terence Calhoun
00007538                           553  * Date       : 11/30/2013
00007538                           554  * Description: A Motorola MC68000 Microprocessor Disassembler 
00007538                           555  *----------------------------------------------------------------------------
00001000                           556          ORG     $1000
00001000  =0000000D                557  CR      EQU     $0D         ASCII: carriage return
00001000  =0000000A                558  LF      EQU     $0A         ASCII: line feed
00001000  =00000009                559  TB      EQU     $09         ASCII: horizontal tab
00001000  =00007000                560  MNADDR  EQU     $7000       Min address
00001000  =00FFFFFF                561  MXADDR  EQU     $00FFFFFF   Max address
00001000                           562  
00001000                           563  GBUFF   DS.L    1           Pointer to next location in "Good buffer"
00001004                           564  SLOC    DS.B    4           Starting location storage
00001008                           565  ELOC    DS.B    4           Ending location storage
0000100C                           566  
0000100C                           567  *-----I/O Memory-----
0000100C                           568  IOOPCD  DS.B    1           IO offset value for OPNAME, or FF if none
0000100D                           569  IOBDCD  DS.B    1           IO offset value for BAD OPNAME, or FF if none
0000100E                           570  IOSIZE  DS.B    1           IO size for OP code, or FF if none
00001010                           571  IOADDR  DS.L    1           IO address value for instruction memory location
00001014                           572  IOLC    DS.B    1           IO line counter for screen
00001015                           573  QDATA   DS.B    1           OP immediate data for xxxxQ instructions
00001016                           574  
00001016                           575  
00001016                           576  * OP code name memory
00001016                           577  * Example to display MULU:
00001016                           578  *       LEA     OPNAME,A1
00001016                           579  *       ADD.L   #$2D,A1
00001016                           580  *       MOVE.B  #14,D0
00001016                           581  *       TRAP    #15
00001016                           582  *                NAME           DEC     HEX
00001016= 4D 4F 56 45 00           583  OPNAME  DC.B    'MOVE',0        00      00
0000101B= 4D 4F 56 45 41 00        584          DC.B    'MOVEA',0       05      05
00001021= 4D 4F 56 45 4D 00        585          DC.B    'MOVEM',0       11      0B
00001027= 41 44 44 00              586          DC.B    'ADD',0         17      11
0000102B= 41 44 44 41 00           587          DC.B    'ADDA',0        21      15
00001030= 41 44 44 51 00           588          DC.B    'ADDQ',0        26      1A
00001035= 53 55 42 00              589          DC.B    'SUB',0         31      1F
00001039= 53 55 42 41 00           590          DC.B    'SUBA',0        35      23
0000103E= 53 55 42 49 00           591          DC.B    'SUBI',0        40      28
00001043= 4D 55 4C 55 00           592          DC.B    'MULU',0        45      2D
00001048= 44 49 56 53 00           593          DC.B    'DIVS',0        50      32
0000104D= 4C 45 41 00              594          DC.B    'LEA',0         55      37
00001051= 41 4E 44 00              595          DC.B    'AND',0         59      3B
00001055= 4F 52 49 00              596          DC.B    'ORI',0         63      3F
00001059= 45 4F 52 00              597          DC.B    'EOR',0         67      43
0000105D= 45 4F 52 49 00           598          DC.B    'EORI',0        71      47
00001062= 4E 4F 54 00              599          DC.B    'NOT',0         76      4C
00001066= 41 53 4C 00              600          DC.B    'ASL',0         80      50
0000106A= 4C 53 52 00              601          DC.B    'LSR',0         84      54
0000106E= 42 54 53 54 00           602          DC.B    'BTST',0        88      58
00001073= 43 4D 50 00              603          DC.B    'CMP',0         93      5D
00001077= 43 4D 50 41 00           604          DC.B    'CMPA',0        97      61
0000107C= 43 4D 50 49 00           605          DC.B    'CMPI',0        102     66
00001081= 42 43 43 00              606          DC.B    'BCC',0         107     6B
00001085= 42 45 51 00              607          DC.B    'BEQ',0         111     6F
00001089= 42 4C 54 00              608          DC.B    'BLT',0         115     73
0000108D= 42 4E 45 00              609          DC.B    'BNE',0         119     77
00001091= 42 48 49 00              610          DC.B    'BHI',0         123     7B
00001095= 4A 53 52 00              611          DC.B    'JSR',0         127     7F
00001099= 52 54 53 00              612          DC.B    'RTS',0         131     83
0000109D= 42 41 44 00              613          DC.B    'BAD',0         135     87
000010A1= 4D 4F 56 45 51 00        614          DC.B    'MOVEQ',0       139     8B
000010A7= 4C 53 4C 00              615          DC.B    'LSL',0         145     91
000010AB= 41 53 52 00              616          DC.B    'ASR',0         149     95
000010AF= 41 44 44 49 00           617          DC.B    'ADDI',0        153     99
000010B4                           618  
000010B4= 2E 42 00                 619  IOOPSZ  DC.B    '.B',0          0       00
000010B7= 2E 57 00                 620          DC.B    '.W',0          3       03
000010BA= 2E 4C 00                 621          DC.B    '.L',0          6,      06
000010BD= 20 20 00                 622          DC.B    '  ',0          9,      09
000010C0                           623  
000010C0                           624  *-----EA Memory------
000010C0                           625  DMD     DS.B    1               Destination mode
000010C1                           626  DRG     DS.B    1               Destination register
000010C2                           627  SMD     DS.B    1               Source mode
000010C3                           628  SRG     DS.B    1               Source register
000010C4                           629  RGMD    DS.B    1               Last register + mod (00REGMOD)
000010C5                           630  DIS     DS.B    1               Last displacement
000010C6                           631  
000010C6                           632  *--------------------
000010C6                           633  
000010C6= 20 20 5F 20 20 20 ...    634  MSSG0   DC.B    '  _     _     _     _     _     _ ',CR,LF
000010EA= 20 28 6F 5C 2D 2D ...    635          DC.B    ' (o\---/o)   (o\---/o)   (o\---/o)',CR,LF
0000110E= 20 20 7C 20 2D 20 ...    636          DC.B    '  | - - |     | ^ ^ |     | . . |',CR,LF
00001131= 20 5F 28 20 28 59 ...    637          DC.B    ' _( (Y)_)_,--.(_(Y)_),--._(_(Y) )_',CR,LF
00001155= 2F 20 2F 5F 5F 5F ...    638          DC.B    '/ /___|_  ".."       ".."  _|___\ \',CR,LF
0000117A= 5C 5F 5F 5F 5F 5F ...    639          DC.B    '\_______):     THREE     :(_______/',CR,LF
0000119F= 7C 20 7C 20 20 20 ...    640          DC.B    '| |   |        BEARS        |   | |',CR,LF
000011C4= 7C 20 7C 20 20 20 ...    641          DC.B    '| |   |    DISASSEMBLER     |   | |',CR,LF
000011E9= 7C 20 20 5C 5F 5F ...    642          DC.B    '|  \__|__Joey__Terence__Win_|__/  |',CR,LF
0000120E= 20 5C 20 20 20 20 ...    643          DC.B    ' \    I  /_  )   |   (  _\  I    /',CR,LF
00001232= 20 20 5C 5F 5F 5F ...    644          DC.B    '  \____)___)(___/ \___)(___(____/',CR,LF
00001255= 57 65 6C 63 6F 6D ...    645          DC.B    'Welcome to 3B Disassembler. Enter 0 at any time to quit.',CR,LF,0
00001290= 45 6E 74 65 72 20 ...    646  MSSG1   DC.B    'Enter the starting location of the code to be disassembled, or leave it blank',CR,LF,'for the starting address:',0
000012F9= 45 6E 74 65 72 20 ...    647  MSSG2   DC.B    'Enter the ending location of the code to be disassembled, or leave it blank',CR,LF,'for the ending address:',0
0000135E= 50 72 65 73 73 20 ...    648  MSSG4   DC.B    'Press any key for the next page.',0
0000137F= 59 6F 75 20 68 61 ...    649  MSSG5   DC.B    'You have reached the end of the program.',0
000013A8= 41 64 64 72 65 73 ...    650  HEADR   DC.B    'Address      OP-Code    Operand',CR,LF,0
000013CA= 54 68 65 20 69 6E ...    651  ERR0    DC.B    'The input address was too small.',CR,LF,0
000013ED= 54 68 65 20 69 6E ...    652  ERR1    DC.B    'The input address was too big.',CR,LF,0
0000140E                           653  
0000140E  11FC 0000 1014           654  START   MOVE.B  #0,IOLC
00001414  43F8 10C6                655          LEA     MSSG0,A1        Welcome message
00001418  103C 000E                656          MOVE.B  #14,D0
0000141C  4E4F                     657          TRAP    #15
0000141E  6000 0216                658          BRA     PRMPT1
00001422                           659  
00001422                           660  *-----------------------------------
00001422                           661  *    Conversion & Comparison Methods
00001422                           662  *-----------------------------------
00001422                           663  
00001422                           664  *
00001422                           665  * Flag set / clear: Sets or clears the flag
00001422                           666  *
00001422                           667   
00001422  44FC 0004                668  FLAGST  MOVE.W  #%100,CCR       Set the z-flag
00001426  4E75                     669          RTS                     Return to caller
00001428  44FC 0000                670  FLAGCL  MOVE.W  #%000,CCR       Clear the z-flg
0000142C  4E75                     671          RTS                     Return to caller
0000142E                           672  
0000142E                           673  *
0000142E                           674  * ASCII2HEX: Convert ASCII into HEX.
0000142E                           675  * Input ASCII from D0 output HEX to D1
0000142E                           676  *
0000142E                           677  
0000142E                           678  ASCII2HEX
0000142E  2200                     679          MOVE.L  D0,D1           Move the input to D1
00001430  0441 3030                680          SUB     #$3030,D1       Convert last word
00001434  4841                     681          SWAP    D1              Swap bytes
00001436  0441 3030                682          SUB     #$3030,D1       Convert first word
0000143A  4841                     683          SWAP    D1              Restore order
0000143C                           684          
0000143C  2F02                     685          MOVE.L  D2,-(SP)        Push D2 on stack
0000143E  4282                     686          CLR.L   D2              
00001440  143C 0003                687          MOVE.B  #3,D2           Set rotation count
00001444                           688          
00001444  6100 001A                689          BSR     A2H             Start loop
00001448                           690          
00001448  241F                     691          MOVE.L  (SP)+,D2        Restore D2
0000144A                           692                  
0000144A                           693                                * XAXBXCXD
0000144A  E919                     694          ROL.B   #4,D1           XAXBXCDX
0000144C  E949                     695          LSL.W   #4,D1           XAXBCDX0
0000144E  E159                     696          ROL.W   #8,D1           XAXBX0CD
00001450  4841                     697          SWAP    D1              X0CDXAXB
00001452  E919                     698          ROL.B   #4,D1           X0CDXABX
00001454  E949                     699          LSL.W   #4,D1           X0CDABX0
00001456  E189                     700          LSL.L   #8,D1           CDABX000
00001458  4241                     701          CLR.W   D1              CDAB0000
0000145A  4841                     702          SWAP    D1              0000CDAB
0000145C  E159                     703          ROL.W   #8,D1           0000ABCD
0000145E  4E75                     704          RTS                     Return to caller
00001460                           705          
00001460                           706          
00001460                           707  A2H   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
00001460  B23C 0011                708          CMP.B   #$11,D1         11 = A
00001464  6700 0032                709          BEQ     A2H11
00001468  B23C 0012                710          CMP.B   #$12,D1         12 = B
0000146C  6700 0030                711          BEQ     A2H12
00001470  B23C 0013                712          CMP.B   #$13,D1         13 = C
00001474  6700 002E                713          BEQ     A2H13
00001478  B23C 0014                714          CMP.B   #$14,D1         14 = D
0000147C  6700 002C                715          BEQ     A2H14
00001480  B23C 0015                716          CMP.B   #$15,D1         15 = E
00001484  6700 002A                717          BEQ     A2H15
00001488  B23C 0016                718          CMP.B   #$16,D1         16 = F
0000148C  6700 0028                719          BEQ     A2H16
00001490                           720          
00001490                           721  A2HADV  * A2H conversion branch helper: Rotate to the next byte, and loop back to A2H until all bytes have been analyzed/converted
00001490  E199                     722          ROL.L   #8,D1           Rotate 1st byte to the end
00001492  51CA FFCC                723          DBRA    D2,A2H          If count is > 0, decrement and loop back to A2H
00001496  4E75                     724          RTS                     If count == 0, return to sub-routine
00001498                           725  
00001498                           726  * A2H conversion branches
00001498  123C 000A                727  A2H11   MOVE.B  #$A,D1
0000149C  60F2                     728          BRA     A2HADV
0000149E  123C 000B                729  A2H12   MOVE.B  #$B,D1
000014A2  60EC                     730          BRA     A2HADV
000014A4  123C 000C                731  A2H13   MOVE.B  #$C,D1
000014A8  60E6                     732          BRA     A2HADV
000014AA  123C 000D                733  A2H14   MOVE.B  #$D,D1
000014AE  60E0                     734          BRA     A2HADV
000014B0  123C 000E                735  A2H15   MOVE.B  #$E,D1
000014B4  60DA                     736          BRA     A2HADV
000014B6  123C 000F                737  A2H16   MOVE.B  #$F,D1
000014BA  60D4                     738          BRA     A2HADV
000014BC                           739  
000014BC                           740  *
000014BC                           741  * HEX2ASCII: Convert ASCII into HEX.
000014BC                           742  * Input HEX from D0.W output ASCII to D1.L
000014BC                           743  *
000014BC                           744  
000014BC                           745  HEX2ASCII
000014BC  2200                     746          MOVE.L  D0,D1           Move the input to D1
000014BE                           747  
000014BE                           748                                * XXXXABCD
000014BE  4841                     749          SWAP    D1              ABCDXXXX
000014C0  4241                     750          CLR.W   D1              ABCD0000
000014C2  E999                     751          ROL.L   #4,D1           BCD0000A
000014C4  E909                     752          LSL.B   #4,D1           BCD000A0
000014C6  E159                     753          ROL.W   #8,D1           BCD0A000
000014C8  E999                     754          ROL.L   #4,D1           CD0A000B
000014CA  E159                     755          ROL.W   #8,D1           CD0A0B00
000014CC  E999                     756          ROL.L   #4,D1           D0A0B00C
000014CE  E909                     757          LSL.B   #4,D1           D0A0B0C0
000014D0  E999                     758          ROL.L   #4,D1           0A0B0C0D
000014D2                           759  
000014D2  2F02                     760          MOVE.L  D2,-(SP)        Push D2 on stack
000014D4  4282                     761          CLR.L   D2              
000014D6  143C 0003                762          MOVE.B  #3,D2           Set rotation count
000014DA  6100 0012                763          BSR     H2A             Start loop
000014DE  241F                     764          MOVE.L  (SP)+,D2        Restore D2
000014E0                           765  
000014E0  0641 3030                766          ADD     #$3030,D1       Convert last word
000014E4  4841                     767          SWAP    D1              Swap bytes
000014E6  0641 3030                768          ADD     #$3030,D1       Convert first word
000014EA  4841                     769          SWAP    D1              Restore order
000014EC  4E75                     770          RTS                     Return to caller
000014EE                           771          
000014EE                           772          
000014EE                           773  H2A   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
000014EE  B23C 000A                774          CMP.B   #$A,D1         A = 11
000014F2  6700 0032                775          BEQ     H2AA
000014F6  B23C 000B                776          CMP.B   #$B,D1         B = 12
000014FA  6700 0030                777          BEQ     H2AB
000014FE  B23C 000C                778          CMP.B   #$C,D1         C = 13
00001502  6700 002E                779          BEQ     H2AC
00001506  B23C 000D                780          CMP.B   #$D,D1         D = 14
0000150A  6700 002C                781          BEQ     H2AD
0000150E  B23C 000E                782          CMP.B   #$E,D1         E = 15
00001512  6700 002A                783          BEQ     H2AE
00001516  B23C 000F                784          CMP.B   #$F,D1         F = 16
0000151A  6700 0028                785          BEQ     H2AF
0000151E                           786          
0000151E                           787  H2AADV  * H2A conversion branch helper: Rotate to the next byte, and loop back to H2A until all bytes have been analyzed/converted
0000151E  E199                     788          ROL.L   #8,D1           Rotate 1st byte to the end
00001520  51CA FFCC                789          DBRA    D2,H2A          If count is > 0, decrement and loop back to A2H
00001524  4E75                     790          RTS                     If count == 0, return to sub-routine
00001526                           791  
00001526                           792  * H2A conversion branches
00001526  123C 0011                793  H2AA    MOVE.B  #$11,D1
0000152A  60F2                     794          BRA     H2AADV
0000152C  123C 0012                795  H2AB    MOVE.B  #$12,D1
00001530  60EC                     796          BRA     H2AADV
00001532  123C 0013                797  H2AC    MOVE.B  #$13,D1
00001536  60E6                     798          BRA     H2AADV
00001538  123C 0014                799  H2AD    MOVE.B  #$14,D1
0000153C  60E0                     800          BRA     H2AADV
0000153E  123C 0015                801  H2AE    MOVE.B  #$15,D1
00001542  60DA                     802          BRA     H2AADV
00001544  123C 0016                803  H2AF    MOVE.B  #$16,D1
00001548  60D4                     804          BRA     H2AADV
0000154A                           805  
0000154A                           806  
0000154A                           807  *
0000154A                           808  * Mask: Mask an input
0000154A                           809  * Input value from D0, input mask from D2, output masked value to D1
0000154A                           810  *
0000154A                           811  
0000154A  2200                     812  MASK    MOVE.L  D0,D1           Move the input to D1
0000154C  C282                     813          AND.L   D2,D1           Perform AND on input with the mask
0000154E  4E75                     814          RTS                     Return to caller
00001550                           815  
00001550                           816  *
00001550                           817  * Test Mask: Test an input to a mask.
00001550                           818  * Input value from D0, input mask from D2, and modify z-flag
00001550                           819  *
00001550                           820  
00001550  2F01                     821  TSTMSK  MOVE.L  D1,-(SP)        Push D1 on stack
00001552  61F6                     822          BSR     MASK            Mask the input
00001554  B481                     823          CMP.L   D1,D2           Test if the input matched the mask
00001556  6606                     824          BNE     *+8             If it didn't match, skip two lines
00001558  221F                     825          MOVE.L  (SP)+,D1        Restore D1
0000155A  6000 FEC6                826          BRA     FLAGST          Set flag & return to caller
0000155E  221F                     827          MOVE.L  (SP)+,D1        Restore D1
00001560  6000 FEC6                828          BRA     FLAGCL          Clear flag & return to caller
00001564                           829  
00001564                           830  *
00001564                           831  * Compare Mask: Strictly test an input to two masks allowing don't cares.
00001564                           832  * Input value from D0, input 1 mask from D2, input 0 mask from D3, and modify z-flag
00001564                           833  *
00001564                           834  
00001564  48E7 F800                835  CMPMSK  MOVEM.L D0-D4,-(SP)     Push D1-D4 on stack
00001568  2800                     836          MOVE.L  D0,D4           Copy input to D4
0000156A  C082                     837          AND.L   D2,D0           AND 1 mask to input
0000156C  B480                     838          CMP.L   D0,D2           Compare masked input to 1 mask
0000156E  6708                     839          BEQ     *+10            If it matched, skip two lines
00001570  4CDF 001F                840          MOVEM.L (SP)+,D0-D4     If it didn't match, restore D1-D4
00001574  6000 FEB2                841          BRA     FLAGCL          Clear flag & return to caller
00001578  2004                     842          MOVE.L  D4,D0           Restore input
0000157A  4680                     843          NOT.L   D0              !input
0000157C  C083                     844          AND.L   D3,D0           AND 0 mask on input; effectively, NOR 0 mask to the input
0000157E  B680                     845          CMP.L   D0,D3           Compare masked input to 0 mask
00001580  6608                     846          BNE     *+10            If it didn't match, skip to clear flag
00001582  4CDF 001F                847          MOVEM.L (SP)+,D0-D4     If it matched, restore D1-D4
00001586  6000 FE9A                848          BRA     FLAGST          Set flag & return to caller
0000158A  4CDF 001F                849          MOVEM.L (SP)+,D0-D4     Restore D1-D4
0000158E  6000 FE98                850          BRA     FLAGCL          Clear flag & return to caller
00001592                           851  
00001592                           852  *        
00001592                           853  * Extract Mask: Test an input to a subsequent mask, and return the masked value in LSB format
00001592                           854  * Input value from D0, input mask from D2, output value in D1
00001592                           855  *
00001592                           856  
00001592  2F02                     857  EXTMSK  MOVE.L  D2,-(SP)        Push D2 on stack
00001594  2200                     858          MOVE.L  D0,D1           Move the input to D1
00001596  C282                     859          AND.L   D2,D1           Perform AND on input with the mask
00001598  0802 0000                860  EXTLP   BTST.L  #0,D2           Test the LSB of the mask for 0
0000159C  6700 0006                861          BEQ     EXTADV          If it is 0, rotate the mask until it is 1
000015A0  241F                     862          MOVE.L  (SP)+,D2        Restore the mask
000015A2  4E75                     863          RTS                     Return to caller
000015A4                           864          
000015A4  E28A                     865  EXTADV  LSR.L   #1,D2           Rotate mask right by 1 bit
000015A6  E299                     866          ROR.L   #1,D1           Rotate output in sync with mask
000015A8  60EE                     867          BRA     EXTLP           Return to loop
000015AA                           868  
000015AA                           869  *
000015AA                           870  * Display ASCII: Display the ASCII from D0.L to screen
000015AA                           871  *
000015AA  48E7 E000                872  DSPAX   MOVEM.L D0-D2,-(SP)     Push D0-D2
000015AE  2200                     873          MOVE.L  D0,D1
000015B0  6000 0044                874          BRA     DSPHST          Branch to DISPHX Start
000015B4                           875  
000015B4                           876  *
000015B4                           877  * Display HEX Address: Display the hex from A1 according to the byte length in D2.L
000015B4                           878  *
000015B4                           879  
000015B4  48E7 E040                880  DSPHXA  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
000015B8  51CA 0006                881  DSPHXLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
000015BC  6000 0016                882          BRA     DSPHXRT         If count is <= 0, branch to return
000015C0  1019                     883          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
000015C2  6100 FEF8                884          BSR     HEX2ASCII       Get ASCII in D1
000015C6  E159                     885          ROL.W   #8,D1           Read first byte
000015C8  103C 0006                886          MOVE.B  #6,D0           Display char from D1.B
000015CC  4E4F                     887          TRAP    #15
000015CE  E159                     888          ROL.W   #8,D1           Read second byte
000015D0  4E4F                     889          TRAP    #15
000015D2  60E4                     890          BRA     DSPHXLP         Loop back
000015D4  4CDF 0207                891  DSPHXRT MOVEM.L (SP)+,D0-D2/A1  Else, restore values
000015D8  4E75                     892          RTS                     Return to caller
000015DA                           893          
000015DA                           894  
000015DA                           895  
000015DA                           896  *
000015DA                           897  * Display HEX Nibble: Display the hex from D0.B to screen
000015DA                           898  *
000015DA                           899  
000015DA  48E7 C000                900  DSPHXN  MOVEM.L D0/D1,-(SP)     Push D0 and D1 to stack
000015DE  6100 FEDC                901          BSR     HEX2ASCII       Get ASCII in D1
000015E2  103C 0006                902          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
000015E6  4E4F                     903          TRAP    #15
000015E8  4CDF 0003                904          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
000015EC  4E75                     905          RTS                     Return to caller
000015EE                           906  
000015EE                           907  *
000015EE                           908  * Display HEX Word: Display the hex from D0.W to screen
000015EE                           909  *
000015EE                           910  
000015EE  48E7 E000                911  DSPHXW  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
000015F2  6100 FEC8                912          BSR     HEX2ASCII       Get ASCII in D1
000015F6                           913  
000015F6  4282                     914  DSPHST  CLR.L   D2              
000015F8  143C 0003                915          MOVE.B  #3,D2           Set rotation count
000015FC  103C 0006                916          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
00001600  6100 0008                917          BSR     DSPHADV         Start loop
00001604                           918  
00001604  4CDF 0007                919          MOVEM.L  (SP)+,D0-D2    Restore D0-D2
00001608  4E75                     920          RTS                     Return to caller
0000160A                           921  
0000160A  E199                     922  DSPHADV ROL.L   #8,D1           Rotate bytes left
0000160C  4E4F                     923          TRAP    #15             Display char in D1.B
0000160E  51CA FFFA                924          DBRA    D2,DSPHADV      If count is > 0, decrement and loop back to DSPHADV
00001612  4E75                     925          RTS                     If count == 0, return to sub-routine
00001614                           926  
00001614                           927  *
00001614                           928  * Display HEX Long: Display the hex from D0.L to screen
00001614                           929  *
00001614                           930  
00001614  4840                     931  DSPHXL  SWAP    D0              Swap first half to D0.W
00001616  61D6                     932          BSR     DSPHXW          Display first half
00001618  4840                     933          SWAP    D0              Swap lower half to D0.W
0000161A  61D2                     934          BSR     DSPHXW          Display lower half
0000161C  4E75                     935          RTS                     Return to caller
0000161E                           936          
0000161E                           937  
0000161E                           938          
0000161E                           939  *--------------------
0000161E                           940  *   I/O
0000161E                           941  *--------------------                   
0000161E  43F8 13CA                942  ILL0    LEA     ERR0,A1         Starting location was too small
00001622  103C 000E                943          MOVE.B  #14,D0
00001626  4E4F                     944          TRAP    #15
00001628  6000 000C                945          BRA     PRMPT1
0000162C                           946          
0000162C  43F8 13ED                947  ILL1    LEA     ERR1,A1         Starting location was too big
00001630  103C 000E                948          MOVE.B  #14,D0
00001634  4E4F                     949          TRAP    #15
00001636                           950          
00001636  43F8 1290                951  PRMPT1  LEA     MSSG1,A1        Starting location request message
0000163A  103C 000E                952          MOVE.B  #14,D0
0000163E  4E4F                     953          TRAP    #15
00001640                           954          
00001640  43F8 1004                955          LEA     SLOC,A1         Input will be stored in SLOC
00001644  103C 0002                956          MOVE.B  #2,D0           Input starting location (as string / hex)
00001648  4E4F                     957          TRAP    #15
0000164A                           958          
0000164A  2038 1004                959          MOVE.L  (SLOC),D0       Move input to D0
0000164E                           960  
0000164E  B0BC 00FFFFFF            961          CMP.L   #$00FFFFFF,D0   Check if input was NULL
00001654  660C                     962          BNE     *+14            If the input was not null, branch to convert input
00001656  21FC 00007000 1004       963          MOVE.L  #MNADDR,(SLOC)  If the input was null, move the min address to SLOC
0000165E  6000 003E                964          BRA     PRMPT2          Branch to the next prompt
00001662                           965          
00001662  6100 FDCA                966          BSR     ASCII2HEX       Convert D0 to HEX in D1
00001666                           967          
00001666  2281                     968          MOVE.L  D1,(A1)         Set SLOC to HEX value
00001668                           969                          
00001668  B2BC 00000000            970          CMP.L   #0,D1           Compare starting location to 0
0000166E  6700 058C                971          BEQ     DONE            End program if 0
00001672                           972          
00001672  B2BC 00007000            973          CMP.L   #MNADDR,D1      Compare starting location to min
00001678  65A4                     974          BLO     ILL0            Branch to ILL0 if < min
0000167A                           975          
0000167A  B2BC 00FFFFFF            976          CMP.L   #MXADDR,D1      Compare ending location to max
00001680  64AA                     977          BHS     ILL1            Branch to ILL1 if >= max
00001682                           978                  
00001682  6000 001A                979          BRA     PRMPT2          Branch to the next prompt
00001686                           980  
00001686  43F8 13CA                981  ILL2    LEA     ERR0,A1         Ending location was too small
0000168A  103C 000E                982          MOVE.B  #14,D0
0000168E  4E4F                     983          TRAP    #15
00001690  6000 000C                984          BRA     PRMPT2
00001694                           985          
00001694  43F8 13ED                986  ILL3    LEA     ERR1,A1         Ending location was too big
00001698  103C 000E                987          MOVE.B  #14,D0
0000169C  4E4F                     988          TRAP    #15
0000169E                           989          
0000169E  43F8 12F9                990  PRMPT2  LEA     MSSG2,A1        Ending location request message
000016A2  103C 000E                991          MOVE.B  #14,D0
000016A6  4E4F                     992          TRAP    #15
000016A8                           993          
000016A8  43F8 1008                994          LEA     ELOC,A1         Input will be stored in SLOC
000016AC  103C 0002                995          MOVE.B  #2,D0           Input starting location (as string / hex)
000016B0  4E4F                     996          TRAP    #15
000016B2                           997          
000016B2  2038 1008                998          MOVE.L  (ELOC),D0       Move input to D0
000016B6                           999  
000016B6  B0BC 00FFFFFF           1000          CMP.L   #$00FFFFFF,D0   Check if input was NULL
000016BC  660C                    1001          BNE     *+14            If the input was not null, branch to convert input
000016BE  21FC 00FFFFFF 1008      1002          MOVE.L  #MXADDR,(ELOC)  If the input was null, move the max address to ELOC
000016C6  6000 002A               1003          BRA     PRMPTDN         Branch to prompt done
000016CA                          1004          
000016CA  6100 FD62               1005          BSR     ASCII2HEX       Convert D0 to HEX in D1
000016CE                          1006          
000016CE  2281                    1007          MOVE.L  D1,(A1)         Set ELOC to HEX value
000016D0                          1008  
000016D0  B2BC 00000000           1009          CMP.L   #0,D1           Compare ending location to 0
000016D6  6700 0524               1010          BEQ     DONE            End program if 0
000016DA                          1011          
000016DA  B2BC 00007000           1012          CMP.L   #MNADDR,D1      Compare min ending location to min
000016E0  63A4                    1013          BLS     ILL2            Branch to ILL2 if <= min
000016E2                          1014          
000016E2  B2BC 00FFFFFF           1015          CMP.L   #MXADDR,D1      Compare ending location to max
000016E8  62AA                    1016          BHI     ILL3            Branch to ILL3 if > max
000016EA                          1017          
000016EA  2038 1004               1018          MOVE.L  (SLOC),D0       Move starting location data to D0
000016EE  B280                    1019          CMP.L   D0,D1           Compare ending location to starting location
000016F0  6394                    1020          BLS     ILL2            Branch to ILL3 if <= starting location
000016F2                          1021          
000016F2  21F8 1004 1000          1022  PRMPTDN MOVE.L  SLOC,GBUFF      Store starting location in GBUFF for OP
000016F8  6000 04E6               1023          BRA     DSPHDR          Branch to display method
000016FC                          1024  
000016FC                          1025  *
000016FC                          1026  * Display string: Displays string until NULL char
000016FC                          1027  * Input string at A1, output length of string at D1.B
000016FC                          1028  * Max length: 255
000016FC                          1029  *
000016FC                          1030          
000016FC  48E7 E040               1031  DSPSTR  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
00001700  243C 000000FF           1032          MOVE.L  #255,D2         Set count to 255
00001706  51CA 0006               1033  DSPSTLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
0000170A  6000 0016               1034          BRA     DSPSTRT         If count is <= 0, branch to return
0000170E  1019                    1035          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
00001710  B03C 0000               1036          CMP.B   #0,D0           Check if byte is NULL char
00001714  6700 000C               1037          BEQ     DSPSTRT         If byte is NULL char, branch to return
00001718  6100 FDA2               1038          BSR     HEX2ASCII       Else, get ASCII in D1
0000171C  6100 FE8C               1039          BSR     DSPAX           Display ASCII
00001720  60E4                    1040          BRA     DSPSTLP         Loop back
00001722  4482                    1041  DSPSTRT NEG.L   D2              Negate count
00001724  0682 000000FE           1042          ADD.L   #254,D2         Add 254; effectively 255 - count - null byte
0000172A  4CDF 0003               1043          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
0000172E  1202                    1044          MOVE.B  D2,D1           Move length to D1
00001730  4CDF 0204               1045          MOVEM.L (SP)+,D2/A1     Restore D2 and A1
00001734  4E75                    1046          RTS                     Return to caller
00001736                          1047  
00001736                          1048  *
00001736                          1049  * Display offset space: Display space according to offset length
00001736                          1050  * Input offset length in D2.B
00001736                          1051  *
00001736                          1052  
00001736  48E7 E000               1053  DSPOFS  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
0000173A                          1054          * Ensure count is strictly in one byte
0000173A  4280                    1055          CLR.L   D0
0000173C  1002                    1056          MOVE.B  D2,D0
0000173E  2400                    1057          MOVE.L  D0,D2
00001740  51CA 0006               1058  DSPOFLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001744  6000 000E               1059          BRA     DSPOFRT         If count is <= 0, branch to return
00001748  103C 0006               1060          MOVE.B  #6,D0           Display character
0000174C  123C 0020               1061          MOVE.B  #' ',D1         Read space
00001750  4E4F                    1062          TRAP    #15
00001752  60EC                    1063          BRA     DSPOFLP         Loop back
00001754  4CDF 0007               1064  DSPOFRT MOVEM.L (SP)+,D0-D2     Restore D0-D2
00001758  4E75                    1065          RTS                     Return to callr
0000175A                          1066  
0000175A                          1067  *
0000175A                          1068  * Display An: Displays An or SP if n == 7
0000175A                          1069  * Input n in D3
0000175A                          1070  *
0000175A                          1071  
0000175A  B63C 0007               1072  DSPAn   CMP.B   #7,D3               Compare n to 7
0000175E  6700 0016               1073          BEQ     DSPSP               If ==, branch to Display SP
00001762  103C 0006               1074          MOVE.B  #6,D0               Else, display character
00001766  123C 0041               1075          MOVE.B  #'A',D1             Read A
0000176A  4E4F                    1076          TRAP    #15
0000176C  4280                    1077          CLR.L   D0
0000176E  2003                    1078          MOVE.L  D3,D0               Read reg from D3
00001770  6100 FE68               1079          BSR     DSPHXN              Display as hex nibble
00001774  4E75                    1080          RTS                         Return to caller
00001776                          1081  
00001776  103C 0006               1082  DSPSP   MOVE.B  #6,D0               Display character
0000177A  123C 0053               1083          MOVE.B  #'S',D1             Read S
0000177E  4E4F                    1084          TRAP    #15
00001780  123C 0050               1085          MOVE.B  #'P',D1             Read P
00001784  4E4F                    1086          TRAP    #15
00001786  4E75                    1087          RTS                         Return to caller
00001788                          1088  
00001788                          1089  *
00001788                          1090  * Brief Extension Word: Displays a brief extension word (without displacement)
00001788                          1091  * Input BEW to D0.B
00001788                          1092  * X|REG|S|SC|0 -> Xn.S * SC
00001788                          1093  * X (Index Register Type):
00001788                          1094  *   0 = Dn
00001788                          1095  *   1 = An
00001788                          1096  * S (Index Size):
00001788                          1097  *   0 = Sign-Extended Word
00001788                          1098  *   1 = Long Word
00001788                          1099  * SC (Scale):
00001788                          1100  *   00 = 1
00001788                          1101  *   01 = 2
00001788                          1102  *   10 = 4
00001788                          1103  *   11 = 8
00001788                          1104  *
00001788  48E7 F000               1105  BEXTW   MOVEM.L D0-D3,-(SP)         Push D0-D3 to stack
0000178C  7470                    1106          MOVE.L  #$70,D2             Extract REG at 01110000
0000178E  6100 FE02               1107          BSR     EXTMSK              Get REG to D1
00001792  1601                    1108          MOVE.B  D1,D3               Move REG to D3
00001794  243C 00000080           1109          MOVE.L  #$80,D2             Extract X at 10000000
0000179A  6100 FDF6               1110          BSR     EXTMSK              Get X to D1
0000179E  1401                    1111          MOVE.B  D1,D2               Move MODE to D2
000017A0  6100 0074               1112          BSR     DISPOP              Display Xn
000017A4  7408                    1113          MOVE.L  #8,D2               Extract S at 00001000
000017A6  6100 FDEA               1114          BSR     EXTMSK              Get S to D1
000017AA  1601                    1115          MOVE.B  D1,D3               Move S to D3
000017AC  7406                    1116          MOVE.L  #6,D2               Extract SC at 00000110
000017AE  6100 FDE2               1117          BSR     EXTMSK              Get SC to D1
000017B2  C2FC 0004               1118          MULU.W  #4,D1               Convert D1 to displacement
000017B6  4EFB 1002               1119          JMP     SCTBL(PC,D1.W)      Jump to SC mode
000017BA  6000 000E               1120  SCTBL   BRA     SC0                 00
000017BE  6000 0012               1121          BRA     SC1                 01
000017C2  6000 0016               1122          BRA     SC2                 10
000017C6  6000 001A               1123          BRA     SC3                 11
000017CA  143C 0001               1124  SC0     MOVE.B  #1,D2               00 = 1
000017CE  6000 001A               1125          BRA     SC4
000017D2  143C 0002               1126  SC1     MOVE.B  #2,D2               01 = 2
000017D6  6000 0012               1127          BRA     SC4
000017DA  143C 0004               1128  SC2     MOVE.B  #4,D2               10 = 4
000017DE  6000 000A               1129          BRA     SC4
000017E2  143C 0008               1130  SC3     MOVE.B  #8,D2               11 = 8
000017E6  6000 0002               1131          BRA     SC4
000017EA  103C 0006               1132  SC4     MOVE.B  #6,D0               Display character
000017EE  123C 002E               1133          MOVE.B  #'.',D1              Read . to D1
000017F2  4E4F                    1134          TRAP    #15
000017F4  123C 004C               1135          MOVE.B  #'L',D1             Read L to D1 as default
000017F8  4A03                    1136          TST.B   D3                  Test D3 for W
000017FA  6604                    1137          BNE     *+6                 If !=, skip next line
000017FC  123C 0057               1138          MOVE.B  #'W',D1             Else, read W to D1
00001800  4E4F                    1139          TRAP    #15
00001802  123C 002A               1140          MOVE.B  #'*',D1             Read *
00001806  4E4F                    1141          TRAP    #15
00001808  103C 0003               1142          MOVE.B  #3,D0               Display number
0000180C  1202                    1143          MOVE.B  D2,D1               Read scale
0000180E  4E4F                    1144          TRAP    #15
00001810  4CDF 000F               1145          MOVEM.L (SP)+,D0-D3         Restore D0-D3
00001814  4E75                    1146          RTS                         Return to caller
00001816                          1147  
00001816                          1148  *
00001816                          1149  * Display operand: Displays operand according to mode and register
00001816                          1150  * Input mode in D2.B, input reg in D3.B
00001816                          1151  *
00001816                          1152  
00001816  48E7 E000               1153  DISPOP  MOVEM.L D0-D2,-(SP)         Push D0-D2 to stack
0000181A  103C 0006               1154          MOVE.B  #6,D0               Display character
0000181E  C4FC 0004               1155          MULU.W  #4,D2
00001822  4EFB 2002               1156          JMP     DMDTBL(PC,D2.W)     Jump to mode
00001826  6000 001E               1157  DMDTBL  BRA     DISP0               Dn
0000182A  6000 002C               1158          BRA     DISP1               An
0000182E  6000 0030               1159          BRA     DISP2               (An)
00001832  6000 0044               1160          BRA     DISP3               (An)+
00001836  6000 005E               1161          BRA     DISP4               -(An)
0000183A  6000 0078               1162          BRA     DISP5               (d,An)
0000183E  6000 00A8               1163          BRA     DISP6               (d,An,Xn)
00001842  6000 00F0               1164          BRA     DISP7               (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
00001846                          1165  * Dn            000 XXX
00001846  123C 0044               1166  DISP0   MOVE.B  #'D',D1             Read D
0000184A  4E4F                    1167          TRAP    #15
0000184C  4280                    1168          CLR.L   D0
0000184E  1003                    1169          MOVE.B  D3,D0               Read reg from D3
00001850  6100 FD88               1170          BSR     DSPHXN              Display as hex nibble
00001854  6000 01E6               1171          BRA     DISPD               Branch to return
00001858                          1172  * An            001 XXX
00001858  6100 FF00               1173  DISP1   BSR     DSPAn               Display An or SP        
0000185C  6000 01DE               1174          BRA     DISPD               Branch to return
00001860                          1175  * (An)          010 XXX
00001860  123C 0028               1176  DISP2   MOVE.B  #'(',D1             Read (
00001864  4E4F                    1177          TRAP    #15
00001866  6100 FEF2               1178          BSR     DSPAn               Display An or SP
0000186A  103C 0006               1179          MOVE.B  #6,D0               Display character
0000186E  123C 0029               1180          MOVE.B  #')',D1             Read )
00001872  4E4F                    1181          TRAP    #15
00001874  6000 01C6               1182          BRA     DISPD               Branch to return
00001878                          1183  * (An)+         011 XXX
00001878  123C 0028               1184  DISP3   MOVE.B  #'(',D1             Read (
0000187C  4E4F                    1185          TRAP    #15
0000187E  6100 FEDA               1186          BSR     DSPAn               Display An or SP
00001882  103C 0006               1187          MOVE.B  #6,D0               Display character
00001886  123C 0029               1188          MOVE.B  #')',D1             Read )
0000188A  4E4F                    1189          TRAP    #15
0000188C  123C 002B               1190          MOVE.B  #'+',D1             Read +
00001890  4E4F                    1191          TRAP    #15
00001892  6000 01A8               1192          BRA     DISPD               Branch to return
00001896                          1193  * -(An)         100 XXX
00001896  123C 002D               1194  DISP4   MOVE.B  #'-',D1             Read +
0000189A  4E4F                    1195          TRAP    #15
0000189C  123C 0028               1196          MOVE.B  #'(',D1             Read (
000018A0  4E4F                    1197          TRAP    #15
000018A2  6100 FEB6               1198          BSR     DSPAn               Display An or SP
000018A6  103C 0006               1199          MOVE.B  #6,D0               Display character
000018AA  123C 0029               1200          MOVE.B  #')',D1             Read )
000018AE  4E4F                    1201          TRAP    #15
000018B0  6000 018A               1202          BRA     DISPD               Branch to return
000018B4                          1203  * (d16,An)      101 XXX
000018B4  123C 0028               1204  DISP5   MOVE.B  #'(',D1             Read (
000018B8  4E4F                    1205          TRAP    #15
000018BA  103C 0003               1206          MOVE.B  #3,D0               Display signed number
000018BE  2278 1010               1207          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000018C2  3211                    1208          MOVE.W  (A1),D1             Read word to D1
000018C4  48C1                    1209          EXT.L   D1                  Extend word to long
000018C6  4E4F                    1210          TRAP    #15
000018C8  54B8 1010               1211          ADD.L   #2,(IOADDR)         Advance IO address by word
000018CC  103C 0006               1212          MOVE.B  #6,D0               Display character
000018D0  123C 002C               1213          MOVE.B  #',',D1             Read ,
000018D4  4E4F                    1214          TRAP    #15
000018D6  6100 FE82               1215          BSR     DSPAn               Display An or SP
000018DA  103C 0006               1216          MOVE.B  #6,D0               Display character
000018DE  123C 0029               1217          MOVE.B  #')',D1             Read )
000018E2  4E4F                    1218          TRAP    #15
000018E4  6000 0156               1219          BRA     DISPD               Branch to return
000018E8                          1220  * (d8,An,Xn)   110  XXX
000018E8  123C 0028               1221  DISP6   MOVE.B  #'(',D1             Read (
000018EC  4E4F                    1222          TRAP    #15
000018EE  103C 0003               1223          MOVE.B  #3,D0               Display signed number
000018F2  2278 1010               1224          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000018F6  11D9 10C5               1225          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
000018FA  1211                    1226          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
000018FC  4881                    1227          EXT.W   D1                  Extend byte to word
000018FE  48C1                    1228          EXT.L   D1                  Extend word to long
00001900  4E4F                    1229          TRAP    #15
00001902  103C 0006               1230          MOVE.B  #6,D0               Display character
00001906  123C 002C               1231          MOVE.B  #',',D1             Read ,
0000190A  4E4F                    1232          TRAP    #15
0000190C  6100 FE4C               1233          BSR     DSPAn               Display An or SP
00001910  103C 0006               1234          MOVE.B  #6,D0               Display character
00001914  123C 002C               1235          MOVE.B  #',',D1             Read ,
00001918  4E4F                    1236          TRAP    #15
0000191A  1038 10C5               1237          MOVE.B  (DIS),D0            Read (DIS) to D0
0000191E  6100 FE68               1238          BSR     BEXTW               Display Brief Extension Word
00001922  54B8 1010               1239          ADD.L   #2,(IOADDR)         Advance IO address by word
00001926  103C 0006               1240          MOVE.B  #6,D0               Display character
0000192A  123C 0029               1241          MOVE.B  #')',D1             Read )
0000192E  4E4F                    1242          TRAP    #15
00001930  6000 010A               1243          BRA     DISPD               Branch to return
00001934                          1244  * (XXX).W/(XXX).L/(d16,PC)/(d8,PC,Xn)/#data
00001934  C6FC 0004               1245  DISP7   MULU.W  #4,D3
00001938  4EFB 3002               1246          JMP     DRGTBL(PC,D3.W)     Jump to reg
0000193C  6000 0012               1247  DRGTBL  BRA     DISP8               (XXX).W
00001940  6000 002A               1248          BRA     DISP9               (XXX).L
00001944  6000 0042               1249          BRA     DISPA               (d,PC)
00001948  6000 0076               1250          BRA     DISPB               (d,PC,Xn)
0000194C  6000 00C2               1251          BRA     DISPC               #data
00001950                          1252  * (XXX.W)       111 000
00001950                          1253  DISP8   
00001950  123C 0024               1254          MOVE.B  #'$',D1             Read $
00001954  4E4F                    1255          TRAP    #15
00001956  2278 1010               1256          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000195A  4282                    1257          CLR.L   D2
0000195C  143C 0002               1258          MOVE.B  #2,D2               Read word size to D2
00001960  6100 FC52               1259          BSR     DSPHXA              Display address
00001964  D5B8 1010               1260          ADD.L   D2,(IOADDR)         Advance IO address by word
00001968  6000 00D2               1261          BRA     DISPD               Branch to return
0000196C                          1262  * (XXX.L)       111 001
0000196C  123C 0024               1263  DISP9   MOVE.B  #'$',D1             Read $
00001970  4E4F                    1264          TRAP    #15
00001972  2278 1010               1265          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001976  4282                    1266          CLR.L   D2
00001978  143C 0004               1267          MOVE.B  #4,D2               Read long size to D2
0000197C  6100 FC36               1268          BSR     DSPHXA              Display address
00001980  D5B8 1010               1269          ADD.L   D2,(IOADDR)         Advance IO address by long
00001984  6000 00B6               1270          BRA     DISPD               Branch to return
00001988                          1271  * (d16,PC)      111 010
00001988  123C 0028               1272  DISPA   MOVE.B  #'(',D1             Read (
0000198C  4E4F                    1273          TRAP    #15
0000198E  103C 0003               1274          MOVE.B  #3,D0               Display signed number
00001992  2278 1010               1275          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001996  3211                    1276          MOVE.W  (A1),D1             Read word to D1
00001998  48C1                    1277          EXT.L   D1                  Extend word to long
0000199A  4E4F                    1278          TRAP    #15
0000199C  54B8 1010               1279          ADD.L   #2,(IOADDR)         Advance IO address by word
000019A0  103C 0006               1280          MOVE.B  #6,D0               Display character
000019A4  123C 002C               1281          MOVE.B  #',',D1             Read ,
000019A8  4E4F                    1282          TRAP    #15
000019AA  123C 0050               1283          MOVE.B  #'P',D1             Read P
000019AE  4E4F                    1284          TRAP    #15
000019B0  123C 0043               1285          MOVE.B  #'C',D1             Read C
000019B4  4E4F                    1286          TRAP    #15
000019B6  123C 0029               1287          MOVE.B  #')',D1             Read )
000019BA  4E4F                    1288          TRAP    #15
000019BC  6000 007E               1289          BRA     DISPD
000019C0                          1290  * (d8,PC,Xn)    111 011
000019C0  123C 0028               1291  DISPB   MOVE.B  #'(',D1             Read (
000019C4  4E4F                    1292          TRAP    #15
000019C6  103C 0003               1293          MOVE.B  #3,D0               Display signed number
000019CA  2278 1010               1294          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000019CE  11D9 10C5               1295          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
000019D2  1211                    1296          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
000019D4  4881                    1297          EXT.W   D1                  Extend byte to word
000019D6  48C1                    1298          EXT.L   D1                  Extend word to long
000019D8  4E4F                    1299          TRAP    #15
000019DA  103C 0006               1300          MOVE.B  #6,D0               Display character
000019DE  123C 002C               1301          MOVE.B  #',',D1             Read ,
000019E2  4E4F                    1302          TRAP    #15
000019E4  123C 0050               1303          MOVE.B  #'P',D1             Read P
000019E8  4E4F                    1304          TRAP    #15
000019EA  123C 0043               1305          MOVE.B   #'C',D1             Read C
000019EE  4E4F                    1306          TRAP    #15
000019F0  123C 002C               1307          MOVE.B  #',',D1             Read ,
000019F4  4E4F                    1308          TRAP    #15
000019F6  1038 10C5               1309          MOVE.B  (DIS),D0            Read (DIS) to D0
000019FA  6100 FD8C               1310          BSR     BEXTW               Display Brief Extension Word
000019FE  54B8 1010               1311          ADD.L   #2,(IOADDR)         Advance IO address by word
00001A02  103C 0006               1312          MOVE.B  #6,D0               Display character
00001A06  123C 0029               1313          MOVE.B  #')',D1             Read )
00001A0A  4E4F                    1314          TRAP    #15
00001A0C  6000 002E               1315          BRA     DISPD               Branch to return
00001A10                          1316  * #<data>       111 100
00001A10  123C 0023               1317  DISPC   MOVE.B  #'#',D1             Read #
00001A14  4E4F                    1318          TRAP    #15
00001A16  2278 1010               1319          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001A1A  4282                    1320          CLR.L   D2
00001A1C  1438 100E               1321          MOVE.B  (IOSIZE),D2         Read instruction size to D2
00001A20  B43C 0000               1322          CMP.B   #0,D2               Test if size is byte
00001A24  6604                    1323          BNE     *+6                 If !=, skip next line
00001A26  143C 0001               1324          MOVE.B  #1,D2               If ==, change byte to word
00001A2A  C4FC 0002               1325          MULU.W  #2,D2               Translate size to value
00001A2E  6100 FB84               1326          BSR     DSPHXA              Display address
00001A32  D3C2                    1327          ADD.L   D2,A1               Advance A1 by instruction size
00001A34  21C9 1010               1328          MOVE.L  A1,(IOADDR)         Move A1 to IOADDR
00001A38  6000 0002               1329          BRA     DISPD               Branch to return
00001A3C  4CDF 0007               1330  DISPD   MOVEM.L (SP)+,D0-D2         Restore D0-D2
00001A40  4E75                    1331          RTS                         Return to caller
00001A42                          1332          
00001A42  11F8 100C 100D          1333  BRBAD   MOVE.B  (IOOPCD),(IOBDCD)   Move OPCODE to BAD OPCODE
00001A48  11FC 0087 100C          1334          MOVE.B  #$87,(IOOPCD)       Set OPCODE to BAD
00001A4E                          1335          * Clear bad data
00001A4E  11FC 00FF 10C2          1336          MOVE.B  #$FF,(SMD)
00001A54  11FC 00FF 10C3          1337          MOVE.B  #$FF,(SRG)
00001A5A  11FC 00FF 10C0          1338          MOVE.B  #$FF,(DMD)
00001A60  11FC 00FF 10C1          1339          MOVE.B  #$FF,(DRG)
00001A66  11FC 00FF 100E          1340          MOVE.B  #$FF,(IOSIZE)
00001A6C                          1341          
00001A6C                          1342  PRINT   *----TODO----*
00001A6C                          1343          * If OP code exists as BAD and BAD OPCODE don't exist, assume that the last
00001A6C                          1344          * OP display was BAD, and display then next word as raw data
00001A6C  0C38 00FF 100C          1345          CMP.B   #$FF,(IOOPCD)       Test if OP code exists
00001A72  67CE                    1346          BEQ     BRBAD               If it does not, display BAD
00001A74                          1347  
00001A74  2038 1010               1348          MOVE.L  (IOADDR),D0         Read memory location
00001A78  6100 FB9A               1349          BSR     DSPHXL              Display as hex long
00001A7C  103C 0006               1350          MOVE.B  #6,D0               Display character
00001A80  123C 0009               1351          MOVE.B  #TB,D1              Read tab
00001A84  4E4F                    1352          TRAP    #15
00001A86                          1353  
00001A86  4280                    1354          CLR.L   D0
00001A88  4282                    1355          CLR.L   D2
00001A8A  43F8 1016               1356          LEA     OPNAME,A1           Read OP-code
00001A8E  1038 100C               1357          MOVE.B  (IOOPCD),D0         Get offset
00001A92  D3C0                    1358          ADD.L   D0,A1               Add offset
00001A94  6100 FC66               1359          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001A98  1401                    1360          MOVE.B  D1,D2               Store length in D2 to be used as space offset
00001A9A                          1361      
00001A9A  0C38 00FF 100D          1362          CMP.B   #$FF,(IOBDCD)       Test if BAD OP code exists
00001AA0  6732                    1363          BEQ     *+52                If it doesn't exist, don't display it
00001AA2  103C 0006               1364          MOVE.B  #6,D0               Display character
00001AA6  123C 0020               1365          MOVE.B  #' ',D1             Read space
00001AAA  4E4F                    1366          TRAP    #15
00001AAC  123C 0028               1367          MOVE.B  #'(',D1             Read (
00001AB0  4E4F                    1368          TRAP    #15
00001AB2  43F8 1016               1369          LEA     OPNAME,A1           Read OP-code
00001AB6  1038 100D               1370          MOVE.B  (IOBDCD),D0         Get offset
00001ABA  D3C0                    1371          ADD.L   D0,A1               Add offset
00001ABC  6100 FC3E               1372          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001AC0  D401                    1373          ADD.B   D1,D2               Add length to space offset
00001AC2  103C 0006               1374          MOVE.B  #6,D0               Display character
00001AC6  123C 003F               1375          MOVE.B  #'?',D1
00001ACA  4E4F                    1376          TRAP    #15                 Read ?
00001ACC  123C 0029               1377          MOVE.B  #')',D1             Read )
00001AD0  4E4F                    1378          TRAP    #15
00001AD2  5402                    1379          ADD.B   #2,D2               Add 2 to space offset to account for ( and )
00001AD4                          1380  
00001AD4  43F8 10B4               1381          LEA     IOOPSZ,A1           Read OP code size
00001AD8  103C 0003               1382          MOVE.B  #$03,D0             Set size to 3
00001ADC  0C38 00FF 100E          1383          CMP.B   #$FF,(IOSIZE)       Test if OP size exists
00001AE2  6704                    1384          BEQ     *+6                 If OP size doesn't exist, skip the next line
00001AE4  1038 100E               1385          MOVE.B  (IOSIZE),D0         If OP size exists, move it to D0
00001AE8  C0FC 0003               1386          MULU.W  #$3,D0              Multiply size by 3 for correct offset
00001AEC  D3C0                    1387          ADD.L   D0,A1               Add offset
00001AEE  6100 FC0C               1388          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001AF2                          1389          
00001AF2  D401                    1390          ADD.B   D1,D2               Add length to space offset
00001AF4  4442                    1391          NEG.W   D2                  Negate space offset
00001AF6  0642 000B               1392          ADD.W   #11,D2              Add 11 to space offset; effectively 11 - space offset
00001AFA                          1393  
00001AFA  6100 FC3A               1394          BSR     DSPOFS              Display space offset with tab
00001AFE                          1395  
00001AFE  54B8 1010               1396          ADD.L   #2,(IOADDR)         Move memory location past first word
00001B02                          1397  
00001B02  4204                    1398          CLR.B   D4                  Set source to false
00001B04  4242                    1399          CLR.W   D2
00001B06  4243                    1400          CLR.W   D3
00001B08  1438 10C2               1401          MOVE.B  (SMD),D2            Read source mode to D2
00001B0C  B43C 00FF               1402          CMP.B   #$FF,D2             Test if it exists
00001B10  6700 0016               1403          BEQ     NOSRC               If it does not exist, do not display source
00001B14  1638 10C3               1404          MOVE.B  (SRG),D3            Read source reg to D3
00001B18  B63C 00FF               1405          CMP.B   #$FF,D3             Test if it exists
00001B1C  6700 000A               1406          BEQ     NOSRC               If it does not exist, do not display source
00001B20  6100 FCF4               1407          BSR     DISPOP              If both mode & register exist, display accordingly
00001B24  183C 0001               1408          MOVE.B  #1,D4               Set source to true
00001B28                          1409  
00001B28  4242                    1410  NOSRC   CLR.W   D2
00001B2A  4243                    1411          CLR.W   D3
00001B2C  1438 10C0               1412          MOVE.B  (DMD),D2            Read dest mode to D2
00001B30  B43C 00FF               1413          CMP.B   #$FF,D2             Test if it exists
00001B34  6700 0024               1414          BEQ     NODST               If it does not exist, do not display dest
00001B38  1638 10C1               1415          MOVE.B  (DRG),D3            Read dest reg to D3
00001B3C  B63C 00FF               1416          CMP.B   #$FF,D3             Test if it exists
00001B40  6700 0018               1417          BEQ     NODST               If it does not exist, do not display dest
00001B44                          1418  
00001B44  103C 0006               1419          MOVE.B  #6,D0               Display character
00001B48  123C 002C               1420          MOVE.B  #',',D1             Read comma
00001B4C  B83C 0001               1421          CMP.B   #1,D4               Test if source was displayed
00001B50  6600 0000               1422          BNE     *+2                 If it was not displayed, don't display a comma
00001B54  4E4F                    1423          TRAP    #15                 If it was displayed, display a comma
00001B56                          1424  
00001B56  6100 FCBE               1425          BSR     DISPOP              If both mode & register exist, display accordingly
00001B5A                          1426  
00001B5A  103C 0006               1427  NODST   MOVE.B  #6,D0               Display character
00001B5E  123C 0009               1428          MOVE.B  #TB,D1              Read tab
00001B62  4E4F                    1429          TRAP    #15
00001B64                          1430  
00001B64  123C 000D               1431          MOVE.B  #CR,D1
00001B68  4E4F                    1432          TRAP    #15
00001B6A  123C 000A               1433          MOVE.B  #LF,D1
00001B6E  4E4F                    1434          TRAP    #15
00001B70                          1435  
00001B70                          1436          *DISPLAY IO OPERAND
00001B70                          1437          
00001B70  2078 1000               1438          MOVE.L  GBUFF,A0            Set A0 to ELOC location
00001B74  B1F8 1008               1439          CMPA.L  ELOC,A0             Compare next buffer to ending location
00001B78  6C00 0082               1440          BGE     DONE                Branch to DONE if >= ending location
00001B7C                          1441  
00001B7C  5238 1014               1442          ADD.B   #1,IOLC
00001B80  0C38 001E 1014          1443          CMP.B   #30,IOLC            Compare #30 to line counter
00001B86  6700 0034               1444          BEQ     PAUSE               If ==, branch to PAUSE
00001B8A                          1445  
00001B8A                          1446          * Reset IO instruction values
00001B8A  11FC 00FF 10C2          1447          MOVE.B  #$FF,(SMD)
00001B90  11FC 00FF 10C3          1448          MOVE.B  #$FF,(SRG)
00001B96  11FC 00FF 10C0          1449          MOVE.B  #$FF,(DMD)
00001B9C  11FC 00FF 10C1          1450          MOVE.B  #$FF,(DRG)
00001BA2  11FC 00FF 100C          1451          MOVE.B  #$FF,(IOOPCD)
00001BA8  11FC 00FF 100D          1452          MOVE.B  #$FF,(IOBDCD)
00001BAE  11FC 00FF 100E          1453          MOVE.B  #$FF,(IOSIZE)
00001BB4  54B8 1000               1454          ADD.L   #$2,(GBUFF)     Advance buffer
00001BB8                          1455  
00001BB8  6000 006A               1456          BRA     OP                  Branch to OP for next instruction
00001BBC                          1457  
00001BBC  43F8 135E               1458  PAUSE   LEA     MSSG4,A1            Display keypress prompt
00001BC0  103C 000E               1459          MOVE.B  #14,D0
00001BC4  4E4F                    1460          TRAP    #15
00001BC6  103C 000C               1461          MOVE.B  #12,D0              Hide keyboard input
00001BCA  123C 0000               1462          MOVE.B  #0,D1
00001BCE  4E4F                    1463          TRAP    #15
00001BD0  103C 0005               1464          MOVE.B  #5,D0               Request keyboard input
00001BD4  4E4F                    1465          TRAP    #15
00001BD6                          1466  *----TODO----*
00001BD6                          1467  * Test if keycode was for ENTER
00001BD6  103C 000C               1468          MOVE.B  #12,D0              Show keyboard input
00001BDA  123C 0001               1469          MOVE.B  #1,D1
00001BDE  4E4F                    1470          TRAP    #15
00001BE0  103C 000B               1471  DSPHDR  MOVE.B  #11,D0              Clear the screen
00001BE4  323C FF00               1472          MOVE.W  #$FF00,D1
00001BE8  4E4F                    1473          TRAP    #15
00001BEA  43F8 13A8               1474          LEA     HEADR,A1            Display header
00001BEE  103C 000E               1475          MOVE.B  #14,D0
00001BF2  4E4F                    1476          TRAP    #15
00001BF4  4238 1014               1477          CLR.B   (IOLC)              Reset line counter
00001BF8  6000 002A               1478          BRA     OP
00001BFC                          1479  
00001BFC  43F8 137F               1480  DONE    LEA     MSSG5,A1            Display end message
00001C00  103C 000E               1481          MOVE.B  #14,D0
00001C04  4E4F                    1482          TRAP    #15
00001C06  103C 0009               1483          MOVE.B  #9,D0
00001C0A  4E4F                    1484          TRAP    #15
00001C0C                          1485  
00001C0C                          1486  *--------------------
00001C0C                          1487  *   OP
00001C0C                          1488  *--------------------
00001C0C                          1489  
00001C0C                          1490  *
00001C0C                          1491  * Jump Mask: Use CMPMSK, and jumps to the OP branch if it returns true
00001C0C                          1492  * Input CMPMSK inputs, input A0 for OP branch
00001C0C                          1493  *
00001C0C                          1494  
00001C0C  6100 F956               1495  JMPMSK  BSR     CMPMSK          Branch to CMPMSK
00001C10  6610                    1496          BNE.S   *+18            If the bits did not match, return to caller
00001C12  4E90                    1497          JSR     (A0)            If the bits matched, branch to the OP address
00001C14  660A                    1498          BNE     *+12            If the OP address was read ybsuccessful, skip the next two lines
00001C16  21C9 1000               1499          MOVE.L  A1,GBUFF        The buffer was good, move it to GBUFF
00001C1A  6000 FE50               1500          BRA     PRINT           Branch to PRINT     
00001C1E  2278 1000               1501          MOVE.L  GBUFF,A1        The buffer was bad, restore A1
00001C22  4E75                    1502          RTS                     Return to caller for next instruction
00001C24                          1503  
00001C24  2078 1000               1504  OP      MOVE.L  GBUFF,A0        Set A0 to GBUFF location
00001C28  2278 1000               1505          MOVE.L  GBUFF,A1        Set A1 to GBUFF location for sub-routines
00001C2C  143C 0000               1506          MOVE.B  #0,D2           Set NULL count to 0
00001C30  0C90 FFFFFFFF           1507          CMP.L   #$FFFFFFFF,(A0) Check for NULL
00001C36  67C4                    1508          BEQ     DONE            If NULL, branch to DONE
00001C38  3018                    1509          MOVE.W  (A0)+,D0        Transfer word data to D0, post-increment location
00001C3A  3210                    1510          MOVE.W  (A0),D1         Transfer next word data to D1
00001C3C  21F8 1000 1010          1511          MOVE.L   GBUFF,IOADDR   Set memory location for IO
00001C42                          1512  *-----
00001C42                          1513  * 0000
00001C42                          1514  *-----
00001C42                          1515          * ORI:    00000000XXXXXXXX
00001C42  343C 0000               1516          MOVE.W  #%0000000000000000,D2
00001C46  363C FF00               1517          MOVE.W  #%1111111100000000,D3
00001C4A  207C 0000224E           1518          MOVE.L  #BRORI,A0
00001C50  61BA                    1519          BSR     JMPMSK
00001C52                          1520  
00001C52                          1521          * SUBI:   00000100XXXXXXXX
00001C52  343C 0400               1522          MOVE.W  #%0000010000000000,D2
00001C56  363C FB00               1523          MOVE.W  #%1111101100000000,D3
00001C5A  207C 00002280           1524          MOVE.L  #BRSUBI,A0
00001C60  61AA                    1525          BSR     JMPMSK
00001C62                          1526  
00001C62                          1527          * ADDI:   00000110XXXXXXXX
00001C62  343C 0600               1528          MOVE.W  #%0000011000000000,D2
00001C66  363C F900               1529          MOVE.W  #%1111100100000000,D3
00001C6A  207C 00002088           1530          MOVE.L  #BRADDI,A0
00001C70  619A                    1531          BSR     JMPMSK
00001C72                          1532  
00001C72                          1533          * BTST:   0000100000XXXXXX
00001C72  343C 0800               1534          MOVE.W  #%0000100000000000,D2
00001C76  363C F7C0               1535          MOVE.W  #%1111011111000000,D3
00001C7A  207C 0000209C           1536          MOVE.L  #BRBTST,A0
00001C80  618A                    1537          BSR     JMPMSK
00001C82                          1538  
00001C82                          1539          * EORI:   00001010XXXXXXXX
00001C82  343C 0A00               1540          MOVE.W  #%0000101000000000,D2
00001C86  363C F500               1541          MOVE.W  #%1111010100000000,D3
00001C8A  207C 00002258           1542          MOVE.L  #BREORI,A0
00001C90  6100 FF7A               1543          BSR     JMPMSK
00001C94                          1544  
00001C94                          1545          * CMPI:   00001100XXXXXXXX
00001C94  343C 0C00               1546          MOVE.W  #%0000110000000000,D2
00001C98  363C F300               1547          MOVE.W  #%1111001100000000,D3
00001C9C  207C 000020EC           1548          MOVE.L  #BRCMPI,A0
00001CA2  6100 FF68               1549          BSR     JMPMSK
00001CA6                          1550  *-----
00001CA6                          1551  * 0001
00001CA6                          1552  *-----
00001CA6                          1553          * MOVE.B: 0001XXXXXXXXXXXX
00001CA6  343C 1000               1554          MOVE.W  #%0001000000000000,D2
00001CAA  363C E000               1555          MOVE.W  #%1110000000000000,D3
00001CAE  207C 00002172           1556          MOVE.L  #BRMOVE,A0
00001CB4  6100 FF56               1557          BSR     JMPMSK
00001CB8                          1558  *-----
00001CB8                          1559  * 0010
00001CB8                          1560  *-----
00001CB8                          1561          * MOVE.L: 0010XXXXXXXXXXXX
00001CB8  343C 2000               1562          MOVE.W  #%0010000000000000,D2
00001CBC  363C D000               1563          MOVE.W  #%1101000000000000,D3
00001CC0  6100 FF4A               1564          BSR     JMPMSK
00001CC4                          1565  *-----
00001CC4                          1566  * 0011
00001CC4                          1567  *-----
00001CC4                          1568          * MOVE.W: 0011XXXXXXXXXXXX 
00001CC4  343C 3000               1569          MOVE.W  #%0011000000000000,D2
00001CC8  363C C000               1570          MOVE.W  #%1100000000000000,D3
00001CCC  6100 FF3E               1571          BSR     JMPMSK
00001CD0                          1572  *-----
00001CD0                          1573  * 0100
00001CD0                          1574  *-----
00001CD0                          1575          * NOT:    01000110XXXXXXXX
00001CD0  343C 4600               1576          MOVE.W  #%0100011000000000,D2
00001CD4  363C B900               1577          MOVE.W  #%1011100100000000,D3
00001CD8  207C 00002262           1578          MOVE.L  #BRNOT,A0
00001CDE  6100 FF2C               1579          BSR     JMPMSK
00001CE2                          1580  
00001CE2                          1581          * MULU:   0100110000XXXXXX
00001CE2  343C 4C00               1582          MOVE.W  #%0100110000000000,D2
00001CE6  363C B3C0               1583          MOVE.W  #%1011001111000000,D3
00001CEA  207C 00002230           1584          MOVE.L  #BRMULU,A0
00001CF0  6100 FF1A               1585          BSR     JMPMSK
00001CF4                          1586  
00001CF4                          1587          * DIVS:   0100110001XXXXXX
00001CF4  343C 4C40               1588          MOVE.W  #%0100110001000000,D2
00001CF8  363C B380               1589          MOVE.W  #%1011001110000000,D3
00001CFC  207C 0000223A           1590          MOVE.L  #BRDIVS,A0
00001D02  6100 FF08               1591          BSR     JMPMSK
00001D06                          1592  
00001D06                          1593          * MOVEM:  01001X001XXXXXXX
00001D06  343C 4880               1594          MOVE.W  #%0100100010000000,D2
00001D0A  363C B300               1595          MOVE.W  #%1011001100000000,D3
00001D0E  207C 00002214           1596          MOVE.L  #BRMOVEM,A0
00001D14  6100 FEF6               1597          BSR     JMPMSK
00001D18                          1598  
00001D18                          1599          * RTS:    0100111001110101
00001D18  343C 4E75               1600          MOVE.W  #%0100111001110101,D2
00001D1C  363C B18A               1601          MOVE.W  #%1011000110001010,D3
00001D20  207C 00002144           1602          MOVE.L  #BRRTS,A0
00001D26  6100 FEE4               1603          BSR     JMPMSK
00001D2A                          1604  
00001D2A                          1605          * JSR:    0100111010XXXXXX
00001D2A  343C 4E80               1606          MOVE.W  #%0100111010000000,D2
00001D2E  363C B140               1607          MOVE.W  #%1011000101000000,D3
00001D32  207C 00002168           1608          MOVE.L  #BRJSR,A0
00001D38  6100 FED2               1609          BSR     JMPMSK
00001D3C                          1610  
00001D3C                          1611          * LEA:    0100XXX111XXXXXX
00001D3C  343C 41C0               1612          MOVE.W  #%0100000111000000,D2
00001D40  363C B000               1613          MOVE.W  #%1011000000000000,D3
00001D44  207C 0000214E           1614          MOVE.L  #BRLEA,A0
00001D4A  6100 FEC0               1615          BSR     JMPMSK
00001D4E                          1616  *-----
00001D4E                          1617  * 0101
00001D4E                          1618  *-----
00001D4E                          1619          * ADDQ:   0101XXX0XXXXXXXX
00001D4E  343C 5000               1620          MOVE.W  #%0101000000000000,D2
00001D52  363C A100               1621          MOVE.W  #%1010000100000000,D3
00001D56  207C 0000207E           1622          MOVE.L  #BRADDQ,A0
00001D5C  6100 FEAE               1623          BSR     JMPMSK
00001D60                          1624  *-----
00001D60                          1625  * 0110
00001D60                          1626  *-----
00001D60                          1627          * BCC:    01100000XXXXXXXX
00001D60  343C 6000               1628          MOVE.W  #%0110000000000000,D2
00001D64  363C 9F00               1629          MOVE.W  #%1001111100000000,D3
00001D68  207C 000020A6           1630          MOVE.L  #BRBCC,A0
00001D6E  6100 FE9C               1631          BSR     JMPMSK
00001D72                          1632  *-----
00001D72                          1633  * 0111
00001D72                          1634  *-----
00001D72                          1635          * MOVEQ:  0111XXX0XXXXXXXX
00001D72  343C 7000               1636          MOVE.W  #%0111000000000000,D2
00001D76  363C 8100               1637          MOVE.W  #%1000000100000000,D3
00001D7A  207C 0000221E           1638          MOVE.L  #BRMOVEQ,A0
00001D80  6100 FE8A               1639          BSR     JMPMSK
00001D84                          1640  *-----
00001D84                          1641  * 1000
00001D84                          1642  *-----
00001D84                          1643          * DIVS:   1000XXX111XXXXXX
00001D84  343C 81C0               1644          MOVE.W  #%1000000111000000,D2
00001D88  363C 7000               1645          MOVE.W  #%0111000000000000,D3
00001D8C  207C 0000223A           1646          MOVE.L  #BRDIVS,A0
00001D92  6100 FE78               1647          BSR     JMPMSK
00001D96                          1648  *-----
00001D96                          1649  * 1001
00001D96                          1650  *-----
00001D96                          1651          * SUB:    1001XXXXXXXXXXXX
00001D96  343C 9000               1652          MOVE.W  #%1001000000000000,D2
00001D9A  363C 6000               1653          MOVE.W  #%0110000000000000,D3
00001D9E  207C 0000226C           1654          MOVE.L  #BRSUB,A0
00001DA4  6100 FE66               1655          BSR     JMPMSK
00001DA8                          1656  *-----
00001DA8                          1657  * 1010
00001DA8                          1658  *-----
00001DA8                          1659  *-----
00001DA8                          1660  * 1011
00001DA8                          1661  *-----
00001DA8                          1662          * CMP:    1011XXXXXXXXXXXX
00001DA8  343C B000               1663          MOVE.W  #%1011000000000000,D2
00001DAC  363C 4000               1664          MOVE.W  #%0100000000000000,D3
00001DB0  207C 000020D8           1665          MOVE.L  #BRCMP,A0
00001DB6  6100 FE54               1666          BSR     JMPMSK
00001DBA                          1667  
00001DBA                          1668          * EOR:    1011XXXXXXXXXXXX
00001DBA  207C 00002244           1669          MOVE.L  #BREOR,A0
00001DC0  6100 FE4A               1670          BSR     JMPMSK
00001DC4                          1671  *-----
00001DC4                          1672  * 1100
00001DC4                          1673  *-----
00001DC4                          1674          * AND:    1100XXXXXXXXXXXX
00001DC4  343C C000               1675          MOVE.W  #%1100000000000000,D2
00001DC8  363C 3000               1676          MOVE.W  #%0011000000000000,D3
00001DCC  207C 00002092           1677          MOVE.L  #BRAND,A0
00001DD2  6100 FE38               1678          BSR     JMPMSK
00001DD6                          1679  
00001DD6                          1680          * MULU:   1100XXX011XXXXXX
00001DD6  343C C0C0               1681          MOVE.W  #%1100000011000000,D2
00001DDA  363C 3100               1682          MOVE.W  #%0011000100000000,D3
00001DDE  207C 00002230           1683          MOVE.L  #BRMULU,A0
00001DE4  6100 FE26               1684          BSR     JMPMSK
00001DE8                          1685  *-----
00001DE8                          1686  * 1101
00001DE8                          1687  *-----
00001DE8                          1688          * ADD:    1101XXXXXXXXXXXX
00001DE8  343C D000               1689          MOVE.W  #%1101000000000000,D2
00001DEC  363C 2000               1690          MOVE.W  #%0010000000000000,D3
00001DF0  207C 00002030           1691          MOVE.L  #BRADD,A0
00001DF6  6100 FE14               1692          BSR     JMPMSK
00001DFA                          1693  *-----
00001DFA                          1694  * 1110
00001DFA                          1695  *-----
00001DFA                          1696          * ASL/ASR:1110XXXXXXX00XXX
00001DFA  343C E000               1697          MOVE.W  #%1110000000000000,D2
00001DFE  363C 1018               1698          MOVE.W  #%0001000000011000,D3
00001E02  207C 00002228           1699          MOVE.L  #BRASd,A0
00001E08  6100 FE02               1700          BSR     JMPMSK
00001E0C                          1701  
00001E0C                          1702          * LSL/LSR:1110XXXXXXX01XXX
00001E0C  343C E008               1703          MOVE.W  #%1110000000001000,D2
00001E10  363C 1010               1704          MOVE.W  #%0001000000010000,D3
00001E14  207C 0000222C           1705          MOVE.L  #BRLSd,A0
00001E1A  6100 FDF0               1706          BSR     JMPMSK
00001E1E                          1707  
00001E1E                          1708          * ASL/ASR:1110000X11XXXXXX
00001E1E  343C E0C0               1709          MOVE.W  #%1110000011000000,D2
00001E22  363C 1E00               1710          MOVE.W  #%0001111000000000,D3
00001E26  207C 00002228           1711          MOVE.L  #BRASd,A0
00001E2C  6100 FDDE               1712          BSR     JMPMSK
00001E30                          1713  
00001E30                          1714          * LSL/LSR:1110001X11XXXXXX
00001E30  343C E2C0               1715          MOVE.W  #%1110001011000000,D2
00001E34  363C 1C00               1716          MOVE.W  #%0001110000000000,D3
00001E38  207C 0000222C           1717          MOVE.L  #BRLSd,A0
00001E3E  6100 FDCC               1718          BSR     JMPMSK
00001E42                          1719  *-----
00001E42                          1720  * 1111
00001E42                          1721  *-----     
00001E42  6000 FBFE               1722          BRA     BRBAD           No mask matched, branch to BRBAD
00001E46                          1723  
00001E46                          1724  *--------------------------
00001E46                          1725  *  Instruction Subroutines
00001E46                          1726  *--------------------------
00001E46                          1727  
00001E46                          1728  *
00001E46                          1729  * Test Addressing Modes: Tests last register and mode for valid addressing modes
00001E46                          1730  * Input valid modes in D0.W, output found addressing mode to D1.B, or FF if not found
00001E46                          1731  * Set Z-flag if mode was valid, or clear Z-flag if mode was invalid
00001E46                          1732  *
00001E46                          1733  * D0.W addressing modes (set to 0 for invalid, 1 for valid):
00001E46                          1734  *   0   Dn
00001E46                          1735  *   1   An
00001E46                          1736  *   2   (An)
00001E46                          1737  *   3   (An)+
00001E46                          1738  *   4   -(An)
00001E46                          1739  *   5   (d,An)
00001E46                          1740  *   6   (d,An,Xn)
00001E46                          1741  *   7   (xxx).W
00001E46                          1742  *   8   (xxx).L
00001E46                          1743  *   9   (d,PC)
00001E46                          1744  *   A   (d,PC,Xn)
00001E46                          1745  *   B   #<data>
00001E46                          1746  *
00001E46                          1747  * Modes         %XXXXBA9876543210
00001E46  =00000FFF               1748  M_ALL   EQU     %0000111111111111   All modes
00001E46  =00000FFD               1749  M_DAT   EQU     %0000111111111101   Data modes
00001E46  =00000FFC               1750  M_MEM   EQU     %0000111111111100   Memory modes
00001E46  =000007E4               1751  M_CTR   EQU     %0000011111100100   Control modes
00001E46  =0000007F               1752  M_ALT   EQU     %0000000001111111   Alterable modes
00001E46  =000001FC               1753  M_MALT  EQU     %0000000111111100   Memory alterable modes
00001E46  =000001FD               1754  M_DALT  EQU     %0000000111111101   Data alterable modes
00001E46                          1755  
00001E46  1F02                    1756  TSTAM   MOVE.B  D2,-(SP)        Push D2 to stack
00001E48  4281                    1757          CLR.L   D1
00001E4A  1238 10C4               1758          MOVE.B  (RGMD),D1       Move REGMOD to D1
00001E4E  1401                    1759          MOVE.B  D1,D2           Copy REGMOD to D2
00001E50  EB09                    1760          LSL.B   #5,D1
00001E52  EA09                    1761          LSR.B   #5,D1           D1 = Mode
00001E54  E60A                    1762          LSR.B   #3,D2           D2 = Register
00001E56  B23C 0007               1763          CMP.B   #%111,D1        Test mode to 111
00001E5A  6602                    1764          BNE     *+4             If !=, skip next line
00001E5C  D202                    1765          ADD.B   D2,D1           Add register to mode-- effectively creating a 4 bit mode
00001E5E  0300                    1766          BTST    D1,D0           Test mode for validity
00001E60  6706                    1767          BEQ     *+8             If it is invalid, skip to clear flag
00001E62  141F                    1768          MOVE.B  (SP)+,D2        If it is valid, restore D2
00001E64  6000 F5BC               1769          BRA     FLAGST          Set flag & return to caller
00001E68  141F                    1770          MOVE.B  (SP)+,D2        Restore D2
00001E6A  6000 F5BC               1771          BRA     FLAGCL          Clear flag & return to caller
00001E6E                          1772  
00001E6E                          1773  *
00001E6E                          1774  * Advance Buffer: Advances buffer based on last register and mode
00001E6E                          1775  * Input buffer in A1, reg & mode in RGMD, output displacement to DIS
00001E6E                          1776  *
00001E6E                          1777  
00001E6E  48E7 6000               1778  ADVBFR  MOVEM.L D1/D2,-(SP)     Push D1 & D2 to the stack
00001E72  11FC 00FF 10C5          1779          MOVE.B  #$FF,(DIS)      Set displacement to NULL
00001E78  1238 10C4               1780          MOVE.B  (RGMD),D1       Move Reg & Mod to D1
00001E7C  2409                    1781          MOVE.L  A1,D2           Copy buffer to D2
00001E7E  B23C 0007               1782          CMP.B   #$07,D1         Test 000 111 = (XXX).W (Word)
00001E82  6602                    1783          BNE.S   *+4             Skip next line
00001E84  5489                    1784          ADD.L   #2,A1           Advance buffer by word
00001E86  B23C 000F               1785          CMP.B   #$0F,D1         Test 001 111 = (XXX).L (Long)
00001E8A  6602                    1786          BNE.S   *+4             Skip next line
00001E8C  5889                    1787          ADD.L   #4,A1           Advance buffer by long
00001E8E  B23C 0017               1788          CMP.B   #$17,D1         Test 010 111 = (d16,PC) (Word)
00001E92  6602                    1789          BNE.S   *+4             Skip next line
00001E94  5489                    1790          ADD.L   #2,A1           Advance buffer by word
00001E96  B23C 001F               1791          CMP.B   #$1F,D1         Test 011 111 = (d8,PC,Xn) (Word)
00001E9A  6602                    1792          BNE.S   *+4             Skip next line
00001E9C  5489                    1793          ADD.L   #2,A1           Advance buffer by word
00001E9E  B23C 0027               1794          CMP.B   #$27,D1         Test 100 111 = Immediate (OP code size)
00001EA2  6700 0024               1795          BEQ     ADVBSZ          If ==, branch to Advance Buffer by Size
00001EA6  EB09                    1796          LSL.B   #5,D1           Else, check the mode...
00001EA8  EA09                    1797          LSR.B   #5,D1           D1 = Mode
00001EAA  B23C 0005               1798          CMP.B   #5,D1           Test XXX 101 = (d16,An) (Word)
00001EAE  6602                    1799          BNE     *+4             Skip next line
00001EB0  5489                    1800          ADD.L   #2,A1           Advance buffer by word
00001EB2  B23C 0006               1801          CMP.B   #6,D1           Test XXX 110 = (d8,An,Xn) (Word)
00001EB6  6602                    1802          BNE     *+4             Skip next line
00001EB8  5489                    1803          ADD.L   #2,A1           Advance buffer by word
00001EBA  4482                    1804          NEG.L   D2              Negate original buffer
00001EBC  D489                    1805          ADD.L   A1,D2           Add buffer to get difference
00001EBE  11C2 10C5               1806          MOVE.B  D2,(DIS)        Store displacement in DIS
00001EC2  4CDF 0006               1807          MOVEM.L (SP)+,D1/D2     Restore D1 & D2
00001EC6  4E75                    1808          RTS                     Return to caller
00001EC8                          1809  
00001EC8                          1810  *
00001EC8                          1811  * Advance Buffer by Size: Advances buffer based on instruction size
00001EC8                          1812  * Input buffer in A1, input size from (IOSIZE), output displacement to DIS
00001EC8                          1813  *
00001EC8                          1814  
00001EC8  0C38 00FF 10C5          1815  ADVBSZ  CMP.B   #$FF,(DIS)      Check if DIS is NULL (255 is odd so displacement should never be FF)
00001ECE  6704                    1816          BEQ     *+6             If it is null, values have already been pushed to the stack, skip the next line
00001ED0  48E7 6000               1817          MOVEM.L D1/D2,-(SP)     Else, push D1 & D2 to the stack
00001ED4  1238 100E               1818          MOVE.B  (IOSIZE),D1     Read size to D1
00001ED8  2409                    1819          MOVE.L  A1,D2           Copy buffer to D2
00001EDA  B23C 0000               1820          CMP.B   #0,D1           Test 0 = Byte
00001EDE  6602                    1821          BNE.S   *+4             Skip next line
00001EE0  5489                    1822          ADD.L   #2,A1           Advance buffer by word (00BB)
00001EE2  B23C 0001               1823          CMP.B   #1,D1           Test 1 = Word
00001EE6  6602                    1824          BNE.S   *+4             Skip next line
00001EE8  5489                    1825          ADD.L   #2,A1           Advance buffer by word        
00001EEA  B23C 0002               1826          CMP.B   #2,D1           Test 2 = Long
00001EEE  6602                    1827          BNE.S   *+4             Skip next line
00001EF0  5889                    1828          ADD.L   #4,A1           Advance buffer by long
00001EF2  4442                    1829          NEG     D2              Negate original buffer
00001EF4  D489                    1830          ADD.L   A1,D2           Add buffer to get difference
00001EF6  11C2 10C5               1831          MOVE.B  D2,(DIS)        Store displacement in DIS
00001EFA  4CDF 0006               1832          MOVEM.L (SP)+,D2/D1     Restore D1 and D2
00001EFE  4E75                    1833          RTS                     Return to caller
00001F00                          1834  
00001F00                          1835  *
00001F00                          1836  * OP Size: Test the standard OP size code
00001F00                          1837  * Inputs size from (DMD), outputs size to IOSIZE, operation to D2.B, correct mode to DMD
00001F00                          1838  * OPM (OP-MODE):  Byte | Word | Long | Operation | D2.B
00001F00                          1839  *                  000 |  001 |  010 |   <ea>,Dn |    0
00001F00                          1840  *                  100 |  101 |  110 |   Dn,<ea> |    1
00001F00                          1841  *                         011 |  111 |   <ea>,An |    2
00001F00                          1842  *
00001F00                          1843  
00001F00  48E7 C000               1844  OPSIZE  MOVEM.L D0/D1,-(SP)     Push D0 & D1 to stack
00001F04  4241                    1845          CLR.W   D1              Ensure displacement will be <= 7
00001F06  1238 10C0               1846          MOVE.B  (DMD),D1        Get destination mode in D1
00001F0A  C2FC 0004               1847          MULU.W  #4,D1           Convert to displacement
00001F0E  4EFB 1002               1848          JMP     OPTBL(PC,D1.W)  Jump to OP mode
00001F12  6000 001E               1849  OPTBL   BRA     OP0             000
00001F16  6000 002C               1850          BRA     OP1             001
00001F1A  6000 003A               1851          BRA     OP2             010
00001F1E  6000 0048               1852          BRA     OP3             011
00001F22  6000 0056               1853          BRA     OP4             100
00001F26  6000 0064               1854          BRA     OP5             101
00001F2A  6000 0072               1855          BRA     OP6             110
00001F2E  6000 0080               1856          BRA     OP7             111
00001F32  143C 0000               1857  OP0     MOVE.B  #0,D2           Set OP to 0 for Dn
00001F36  11FC 0000 10C0          1858          MOVE.B  #0,(DMD)        Set mode to Dn
00001F3C  103C 0000               1859          MOVE.B  #0,D0           Set size to byte
00001F40  6000 0080               1860          BRA     OP8             Branch to end
00001F44  143C 0000               1861  OP1     MOVE.B  #0,D2           Set OP to 0 for Dn
00001F48  11FC 0000 10C0          1862          MOVE.B  #0,(DMD)        Set mode to Dn
00001F4E  103C 0001               1863          MOVE.B  #1,D0           Set size to word
00001F52  6000 006E               1864          BRA     OP8             Branch to end
00001F56  143C 0000               1865  OP2     MOVE.B  #0,D2           Set OP to 0 for Dn
00001F5A  11FC 0000 10C0          1866          MOVE.B  #0,(DMD)        Set mode to Dn
00001F60  103C 0002               1867          MOVE.B  #2,D0           Set size to long
00001F64  6000 005C               1868          BRA     OP8             Branch to end
00001F68  143C 0002               1869  OP3     MOVE.B  #2,D2           Set OP to 2 for An
00001F6C  11FC 0001 10C0          1870          MOVE.B  #1,(DMD)        Set mode to An
00001F72  103C 0001               1871          MOVE.B  #1,D0           Set size to word
00001F76  6000 004A               1872          BRA     OP8             Branch to end
00001F7A  143C 0001               1873  OP4     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001F7E  11FC 0000 10C0          1874          MOVE.B  #0,(DMD)        Set mode to Dn
00001F84  103C 0000               1875          MOVE.B  #0,D0           Set size to byte
00001F88  6000 0038               1876          BRA     OP8             Branch to end
00001F8C  143C 0001               1877  OP5     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001F90  11FC 0000 10C0          1878          MOVE.B  #0,(DMD)        Set mode to Dn
00001F96  103C 0001               1879          MOVE.B  #1,D0           Set size to word
00001F9A  6000 0026               1880          BRA     OP8             Branch to end
00001F9E  143C 0001               1881  OP6     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001FA2  11FC 0000 10C0          1882          MOVE.B  #0,(DMD)        Set mode to Dn
00001FA8  103C 0002               1883          MOVE.B  #2,D0           Set size to long
00001FAC  6000 0014               1884          BRA     OP8             Branch to end
00001FB0  143C 0002               1885  OP7     MOVE.B  #2,D2           Set OP to 2 for An
00001FB4  11FC 0001 10C0          1886          MOVE.B  #1,(DMD)        Set mode to An
00001FBA  103C 0002               1887          MOVE.B  #2,D0           Set size to long
00001FBE  6000 0002               1888          BRA     OP8             Branch to end
00001FC2  11C0 100E               1889  OP8     MOVE.B  D0,(IOSIZE)     Store size in IOSIZE
00001FC6  4CDF 0003               1890          MOVEM.L (SP)+,D0/D1     Restore D0 & D1
00001FCA  4E75                    1891          RTS                     Return to caller
00001FCC                          1892  
00001FCC                          1893  *
00001FCC                          1894  * Extract destination: Extracts destination mode to DMD and destination register to DRG from instruction
00001FCC                          1895  * Input instruction from GBUFF, output a combination of reg & mode in RGMD
00001FCC                          1896  *
00001FCC                          1897  
00001FCC  48E7 E080               1898  EXDST   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
00001FD0  2078 1000               1899          MOVE.L  GBUFF,A0        Point A0 to GBUFF
00001FD4  3010                    1900          MOVE.W  (A0),D0         Move instruction to D0
00001FD6  243C 000001C0           1901          MOVE.L  #$1C0,D2        Extract dest mode at 0000000111000000
00001FDC  6100 F5B4               1902          BSR     EXTMSK          Get dest mode to D1
00001FE0  11C1 10C0               1903          MOVE.B  D1,(DMD)        Move dest mode to DMD
00001FE4  243C 00000E00           1904          MOVE.L  #$E00,D2        Extract dest reg at 0000111000000000
00001FEA  6100 F5A6               1905          BSR     EXTMSK          Get dest reg to D1
00001FEE  11C1 10C1               1906          MOVE.B  D1,(DRG)        Move dest reg to (DRG)
00001FF2  E709                    1907          LSL.B   #3,D1           Shift the reg 3 bits left
00001FF4  8238 10C0               1908          OR.B    (DMD),D1        Add mode after reg
00001FF8  11C1 10C4               1909          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001FFC  4CDF 0107               1910          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2 and A0
00002000  4E75                    1911          RTS                     Return to caller
00002002                          1912  
00002002                          1913  *
00002002                          1914  * Extract source: Extracts source mode to SMD and source register to SRG from instruction
00002002                          1915  * Inputs instruction from GBUFF, output a combination of reg & mode in RGMD
00002002                          1916  *
00002002                          1917  
00002002  48E7 E080               1918  EXSRC   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
00002006  2078 1000               1919          MOVE.L  GBUFF,A0        Point A0 to GBUFF
0000200A  3010                    1920          MOVE.W  (A0),D0         Move instruction to D0
0000200C  7438                    1921          MOVE.L  #$38,D2         Extract src mode at 0000000000111000
0000200E  6100 F582               1922          BSR     EXTMSK          Get src mode to D1
00002012  11C1 10C2               1923          MOVE.B  D1,(SMD)        Move src mode to (OMD)
00002016  7407                    1924          MOVE.L  #$7,D2          Extract src reg at 0000000000000111
00002018  6100 F578               1925          BSR     EXTMSK          Get src reg to D1
0000201C  11C1 10C3               1926          MOVE.B  D1,(SRG)        Move src reg to (ORG)
00002020  E709                    1927          LSL.B   #3,D1           Shift the reg 3 bits left
00002022  8238 10C2               1928          OR.B    (SMD),D1        Add mode after reg
00002026  11C1 10C4               1929          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000202A  4CDF 0107               1930          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2
0000202E  4E75                    1931          RTS                     Return to caller
00002030                          1932  
00002030                          1933  * ----------------
00002030                          1934  * OP Mode Branches
00002030                          1935  * ----------------
00002030                          1936  * A1 reserved for tentative good buffer
00002030                          1937  
00002030                          1938  
00002030                          1939  * ADD: 1101|REG|OPM|EMD|ERG
00002030                          1940  * Syntax: ADD       <ea>,Dn
00002030                          1941  *         ADD       Dn,<ea>
00002030                          1942  * Note: The Dn mode is used when the destination is a data register;
00002030                          1943  *       the destination <ea> mode is invalid for a data register. 
00002030                          1944  *       ADDA is used when the destination is an address register.
00002030                          1945  *       ADDI and ADDQ are used when the source is immediate data.
00002030                          1946  *       Most assemblers automatically make this distinction.  
00002030                          1947  
00002030  11FC 0011 100C          1948  BRADD   MOVE.B  #$11,(IOOPCD)   Set OP-code name
00002036  6194                    1949          BSR     EXDST           Extract OP mode & register
00002038  6100 FEC6               1950          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
0000203C                          1951          * "If the location specified is a destination operand,
0000203C                          1952          * only memory alterable addressing modes can be used [...]."
0000203C  B43C 0000               1953          CMP.B   #0,D2           Compare operation to Dn
00002040  6604                    1954          BNE.S   *+6             If !=, skip next line
00002042  303C 01FC               1955          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002046                          1956          * "If the location specified is a source operand,
00002046                          1957          * all addressing modes can be used [...]."
00002046  B43C 0001               1958          CMP.B   #1,D2           Compare operation to <ea>
0000204A  6604                    1959          BNE.S   *+6             If !=, skip next line
0000204C  303C 0FFF               1960          MOVE.W  #M_ALL,D0       Set all modes as valid
00002050                          1961          * "ADDA is used when the destination is an address register."
00002050  B43C 0002               1962          CMP.B   #2,D2           Compare operation to An
00002054  6700 000C               1963          BEQ     BRADDA          If ==, branch to BRADDA
00002058                          1964  
00002058  61A8                    1965          BSR     EXSRC           Extract EA mode & register
0000205A                          1966          *BSR     TSTAM           Test modes for validity
0000205A                          1967          *BNE     FLAGCL          If not valid, return unsuccessful
0000205A  6100 FE12               1968          BSR     ADVBFR          Else, advance the buffer accordingly
0000205E  6000 F3C2               1969          BRA     FLAGST          Return return successful
00002062                          1970  
00002062                          1971  
00002062                          1972  * ADDA: 1101|REG|OPM|EMD|ERG
00002062                          1973  * Syntax: ADDA      <ea>,An
00002062                          1974  
00002062  11FC 0015 100C          1975  BRADDA  MOVE.B  #$15,(IOOPCD)   Set OP-code name
00002068                          1976          * "All addressing modes can be used [...]."
00002068  303C 0FFF               1977          MOVE.W  #M_ALL,D0       Set all modes as valid
0000206C  6194                    1978          BSR     EXSRC           Extract EA mode & register
0000206E  6100 FDD6               1979          BSR     TSTAM           Test modes for validity
00002072  6600 F3B4               1980          BNE     FLAGCL          If not valid, return unsuccessful
00002076  6100 FDF6               1981          BSR     ADVBFR          Else, advance the buffer accordingly
0000207A  6000 F3A6               1982          BRA     FLAGST          Return successful
0000207E                          1983  
0000207E                          1984  * ADDQ: 0101|DAT|0|SZ|EMD|ERG
0000207E                          1985  * Syntax: ADDQ      #<data>,<ea>
0000207E                          1986  
0000207E  11FC 001A 100C          1987  BRADDQ  MOVE.B  #$1A,(IOOPCD)   Set OP-code name
00002084  6000 F39C               1988          BRA     FLAGST          Return successful
00002088                          1989  
00002088                          1990  * ADDI: 000000110|SZ|EMD|ERG
00002088                          1991  * Syntax: ADDI      #<data>,<ea>
00002088                          1992  
00002088  11FC 0099 100C          1993  BRADDI  MOVE.B  #$99,(IOOPCD)   Set OP-code name
0000208E  6000 F392               1994          BRA     FLAGST          Return successful
00002092                          1995  
00002092                          1996  * AND: 1100|REG|OPM|EMD|ERG
00002092                          1997  * Syntax: AND       <ea>,Dn
00002092                          1998  *         AND       Dn,<ea>
00002092                          1999  * Note: The Dn mode is used when the destination is a data register;
00002092                          2000  *       the destination < ea > mode is invalid for a data register. 
00002092                          2001  *       Most assemblers use ANDI when the source is immediate data.
00002092                          2002  
00002092  11FC 003B 100C          2003  BRAND   MOVE.B  #$3B,(IOOPCD)   Set OP-code name
00002098  6000 F388               2004          BRA     FLAGST          Return successful
0000209C                          2005  
0000209C                          2006  * BTST: 0000|REG|100|EMD|ERG (BIT NUMBER DYNAMIC, SPECIFIED IN A REGISTER)
0000209C                          2007  *       0000100000|EMD|ERG  00000000|_BITNUM_ (BIT NUMBER STATIC, SPECIFIED AS IMMEDIATE DATA)
0000209C                          2008  * Syntax: BTST      Dn,<ea>
0000209C                          2009  *         BTST      #<data>,<ea>
0000209C                          2010  
0000209C  11FC 0058 100C          2011  BRBTST  MOVE.B  #$58,(IOOPCD)   Set OP-code name
000020A2  6000 F37E               2012          BRA     FLAGST          Return successful
000020A6                          2013  
000020A6                          2014  * BCC: 0110|COND|_8BTDSP_
000020A6                          2015  * Syntax: BCC       <label>
000020A6                          2016  
000020A6  11FC 006B 100C          2017  BRBCC   MOVE.B  #$6B,(IOOPCD)   Set OP-code name
000020AC  6000 F374               2018          BRA     FLAGST          Return successful
000020B0                          2019  
000020B0  11FC 006F 100C          2020  BRBEQ   MOVE.B  #$6F,(IOOPCD)   Set OP-code name
000020B6  6000 F36A               2021          BRA     FLAGST          Return successful
000020BA                          2022          
000020BA  11FC 0073 100C          2023  BRBLT   MOVE.B  #$73,(IOOPCD)   Set OP-code name
000020C0  6000 F360               2024          BRA     FLAGST          Return successful
000020C4                          2025  
000020C4  11FC 0077 100C          2026  BRBNE   MOVE.B  #$77,(IOOPCD)   Set OP-code name
000020CA  6000 F356               2027          BRA     FLAGST          Return successful
000020CE                          2028  
000020CE  11FC 007B 100C          2029  BRBHI   MOVE.B  #$7B,(IOOPCD)   Set OP-code name
000020D4  6000 F34C               2030          BRA     FLAGST          Return successful
000020D8                          2031  
000020D8                          2032  * CMP: 1011|REG|OPM|EMD|ERG
000020D8                          2033  * Syntax: CMP       <ea>,Dn
000020D8                          2034  * Note: CMPA is used when the destination is an address register.
000020D8                          2035  *       CMPI is used when the source is immediate data.
000020D8                          2036  *       CMPM is used for memory-to-memory compares.
000020D8                          2037  *       Most assemblers automatically make the distinction.
000020D8                          2038  
000020D8  11FC 005D 100C          2039  BRCMP   MOVE.B  #$5D,(IOOPCD)   Set OP-code name
000020DE  6000 F342               2040          BRA     FLAGST          Return successful
000020E2                          2041  
000020E2                          2042  * CMPA: 1011|REG|OPM|EMD|ERG
000020E2                          2043  * Syntax: CMPA      <ea>,An       
000020E2                          2044  
000020E2  11FC 0061 100C          2045  BRCMPA  MOVE.B  #$61,(IOOPCD)   Set OP-code name
000020E8  6000 F338               2046          BRA     FLAGST          Return successful
000020EC                          2047  
000020EC                          2048  * CMPI: 00001100|SZ|EMD|ERG
000020EC                          2049  * Syntax: CMPI      #<data>,<ea>
000020EC                          2050  
000020EC  11FC 0066 100C          2051  BRCMPI  MOVE.B  #$66,(IOOPCD)   Set OP-code name
000020F2  3011                    2052          MOVE.W  (A1),D0         Move instruction to D0
000020F4  243C 000000C0           2053          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
000020FA  6100 F496               2054          BSR     EXTMSK          Get the size to D1
000020FE                          2055  
000020FE  B23C 00FF               2056          CMP.B   #$FF,D1         Test if size was found
00002102  6700 F324               2057          BEQ     FLAGCL          If it was not found, branch to clear flag      
00002106  11C1 100E               2058          MOVE.B  D1,(IOSIZE)     If it was found, store size in IOSIZE
0000210A                          2059  
0000210A                          2060          * Dest EA field: "Only data alterable addressing modes can be used [...]."
0000210A  303C 01FD               2061          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
0000210E  6100 FEF2               2062          BSR     EXSRC           Extract source EA mode & register 
00002112  11F8 10C2 10C0          2063          MOVE.B  SMD,(DMD)       The EA mode is the Destination mode
00002118  11F8 10C3 10C1          2064          MOVE.B  SRG,(DRG)       The EA reg is the Destination reg
0000211E  6100 FD4E               2065          BSR     ADVBFR          Advance the buffer accordingly
00002122                          2066          * SUBI format is SUBI.(size)  #<data>, <ea>
00002122                          2067          * manually set the Source mode and source register
00002122  11FC 0007 10C2          2068          MOVE.B  #$07,(SMD)      Source Mode set to 111
00002128  11FC 0004 10C3          2069          MOVE.B  #$04,(SRG)      Register Mode set to 100 #<data>
0000212E  1238 10C3               2070          MOVE.B  SRG,D1          Copy SRG to D1 to manipulate
00002132  E709                    2071          LSL.B   #3,D1           Shift the reg 3 bits left
00002134  8238 10C2               2072          OR.B    (SMD),D1        Add mode after reg
00002138  11C1 10C4               2073          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000213C                          2074          
0000213C  6100 FD30               2075          BSR     ADVBFR          Advance the buffer accordingly
00002140  6000 F2E0               2076          BRA     FLAGST          Return successful
00002144                          2077  
00002144                          2078  * RTS: 0100111001110101
00002144                          2079  * Syntax: RTS
00002144                          2080  
00002144  11FC 0083 100C          2081  BRRTS   MOVE.B  #$83,(IOOPCD)   Set OP-code name
0000214A  6000 F2D6               2082          BRA     FLAGST          Return successful
0000214E                          2083  
0000214E                          2084  * LEA: 0100|REG|111|EMD|ERG
0000214E                          2085  * Syntax: LEA       <ea>,An
0000214E                          2086  
0000214E  11FC 0037 100C          2087  BRLEA   MOVE.B  #$37,(IOOPCD)   Set OP-code name
00002154  6100 FE76               2088          BSR     EXDST           Extract destination mode & register
00002158  6100 FD14               2089          BSR     ADVBFR          Advance the buffer accordingly
0000215C  6100 FEA4               2090          BSR     EXSRC           Extract source mode & register
00002160  6100 FD0C               2091          BSR     ADVBFR          Advance the buffer accordingly
00002164  6000 F2BC               2092          BRA     FLAGST          Return successful
00002168                          2093  
00002168                          2094  * JSR: 0100111010|EMD|ERG
00002168                          2095  * Syntax: JSR       <ea>
00002168                          2096  
00002168  11FC 007F 100C          2097  BRJSR   MOVE.B  #$7F,(IOOPCD)   Set OP-code name
0000216E  6000 F2B2               2098          BRA     FLAGST          Return successful
00002172                          2099          
00002172                          2100  * MOVE: 00|SZ|DRG|DMD|SMD|SRG
00002172                          2101  * Syntax: MOVE      <ea>,<ea>
00002172                          2102  * Note: Most assemblers use MOVEA when the destination is an address register. 
00002172                          2103  *       MOVEQ can be used to move an immediate 8-bit value to a data register. 
00002172                          2104  
00002172  11FC 0000 100C          2105  BRMOVE  MOVE.B  #$00,(IOOPCD)   Set OP-code name
00002178  3011                    2106          MOVE.W  (A1),D0         Move instruction to D0
0000217A  243C 00003000           2107          MOVE.L  #$3000,D2       Extract size at 0011000000000000
00002180  6100 F410               2108          BSR     EXTMSK          Get the size to D1
00002184                          2109  
00002184  103C 00FF               2110          MOVE.B  #$FF,D0         Set size to null
00002188  B23C 0001               2111          CMP.B   #%01,D1         01 = Byte
0000218C  6604                    2112          BNE.S   *+6             Branch to next test
0000218E  103C 0000               2113          MOVE.B  #$0,D0          Set size to byte
00002192  B23C 0003               2114          CMP.B   #%11,D1         11 = Word
00002196  6604                    2115          BNE.S   *+6             Branch to next test
00002198  103C 0001               2116          MOVE.B  #$1,D0          Set size to word
0000219C  B23C 0002               2117          CMP.B   #%10,D1         10 = Long
000021A0  6604                    2118          BNE.S   *+6             Branch to next test
000021A2  103C 0002               2119          MOVE.B  #$2,D0          Set size to long
000021A6  B03C 00FF               2120          CMP.B   #$FF,D0         Test if size was found
000021AA  6700 F27C               2121          BEQ     FLAGCL          If it was not found, branch to clear flag      
000021AE  11C0 100E               2122          MOVE.B  D0,(IOSIZE)     If it was found, store size in IOSIZE
000021B2                          2123  
000021B2  6100 FE18               2124          BSR     EXDST           Extract dest EA mode & register
000021B6  0C38 0001 10C0          2125          CMP.B   #1,(DMD)        Compare mode to An
000021BC  6700 002A               2126          BEQ     BRMOVEA         If ==, branch to BRMOVEA
000021C0                          2127          * Dest EA field: "Only data alterable addressing modes can be used [...]."
000021C0  303C 01FD               2128          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
000021C4  6100 FC80               2129          BSR     TSTAM           Test modes for validity
000021C8  6600 F25E               2130          BNE     FLAGCL          If not valid, return unsuccessful
000021CC  6100 FCA0               2131          BSR     ADVBFR          Else, advance the buffer accordingly
000021D0  6100 FE30               2132          BSR     EXSRC           Extract source EA mode & register
000021D4                          2133          * Source EA field: "All addressing modes can be used [...]."
000021D4  303C 0FFF               2134          MOVE.W  #M_ALL,D0       Set all modes as valid
000021D8  6100 FC6C               2135          BSR     TSTAM           Test modes for validity
000021DC  6600 F24A               2136          BNE     FLAGCL          If not valid, return unsuccessful
000021E0  6100 FC8C               2137          BSR     ADVBFR          Else, advance the buffer accordingly
000021E4                          2138  
000021E4  6000 F23C               2139          BRA     FLAGST          Return successful
000021E8                          2140  
000021E8                          2141  
000021E8                          2142  * MOVEA: 00|SZ|DRG|001|SMD|SRG
000021E8                          2143  * Syntax: MOVEA     <ea>,An
000021E8                          2144  
000021E8  11FC 0005 100C          2145  BRMOVEA MOVE.B  #$05,(IOOPCD)   Set Op-code name
000021EE  0C38 0000 100E          2146          CMP.B   #0,(IOSIZE)     Compare size to byte
000021F4  6700 F232               2147          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
000021F8  6100 FC74               2148          BSR     ADVBFR          Else, advance the buffer accordingly
000021FC  6100 FE04               2149          BSR     EXSRC           Extract source EA mode & register
00002200                          2150          * Source EA field: "All addressing modes can be used [...]."
00002200  303C 0FFF               2151          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002204  6100 FC40               2152          BSR     TSTAM           Test modes for validity
00002208  6600 F21E               2153          BNE     FLAGCL          If not valid, return unsuccessful
0000220C  6100 FC60               2154          BSR     ADVBFR          Advance the buffer accordingly
00002210  6000 F210               2155          BRA     FLAGST          Return successful
00002214                          2156  
00002214                          2157  * MOVEM: 01001|D|001|S|EMD|ERG
00002214                          2158  * Syntax: MOVEM     <list>,<ea>
00002214                          2159  *         MOVEM     <ea>,<list>
00002214                          2160  
00002214  11FC 000B 100C          2161  BRMOVEM MOVE.B  #$0B,(IOOPCD)   Set OP-code name
0000221A  6000 F206               2162          BRA     FLAGST          Return successful
0000221E                          2163  
0000221E                          2164  * MOVEQ: 0111|REG|0|__DATA__
0000221E                          2165  * Syntax: MOVEQ     #<data>,Dn
0000221E                          2166  
0000221E  11FC 008B 100C          2167  BRMOVEQ MOVE.B  #$8B,(IOOPCD)   Set OP-code name
00002224  6600 F1FC               2168          BNE     FLAGST          Return unsuccessful
00002228                          2169  
00002228                          2170  * ASd: 1110000|d|11|EMD|ERG (memory shifts)
00002228                          2171  *      1110|CRG|d|SZ|i|00|REG (register shifts)
00002228                          2172  * Syntax: ASd       Dx,Dy
00002228                          2173  *         ASd       #<data>,Dy
00002228                          2174  *         ASd       <ea>
00002228                          2175  
00002228                          2176  BRASd   *MOVE.B  #$50,(IOOPCD)   ASL
00002228                          2177          *MOVE.B  #$95,(IOOPCD)   ASR
00002228  6000 F1F8               2178          BRA     FLAGST          Return successful
0000222C                          2179  
0000222C                          2180  * LSd: 1110001|d|11|EMD|ERG (memory shifts)
0000222C                          2181  *      1110|CRG|d|SZ|i|01|REG (register shifts)
0000222C                          2182  * Syntax: LSd       Dx,Dy
0000222C                          2183  *         LSd       #<data>,Dy
0000222C                          2184  *         LSd       <ea>
0000222C                          2185  
0000222C                          2186  BRLSd   *MOVE.B  #$91,(IOOPCD)   LSL
0000222C                          2187          *MOVE.B  #$54,(IOOPCD)   LSR
0000222C  6000 F1F4               2188          BRA     FLAGST          Return successful
00002230                          2189  
00002230                          2190  * MULU: 1100|REG|011|EMD|ERG (WORD)
00002230                          2191  *       0100110000|EMD|ERG  0|RDI|0|SZ|0000000|RDH (LONG)
00002230                          2192  * Syntax: MULU.W    <ea>,Dn    16x16 -> 32
00002230                          2193  *         MULU.L    <ea>,Dl    32x32 -> 32
00002230                          2194  *         MULU.L    <ea>,DhDl 32x32 -> 64 
00002230                          2195  
00002230  11FC 002D 100C          2196  BRMULU  MOVE.B  #$2D,(IOOPCD)   Set OP-code name
00002236  6000 F1EA               2197          BRA     FLAGST          Return successful
0000223A                          2198  
0000223A                          2199  * DIVS: 1000|REG|111|EMD|ERG (WORD)
0000223A                          2200  *       0100110001|EMD|ERG  0|RDQ|1|S|0000000|RDR (LONG)
0000223A                          2201  * Synax: DIVS.W     <ea>,Dn     32/16 -> 16r  16q
0000223A                          2202  *        DIVS.L     <ea>,Dq     32/32 -> 32q
0000223A                          2203  *        DIVS.L     <ea>,Dr:Dq  64/32 -> 32r  32q
0000223A                          2204  *        DIVSL.L    <ea>,Dr:Dq 32/32 -> 32r  32q
0000223A                          2205  
0000223A  11FC 0032 100C          2206  BRDIVS  MOVE.B  #$32,(IOOPCD)   Set OP-code name     
00002240  6000 F1E0               2207          BRA     FLAGST          Return successful
00002244                          2208  
00002244                          2209  * EOR: 1011|REG|OPM|EMD|ERG
00002244                          2210  * Syntax: EOR       Dn,<ea>
00002244                          2211  * Note: Memory-to-data-register operations are not allowed.
00002244                          2212  *       Most assemblers use EORI when the source is immediate data.
00002244                          2213  
00002244  11FC 0043 100C          2214  BREOR   MOVE.B  #$43,(IOOPCD)   Set OP-code name
0000224A  6000 F1D6               2215          BRA     FLAGST          Return successful
0000224E                          2216  
0000224E                          2217  * ORI: 00000000|SZ|EMD|ERG
0000224E                          2218  * Syntax: ORI       #<data>,<ea>
0000224E                          2219  
0000224E  11FC 003F 100C          2220  BRORI   MOVE.B  #$3F,(IOOPCD)   Set OP-code name
00002254  6000 F1CC               2221          BRA     FLAGST          Return successful
00002258                          2222  
00002258                          2223  * EORI: 00001010|SZ|EMD|ERG
00002258                          2224  * Syntax: EORI      #<data>,<ea>
00002258                          2225  
00002258  11FC 0047 100C          2226  BREORI  MOVE.B  #$47,(IOOPCD)   Set OP-code name
0000225E  6000 F1C2               2227          BRA     FLAGST          Return successful
00002262                          2228  
00002262                          2229  * NOT: 01000110|SZ|EMD|ERG
00002262                          2230  * Syntax:  NOT      <ea>
00002262                          2231  
00002262  11FC 004C 100C          2232  BRNOT   MOVE.B  #$4C,(IOOPCD)   Set OP-code name
00002268  6000 F1B8               2233          BRA     FLAGST          Return successful
0000226C                          2234  
0000226C                          2235  * SUB: 1001|REG|OPM|EMD|ERG
0000226C                          2236  * Syntax: SUB       <ea>,Dn
0000226C                          2237  *         SUB       Dn,<ea>
0000226C                          2238  * Note: Most assemblers use SUBA when the destination is an address register
0000226C                          2239  *       and SUBI or SUBQ when the source is immediate data.
0000226C                          2240  
0000226C  11FC 001F 100C          2241  BRSUB   MOVE.B  #$1F,(IOOPCD)   Set OP-code name
00002272  6000 F1AE               2242          BRA     FLAGST          Else, return successful
00002276                          2243  
00002276                          2244  * SUBA: 1001|REG|OPM|EMD|ERG
00002276                          2245  * Syntax: SUBA      <ea>,An
00002276                          2246  
00002276  11FC 0023 100C          2247  BRSUBA  MOVE.B  #$23,(IOOPCD)   Set OP-code name 
0000227C  6000 F1A4               2248          BRA     FLAGST          Else, return successful
00002280                          2249  
00002280                          2250  * SUBI: 0000|0100|SZ|EMD|ERG
00002280                          2251  * Syntax: SUBI      #<data>,<ea> 
00002280                          2252  
00002280  11FC 0028 100C          2253  BRSUBI  MOVE.B  #$28,(IOOPCD)   Set OP-code name
00002286  3011                    2254          MOVE.W  (A1),D0         Move instruction to D0
00002288  243C 000000C0           2255          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
0000228E  6100 F302               2256          BSR     EXTMSK          Get the size to D1
00002292                          2257  
00002292  B23C 00FF               2258          CMP.B   #$FF,D1         Test if size was found
00002296  6700 F190               2259          BEQ     FLAGCL          If it was not found, branch to clear flag      
0000229A  11C1 100E               2260          MOVE.B  D1,(IOSIZE)     If it was found, store size in IOSIZE
0000229E                          2261  
0000229E                          2262          * Dest EA field: "Only data alterable addressing modes can be used [...]."
0000229E  303C 01FD               2263          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
000022A2  6100 FD5E               2264          BSR     EXSRC           Extract source EA mode & register 
000022A6  11F8 10C2 10C0          2265          MOVE.B  SMD,(DMD)       The EA mode is the Destination mode
000022AC  11F8 10C3 10C1          2266          MOVE.B  SRG,(DRG)       The EA reg is the Destination reg
000022B2  6100 FBBA               2267          BSR     ADVBFR          Advance the buffer accordingly
000022B6                          2268          * SUBI format is SUBI.(size)  #<data>, <ea>
000022B6                          2269          * manually set the Source mode and source register
000022B6  11FC 0007 10C2          2270          MOVE.B  #$07,(SMD)      Source Mode set to 111
000022BC  11FC 0004 10C3          2271          MOVE.B  #$04,(SRG)      Register Mode set to 100 #<data>
000022C2  1238 10C3               2272          MOVE.B  SRG,D1          Copy SRG to D1 to manipulate
000022C6  E709                    2273          LSL.B   #3,D1           Shift the reg 3 bits left
000022C8  8238 10C2               2274          OR.B    (SMD),D1        Add mode after reg
000022CC  11C1 10C4               2275          MOVE.B  D1,(RGMD)       Store D1 in RGMD
000022D0                          2276          
000022D0  6100 FB9C               2277          BSR     ADVBFR          Advance the buffer accordingly
000022D4  6000 F14C               2278          BRA     FLAGST          Else, return successful
000022D8                          2279  
000022D8                          2280  
000022D8                          2281  * SUBQ: 0101|DAT|1|SZ|EMD|ERG
000022D8                          2282  * Syntax: SUBQ      #<data>,<ea>
000022D8                          2283  
000022D8                          2284          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 1460
A2H11               1498
A2H12               149E
A2H13               14A4
A2H14               14AA
A2H15               14B0
A2H16               14B6
A2HADV              1490
ADVBFR              1E6E
ADVBSZ              1EC8
ASCII2HEX           142E
B1A                 745E
B2A                 7464
B3                  746A
B4                  7470
B5                  7476
BA1                 7498
BA2                 749E
BA3                 74A4
BA4                 74AA
BB1                 74CC
BB2                 74D4
BB3                 74DE
BB4                 74EE
BEXTW               1788
BRADD               2030
BRADDA              2062
BRADDI              2088
BRADDQ              207E
BRAND               2092
BRASD               2228
BRBAD               1A42
BRBCC               20A6
BRBEQ               20B0
BRBHI               20CE
BRBLT               20BA
BRBNE               20C4
BRBTST              209C
BRCMP               20D8
BRCMPA              20E2
BRCMPI              20EC
BRDIVS              223A
BREOR               2244
BREORI              2258
BRJSR               2168
BRLEA               214E
BRLSD               222C
BRMOVE              2172
BRMOVEA             21E8
BRMOVEM             2214
BRMOVEQ             221E
BRMULU              2230
BRNOT               2262
BRORI               224E
BRRTS               2144
BRSUB               226C
BRSUBA              2276
BRSUBI              2280
CBITS               0
CMPMSK              1564
CR                  D
DIS                 10C5
DISP0               1846
DISP1               1858
DISP2               1860
DISP3               1878
DISP4               1896
DISP5               18B4
DISP6               18E8
DISP7               1934
DISP8               1950
DISP9               196C
DISPA               1988
DISPB               19C0
DISPC               1A10
DISPD               1A3C
DISPOP              1816
DMD                 10C0
DMDTBL              1826
DONE                1BFC
DRG                 10C1
DRGTBL              193C
DSPAN               175A
DSPAX               15AA
DSPHADV             160A
DSPHDR              1BE0
DSPHST              15F6
DSPHXA              15B4
DSPHXL              1614
DSPHXLP             15B8
DSPHXN              15DA
DSPHXRT             15D4
DSPHXW              15EE
DSPOFLP             1740
DSPOFRT             1754
DSPOFS              1736
DSPSP               1776
DSPSTLP             1706
DSPSTR              16FC
DSPSTRT             1722
ELOC                1008
ERR0                13CA
ERR1                13ED
EXDST               1FCC
EXSRC               2002
EXTADV              15A4
EXTLP               1598
EXTMSK              1592
FLAGCL              1428
FLAGST              1422
GBUFF               1000
H2A                 14EE
H2AA                1526
H2AADV              151E
H2AB                152C
H2AC                1532
H2AD                1538
H2AE                153E
H2AF                1544
HEADR               13A8
HEX2ASCII           14BC
ILL0                161E
ILL1                162C
ILL2                1686
ILL3                1694
IOADDR              1010
IOBDCD              100D
IOLC                1014
IOOPCD              100C
IOOPSZ              10B4
IOSIZE              100E
JMPMSK              1C0C
JUMP                7532
LF                  A
MASK                154A
MNADDR              7000
MSSG0               10C6
MSSG1               1290
MSSG2               12F9
MSSG4               135E
MSSG5               137F
MXADDR              FFFFFF
M_ALL               FFF
M_ALT               7F
M_CTR               7E4
M_DALT              1FD
M_DAT               FFD
M_MALT              1FC
M_MEM               FFC
NODST               1B5A
NOSRC               1B28
OP                  1C24
OP0                 1F32
OP1                 1F44
OP2                 1F56
OP3                 1F68
OP4                 1F7A
OP5                 1F8C
OP6                 1F9E
OP7                 1FB0
OP8                 1FC2
OPNAME              1016
OPSIZE              1F00
OPTBL               1F12
PAUSE               1BBC
PRINT               1A6C
PRMPT1              1636
PRMPT2              169E
PRMPTDN             16F2
QDATA               1015
RGMD                10C4
SC0                 17CA
SC1                 17D2
SC2                 17DA
SC3                 17E2
SC4                 17EA
SCTBL               17BA
SLOC                1004
SMD                 10C2
SRG                 10C3
START               140E
TB                  9
TSTAM               1E46
TSTMSK              1550
VBIN1               FFCFCFCF
VHEX1               FA
VHEX2               DADA
VHEX3               ADADDADA
VHEX4               45
