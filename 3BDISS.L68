0000140E Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 12/5/2013 11:52:56 PM

00000000                             1          INCLUDE 'TEST.x68'
00007000                             2      ORG    $7000
00007000                             3  
00007000  =000000FA                  4  VHEX1   EQU $FA
00007000  =0000DADA                  5  VHEX2   EQU $DADA
00007000  =ADADDADA                  6  VHEX3   EQU $ADADDADA
00007000  =00000045                  7  VHEX4   EQU $45
00007000  =00000000                  8  CBITS   EQU $00000000
00007000  =FFCFCFCF                  9  VBIN1   EQU %11111111110011111100111111001111
00007000                            10  
00007000                            11  
00007000                            12  
00007000                            13  
00007000  0442 DADA                 14      SUBI.W  #VHEX2,D2
00007004  1038 00FA                 15      MOVE.B  VHEX1, D0           <ea>,Dn
00007008  3239 0000DADA             16      MOVE.W  VHEX2, D1
0000700E  243C ADADDADA             17      MOVE.L  #VHEX3, D2
00007014                            18      
00007014  10B8 00FA                 19      MOVE.B  VHEX1, (A0)         <ea>,(An)
00007018  32BC DADA                 20      MOVE.W  #VHEX2, (A1)
0000701C  24B9 ADADDADA             21      MOVE.L  VHEX3, (A2)
00007022                            22      
00007022  16FC 00FA                 23      MOVE.B  #VHEX1, (A3)+       <ea>,(An)+
00007026  38F9 0000DADA             24      MOVE.W  VHEX2, (A4)+
0000702C  2AF9 ADADDADA             25      MOVE.L  VHEX3, (A5)+
00007032                            26      
00007032  1138 00FA                 27      MOVE.B  VHEX1, -(A0)        <ea>,-(An)
00007036  3539 0000DADA             28      MOVE.W  VHEX2, -(A2)
0000703C  293C ADADDADA             29      MOVE.L  #VHEX3, -(A4)
00007042                            30              
00007042  13F8 00FA 0000DADA        31      MOVE.B  VHEX1, VHEX2        <ea>,(xxx).W
0000704A  33F9 0000DADA ADADDADA    32      MOVE.W  VHEX2, VHEX3        <ea>,(xxx).L
00007054  23F8 0000 00F00200        33      MOVE.L  CBITS, $00F00200    <ea>,#<data>
0000705C                            34      
0000705C  13C0 0000DADA             35      MOVE.B  D0, VHEX2           Dn,<ea>
00007062  33C1 00F00210             36      MOVE.W  D1, $00F00210
00007068  22C2                      37      MOVE.L  D2, (A1)+
0000706A                            38      
0000706A  13D1 0000FF00             39      MOVE.B  (A1),$FF00          (An),<ea>
00007070  3613                      40      MOVE.W  (A3),D3
00007072  2315                      41      MOVE.L  (A5),-(A1)
00007074                            42      
00007074  2488                      43      MOVE.L  A0, (A2)            An,<ea>
00007076  36C9                      44      MOVE.W  A1, (A3)+
00007078  23CA ADADDADA             45      MOVE.L  A2, VHEX3
0000707E                            46      
0000707E  13E0 0000DADA             47      MOVE.B  -(A0),VHEX2         -(An),<ea>
00007084  3221                      48      MOVE.W  -(A1),D1
00007086  24E2                      49      MOVE.L  -(A2),(A2)+
00007088                            50      
00007088  3239 0000DADA             51      MOVE.W  VHEX2, D1           (xxx).W, <ea>
0000708E  23F9 ADADDADA 0000DADA    52      MOVE.L  VHEX3, VHEX2        (xxx).L, <ea>
00007098  23FC 000013CF ADADDADA    53      MOVE.L  #%0001001111001111, VHEX3   #<data>,<ea>
000070A2                            54      
000070A2                            55  
000070A2  1F38 00FA                 56      MOVE.B  VHEX1, -(SP)        <ea>, -(SP)
000070A6  34A9 00FA                 57      MOVE.W  (VHEX1,A1),(A2)     (d16,An),<ea>
000070AA  333A 6A2E                 58      MOVE.W  (VHEX2,PC),-(A1)    (d16,PC),<ea>
000070AE  261F                      59      MOVE.L  (SP)+, D3           (SP)+, <ea>
000070B0  70FA                      60      MOVEQ.L #VHEX1,D0           MOVEQ
000070B2                            61      
000070B2                            62  
000070B2                            63  
000070B2  3040                      64      MOVEA.W  D0,A0              Dn,An
000070B4  2248                      65      MOVEA.L  A0,A1              An,An
000070B6  2451                      66      MOVEA.L  (A1),A2            (An),An
000070B8                            67      
000070B8  265A                      68      MOVEA.L  (A2)+,A3           (An)+,An
000070BA  3863                      69      MOVEA.W  -(A3),A4           -(An),An
000070BC  3A79 0000DADA             70      MOVEA.W  VHEX2,A5            (xxx).W,An
000070C2                            71      
000070C2  2079 ADADDADA             72      MOVEA.L   VHEX3,A0           (xxx).L,An
000070C8  227C 0000DADA             73      MOVEA.L  #VHEX2,A1           #<data>,An
000070CE  2C79 FFCFCFCF             74      MOVEA.L   VBIN1,A6            (xxx).L,An
000070D4                            75  
000070D4  3C6D 00FA                 76      MOVEA.W  (VHEX1,A5),A6        (d16,An),An
000070D8  3E7A 6A00                 77      MOVEA.W  (VHEX2,PC),A7        (d16,PC),An
000070DC  70FA                      78      MOVEQ.L   #VHEX1, D0           MOVEQ
000070DE  72FA                      79      MOVEQ.L   #VHEX1, D1           MOVEQ
000070E0                            80      
000070E0                            81  
000070E0                            82  
000070E0  4890 020E                 83      MOVEM.W     D1-D3/A1, (A0)      <list>,(An)
000070E4  48B9 0302 0000DADA        84      MOVEM.W     D1/A0-A1, VHEX2     <list>,(xxx).W
000070EC  48E1 F8F8                 85      MOVEM.L     D0-D4/A0-A4, -(A1)  <list>,-(An)
000070F0  48F9 101C ADADDADA        86      MOVEM.L     D2-D4/A4, VHEX3     <list>,(xxx).L
000070F8                            87      
000070F8  4C91 020E                 88      MOVEM.W     (A1),D1-D3/A1       (An),<list>
000070FC  4CB9 0302 0000DADA        89      MOVEM.W     VHEX2, D1/A0-A1     (xxx).W,<list>
00007104  4CDA 1F1F                 90      MOVEM.L     (A2)+, D0-D4/A0-A4  (An)+,<list>
00007108  4CF9 101C ADADDADA        91      MOVEM.L     VHEX3, D2-D4/A4     (xxx).L,<list>
00007110                            92      
00007110                            93  
00007110  48A8 0306 00FA            94      MOVEM.W     D1-D2/A0-A1, (VHEX1,A0) <list>,(d16,An)
00007116  48E9 0306 00FA            95      MOVEM.L     D1-D2/A0-A1, (VHEX1,A1) <list>,(d16,An)
0000711C  4CAA 0306 00FA            96      MOVEM.W     (VHEX1,A2),D1-D2/A0-A1  (d16,An),<list>
00007122  4CFA 0306 69B4            97      MOVEM.L     (VHEX2,PC),D1-D2/A0-A1  (d16,PC),<list>
00007128                            98      
00007128                            99  
00007128  D200                     100      ADD.B       D0,D1       Dn,Dn
0000712A  D441                     101      ADD.W       D1,D2
0000712C  D682                     102      ADD.L       D2,D3
0000712E                           103      
0000712E  D249                     104      ADD.W       A1,D1       An,Dn
00007130  D48A                     105      ADD.L       A2,D2
00007132  DA8B                     106      ADD.L       A3,D5
00007134                           107      
00007134  D410                     108      ADD.B       (A0),D2     (An),Dn
00007136  D651                     109      ADD.W       (A1),D3
00007138  D892                     110      ADD.L       (A2),D4
0000713A                           111      
0000713A  D01B                     112      ADD.B       (A3)+,D0    (An)+,Dn
0000713C  D25C                     113      ADD.W       (A4)+,D1
0000713E  D49D                     114      ADD.L       (A5)+,D2
00007140                           115      
00007140  D620                     116      ADD.B       -(A0),D3    -(An),Dn
00007142  D861                     117      ADD.W       -(A1),D4    
00007144  DAA2                     118      ADD.L       -(A2),D5
00007146                           119      
00007146  D039 0000DADA            120      ADD.B       VHEX2,D0    (xxx).W,Dn
0000714C  D279 ADADDADA            121      ADD.W       VHEX3,D1    (xxx).L,Dn
00007152  0683 000000FA            122      ADD.L       #VHEX1,D3   #<data>,Dn
00007158                           123      
00007158                           124  
00007158  D2C0                     125      ADD.W       D0,A1       Dn,An
0000715A  D4C1                     126      ADD.W       D1,A2
0000715C  D7C2                     127      ADD.L       D2,A3
0000715E                           128      
0000715E  D714                     129      ADD.B       D3,(A4)     Dn,(An)
00007160  D955                     130      ADD.W       D4,(A5) 
00007162  DB96                     131      ADD.L       D5,(A6)
00007164                           132      
00007164  D118                     133      ADD.B       D0,(A0)+    Dn,(An)+
00007166  D359                     134      ADD.W       D1,(A1)+
00007168  D59A                     135      ADD.L       D2,(A2)+
0000716A                           136      
0000716A  D723                     137      ADD.B       D3,-(A3)    Dn,-(An)
0000716C  D964                     138      ADD.W       D4,-(A4)
0000716E  DBA5                     139      ADD.L       D5,-(A5)
00007170                           140      
00007170  D339 0000DADA            141      ADD.B       D1,VHEX2    Dn,(xxx).W
00007176  D5B9 ADADDADA            142      ADD.L       D2,VHEX3    Dn,(xxx).L
0000717C  D779 FFCFCFCF            143      ADD.W       D3,VBIN1    Dn,(xxx).L
00007182                           144      
00007182                           145  
00007182  D029 00FA                146      ADD.B       (VHEX1,A1),D0   (d16,An),Dn
00007186  D27A 6952                147      ADD.W       (VHEX2,PC),D1   (d16,PC),Dn
0000718A  D7A9 00FA                148      ADD.L       D3,(VHEX1,A1)   Dn,(d16,An)
0000718E                           149  
0000718E                           150  
0000718E  D0C0                     151      ADDA.W       D0,A0           Dn,An
00007190  D3C1                     152      ADDA.L       D1,A1   
00007192                           153      
00007192  D7CA                     154      ADDA.L       A2,A3           An,An
00007194  D8CB                     155      ADDA.W       A3,A4
00007196                           156      
00007196  D0D0                     157      ADDA.W       (A0),A0         (An),An
00007198  D5D2                     158      ADDA.L       (A2),A2
0000719A                           159      
0000719A  D3D9                     160      ADDA.L       (A1)+,A1        (An)+,An
0000719C  D4DA                     161      ADDA.W       (A2)+,A2
0000719E                           162     
0000719E  D4E3                     163      ADDA.W       -(A3),A2        -(An),An
000071A0  D7E2                     164      ADDA.L       -(A2),A3
000071A2                           165      
000071A2  D1F9 0000DADA            166      ADDA.L       VHEX2,A0        (xxx).W,An
000071A8  D4F9 0000DADA            167      ADDA.W       VHEX2,A2    
000071AE                           168      
000071AE  D6F9 ADADDADA            169      ADDA.W       VHEX3,A3        (xxx).L,An
000071B4  D9F9 ADADDADA            170      ADDA.L       VHEX3,A4
000071BA                           171      
000071BA  DBFC FFCFCFCF            172      ADDA.L       #VBIN1,A5       #<data>,An
000071C0                           173  
000071C0                           174  
000071C0  D2EA 00FA                175      ADDA.W       (VHEX1,A2),A1   (d16,An),An
000071C4  D7FA 6914                176      ADDA.L       (VHEX2,PC),A3   (d16,PC),An
000071C8  D7EB 00FA                177      ADDA.L       (VHEX1,A3),A3   (d16,An),An
000071CC                           178  
000071CC                           179  
000071CC  5201                     180      ADDQ.B      #$1,D1       #<data>,Dn
000071CE  5442                     181      ADDQ.W      #$2,D2
000071D0  5683                     182      ADDQ.L      #3,D3
000071D2                           183      
000071D2  5848                     184      ADDQ.W      #$4,A0       #<data>,An
000071D4  5A89                     185      ADDQ.L      #$5,A1
000071D6  5C8A                     186      ADDQ.L      #$6,A2
000071D8                           187      
000071D8  5E10                     188      ADDQ.B      #$7,(A0)     #<data>,(An)
000071DA  5051                     189      ADDQ.W      #$8,(A1)
000071DC  5292                     190      ADDQ.L      #1,(A2)
000071DE                           191      
000071DE  541A                     192      ADDQ.B      #$2,(A2)+    #<data>,(An)+
000071E0  565B                     193      ADDQ.W      #$3,(A3)+
000071E2  589C                     194      ADDQ.L      #$4,(A4)+
000071E4                           195      
000071E4  5A25                     196      ADDQ.B      #$5,-(A5)    #<data>,-(An)
000071E6  5C66                     197      ADDQ.W      #6,-(A6)
000071E8  5EA7                     198      ADDQ.L      #$7,-(A7)
000071EA                           199      
000071EA  5239 0000DADA            200      ADDQ.B      #1,VHEX2     #<data>,(xxx).W
000071F0  54B9 ADADDADA            201      ADDQ.L      #2,VHEX3     #<data>,(xxx).L
000071F6  5879 FFCFCFCF            202      ADDQ.W      #$4,VBIN1    #<data>,(xxx).L
000071FC                           203      
000071FC  506A 00FA                204      ADDQ.W      #8,(VHEX1,A2)   #<data>,(d16,An)
00007200  0640 00FA                205      ADDI.W      #VHEX1,D0       ADDI
00007204  D380                     206      ADDX.L      D0,D1           ADDX
00007206                           207      
00007206                           208  
00007206                           209  
00007206  9200                     210      SUB.B       D0,D1       Dn,Dn
00007208  9642                     211      SUB.W       D2,D3
0000720A                           212      
0000720A  9089                     213      SUB.L       A1,D0       An,Dn
0000720C  964C                     214      SUB.W       A4,D3
0000720E                           215      
0000720E  9613                     216      SUB.B       (A3),D3     (An),Dn
00007210  9092                     217      SUB.L       (A2),D0
00007212                           218      
00007212  9218                     219      SUB.B       (A0)+,D1    (An)+,Dn
00007214  945B                     220      SUB.W       (A3)+,D2
00007216                           221      
00007216  94A1                     222      SUB.L       -(A1),D2    -(An),Dn
00007218  9222                     223      SUB.B       -(A2),D1    
0000721A                           224      
0000721A  9079 0000DADA            225      SUB.W       VHEX2,D0    (xxx).W,Dn
00007220  94B9 FFCFCFCF            226      SUB.L       VBIN1,D2    (xxx).L,Dn
00007226  0404 00F0                227      SUB.B       #$F0,D4     #<data>,Dn
0000722A                           228      
0000722A                           229  
0000722A  92C0                     230      SUB.W       D0,A1       Dn,An
0000722C  99C3                     231      SUB.L       D3,A4
0000722E                           232      
0000722E  9713                     233      SUB.B       D3,(A3)     Dn,(An)
00007230  9152                     234      SUB.W       D0,(A2)
00007232                           235      
00007232  9398                     236      SUB.L       D1,(A0)+    Dn,(An)+
00007234  951B                     237      SUB.B       D2,(A3)+
00007236                           238      
00007236  9561                     239      SUB.W       D2,-(A1)    Dn,-(An)
00007238  93A2                     240      SUB.L       D1,-(A2)
0000723A                           241      
0000723A  9139 0000DADA            242      SUB.B       D0,VHEX2    Dn,(xxx).W
00007240  9579 FFCFCFCF            243      SUB.W       D2,VBIN1    Dn,(xxx).L
00007246  97B9 ADADDADA            244      SUB.L       D3,VHEX3    Dn,(xxx).L
0000724C                           245      
0000724C                           246  
0000724C  902A 00FA                247      SUB.B       (VHEX1,A2),D0   (d16,An),Dn
00007250  927A 6888                248      SUB.W       (VHEX2,PC),D1   (d16,PC),Dn
00007254  93A9 00FA                249      SUB.L       D1, (VHEX1,A1)  Dn,(d16,An)
00007258                           250      
00007258                           251  
00007258                           252  
00007258  90C0                     253      SUBA.W      D0,A0       Dn,An
0000725A  93C1                     254      SUBA.L      D1,A1
0000725C                           255      
0000725C  94C9                     256      SUBA.W      A1,A2       An,An
0000725E  97CA                     257      SUBA.L      A2,A3
00007260                           258      
00007260  96D3                     259      SUBA.W      (A3),A3     (An),An
00007262  99D4                     260      SUBA.L      (A4),A4
00007264                           261      
00007264  90DD                     262      SUBA.W      (A5)+,A0    (An)+,An
00007266  93DE                     263      SUBA.L      (A6)+,A1
00007268                           264      
00007268  94E0                     265      SUBA.W      -(A0),A2    -(An),An
0000726A  97E1                     266      SUBA.L      -(A1),A3
0000726C                           267      
0000726C  98F9 0000DADA            268      SUBA.W      VHEX2,A4    (xxx).W,An
00007272  9BF9 ADADDADA            269      SUBA.L      VHEX3,A5    (xxx).L,An
00007278  9DFC FFCFCFCF            270      SUBA.L      #VBIN1,A6   #<data>,An
0000727E                           271      
0000727E                           272  
0000727E  98E9 0F0F                273      SUBA.W      ($F0F,A1),A4   (d16,An),An
00007282  95FA 9E8D                274      SUBA.L      ($1111,PC),A2  (d16,PC),An
00007286                           275      
00007286                           276  
00007286  0400 00FA                277      SUBI.B      #VHEX1,D0       #<data>,Dn
0000728A  0442 DADA                278      SUBI.W      #VHEX2,D2
0000728E                           279      
0000728E  0492 ADADDADA            280      SUBI.L      #VHEX3,(A2)       #<data>,(An)
00007294  0411 000A                281      SUBI.B      #10,(A1)
00007298                           282      
00007298  0458 0000                283      SUBI.W      #CBITS,(A0)+      #<data>,(An)+
0000729C  049A ADADDADA            284      SUBI.L      #VHEX3,(A2)+
000072A2                           285      
000072A2  0424 000A                286      SUBI.B      #10,-(A4)            #<data>,-(An)
000072A6  0461 000F                287      SUBI.W      #$F,-(A1)
000072AA                           288      
000072AA  04B9 0000DADA 0000DADA   289      SUBI.L      #VHEX2,VHEX2        #<data>,(xxx).W
000072B4  0439 0009 ADADDADA       290      SUBI.B      #09,VHEX3        #<data>,(xxx).L
000072BC                           291      
000072BC                           292  
000072BC  0469 0009 0030           293      SUBI.W      #9,($30,A1)         #<data>,(d16,An)
000072C2  5380                     294      SUBQ.L      #1,D0           SUBQ
000072C4                           295      
000072C4                           296     
000072C4                           297  
000072C4                           298  
000072C4  C2C0                     299      MULU.W      D0,D1           Dn,Dn
000072C6  C2D0                     300      MULU.W      (A0),D1         (An),Dn
000072C8  C4DA                     301      MULU.W      (A2)+,D2        (An)+,Dn
000072CA  C6E3                     302      MULU.W      -(A3),D3        -(An),Dn
000072CC  C8F9 0000DADA            303      MULU.W      VHEX2,D4        (xxx).W,Dn
000072D2  CAF9 ADADDADA            304      MULU.W      VHEX3,D5        (xxx).L,Dn
000072D8  CCFC 2345                305      MULU.W      #$2345,D6       #<data>,Dn
000072DC                           306      
000072DC                           307  
000072DC  C0EA 0032                308      MULU.W      ($32,A2),D0     (d16,An),Dn
000072E0  C2FA 9D1E                309      MULU.W      ($1000,PC),D1   (d16,PC),Dn
000072E4                           310      
000072E4                           311      
000072E4                           312  
000072E4  85C1                     313      DIVS.W      D1,D2           Dn,Dn
000072E6  85D1                     314      DIVS.W      (A1),D2         (An),Dn
000072E8  87DA                     315      DIVS.W      (A2)+,D3        (An)+,Dn
000072EA  89E3                     316      DIVS.W      -(A3),D4        -(An),Dn
000072EC  8BF9 0000DADA            317      DIVS.W      VHEX2,D5        (xxx).W,Dn
000072F2  8DF9 ADADDADA            318      DIVS.W      VHEX3,D6        (xxx).L,Dn
000072F8  8FFC FF00                319      DIVS.W      #$FF00,D7       #<data>,Dn
000072FC                           320      
000072FC                           321  
000072FC  83EB 0401                322      DIVS.W      ($401,A3),D1     (d16,An),Dn
00007300  85FA AF0F                323      DIVS.W      ($2211,PC),D2    (d16,PC),Dn
00007304                           324      
00007304                           325     
00007304                           326  
00007304  B101                     327      EOR.B       D0,D1           Dn,Dn
00007306  B342                     328      EOR.W       D1,D2
00007308                           329      
00007308  B592                     330      EOR.L       D2,(A2)         Dn,(An)
0000730A  B713                     331      EOR.B       D3,(A3)
0000730C                           332      
0000730C  B95C                     333      EOR.W       D4,(A4)+        Dn,(An)+
0000730E  BB9D                     334      EOR.L       D5,(A5)+
00007310                           335      
00007310  BD26                     336      EOR.B       D6,-(A6)        Dn,-(An)
00007312  BF67                     337      EOR.W       D7,-(A7)
00007314                           338      
00007314  B1B9 0000DADA            339      EOR.L       D0,VHEX2        Dn,(xxx).W
0000731A  B339 ADADDADA            340      EOR.B       D1,VHEX3        Dn,(xxx).L
00007320                           341  
00007320                           342  
00007320  B56C 0101                343      EOR.W       D2,($101,A4)    Dn,(d16,An)
00007324  0A3C 0001                344      EORI.B      #$1,CCR         EORI to CCR
00007328                           345      
00007328                           346  
00007328                           347  
00007328  0A00 00FA                348      EORI.B      #VHEX1,D0       #<data>,Dn
0000732C  0A41 000A                349      EORI.W      #10,D1
00007330                           350      
00007330  0A91 ADADDADA            351      EORI.L      #VHEX3,(A1)     #<data>,An
00007336  0A13 0012                352      EORI.B      #$12,(A3)
0000733A                           353      
0000733A  0A5A DADA                354      EORI.W      #VHEX2,(A2)+    #<data>,(An)+
0000733E  0A9C FFCFCFCF            355      EORI.L      #VBIN1,(A4)+
00007344                           356      
00007344  0A20 00FF                357      EORI.B      #$FF, -(A0)     #<data>,-(An)
00007348  0A65 1222                358      EORI.W      #$1222,-(A5)
0000734C                           359      
0000734C  0AB9 0000DADA 0000DADA   360      EORI.L      #VHEX2,VHEX2    #<data>,(xxx).W
00007356  0A39 0011 ADADDADA       361      EORI.B      #$11, VHEX3     #<data>,(xxx).L
0000735E                           362      
0000735E                           363  
0000735E  0A6A 000A 0011           364      EORI.W      #10, ($11,A2)   #<data>,(d16,An)
00007364  C342                     365      EXG.L       D1,D2           EXG
00007366                           366      
00007366                           367  
00007366                           368  
00007366  C200                     369      AND.B       D0,D1           Dn,Dn
00007368  C451                     370      AND.W       (A1),D2         (An),Dn
0000736A  C69A                     371      AND.L       (A2)+,D3        (An)+,Dn
0000736C  C823                     372      AND.B       -(A3),D4        -(An),Dn
0000736E  CA79 0000DADA            373      AND.W       VHEX2,D5        (xxx).W,Dn
00007374  CCB9 ADADDADA            374      AND.L       VHEX3,D6        (xxx).L,Dn
0000737A  CE3C 00FF                375      AND.B       #$FF,D7         #<data>,Dn
0000737E                           376      
0000737E                           377  
0000737E  C151                     378      AND.W       D0,(A1)         Dn,(An)
00007380  C39A                     379      AND.L       D1,(A2)+        Dn,(An)+
00007382  C523                     380      AND.B       D2,-(A3)        Dn,-(An)
00007384  C779 0000DADA            381      AND.W       D3,VHEX2        Dn,(xxx).W
0000738A  C9B9 FFCFCFCF            382      AND.L       D4,VBIN1        Dn,(xxx).L
00007390                           383      
00007390                           384  
00007390  C42A 0012                385      AND.B       ($12,A2),D2     (d16,An),Dn
00007394  C67A 9D8B                386      AND.W       ($1121,PC),D3   (d16,PC),Dn
00007398  C9AC 0112                387      AND.L       D4, ($112,A4)   Dn,(d16,An)
0000739C                           388      
0000739C                           389  
0000739C  0000 00F1                390      ORI.B       #$F1,D0         #<data>,Dn
000073A0  0052 DADA                391      ORI.W       #VHEX2,(A2)     #<data>,(An)
000073A4  009B ADADDADA            392      ORI.L       #VHEX3,(A3)+    #<data>,(An)+
000073AA  0024 0011                393      ORI.B       #$11,-(A4)      #<data>,-(An)
000073AE  0079 0062 0000DADA       394      ORI.W       #98,VHEX2       #<data>,(xxx).W
000073B6  00B9 00000064 ADADDADA   395      ORI.L       #100,VHEX3      #<data>,(xxx).L
000073C0                           396      
000073C0                           397  
000073C0  002A 0004 00FF           398      ORI.B       #4,($FF,A2)     #<data>,(d16,An)
000073C6  8441                     399      OR.W        D1,D2           OR
000073C8                           400      
000073C8                           401  
000073C8  E121                     402      ASL.B       D0,D1       Dx,Dy
000073CA  E562                     403      ASL.W       D2,D2       
000073CC  E982                     404      ASL.L       #4,D2       #<data>,Dy
000073CE  E1D2                     405      ASL.W       (A2)        (An)
000073D0  E1DB                     406      ASL.W       (A3)+       (An)+
000073D2  E1E4                     407      ASL.W       -(A4)       -(An)
000073D4  E1F9 0000DADA            408      ASL.W       VHEX2       (xxx).W
000073DA  E1F9 ADADDADA            409      ASL.W       VHEX3       (xxx).L
000073E0                           410      
000073E0                           411  
000073E0  E1EC 0022                412      ASL.W       ($22,A4)    (d16,An)
000073E4  E0F9 0000DADA            413      ASR.W       VHEX2       ASR
000073EA                           414      
000073EA  E029                     415      LSR.B       D0,D1       Dx,Dy
000073EC  E46A                     416      LSR.W       D2,D2       
000073EE  E88A                     417      LSR.L       #4,D2       #<data>,Dy
000073F0  E2D2                     418      LSR.W       (A2)        (An)
000073F2  E2DB                     419      LSR.W       (A3)+       (An)+
000073F4  E2E4                     420      LSR.W       -(A4)       -(An)
000073F6  E2F9 0000DADA            421      LSR.W       VHEX2       (xxx).W
000073FC  E2F9 ADADDADA            422      LSR.W       VHEX3       (xxx).L
00007402                           423      
00007402                           424  
00007402  E2EC 0022                425      LSR.W       ($22,A4)    (d16,An)
00007406  E3F9 0000DADA            426      LSL.W       VHEX2       LSL
0000740C                           427      
0000740C                           428  
0000740C  0101                     429      BTST.L      D0, D1      Dn,Dn
0000740E  0311                     430      BTST.B      D1,(A1)     Dn,(An)
00007410  051A                     431      BTST.B      D2,(A2)+    Dn,(An)+
00007412  0723                     432      BTST.B      D3,-(A3)    Dn,-(An)
00007414  0939 0000DADA            433      BTST.B      D4,VHEX2    Dn,(xxx).W
0000741A  0B38 0045                434      BTST.B      D5,VHEX4    Dn,(xxx).L
0000741E  0D3C 0004                435      BTST.B      D6,#4       Dn,#<data>
00007422                           436      
00007422                           437  
00007422  0800 00DA                438      BTST.L      #VHEX2,D0       #<data>,Dn
00007426  0810 00FA                439      BTST.B      #VHEX1,(A0)     #<data>,(An)
0000742A  0818 00DA                440      BTST.B      #VHEX3,(A0)+    #<data>,(An)+
0000742E  0824 00CF                441      BTST.B      #VBIN1,-(A4)    #<data>,-(An)
00007432  0839 0011 0000DADA       442      BTST.B      #$11,VHEX2      #<data>,(xxx).W
0000743A  0839 0099 ADADDADA       443      BTST.B      #$99,VHEX3      #<data>,(xxx).L
00007442                           444      
00007442                           445  
00007442  0F2B 0011                446      BTST.B      D7, ($11,A3)    Dn,(d16,An)
00007446  0D3A 8C62                447      BTST.B      D6, ($AA,PC)    Dn,(d16,PC)
0000744A  082A 0057 00BB           448      BTST.B      #1111,($BB,A2)  #<data>,(d16,An)
00007450                           449      
00007450  B001                     450      CMP.B       D1,D0       Dn,Dn
00007452  6700 0002                451      BEQ         B1a
00007456                           452  B1a    
00007456  B24A                     453      CMP.W       A2,D1       An,Dn
00007458  6700 0002                454      BEQ         B2a
0000745C                           455  B2a
0000745C  B493                     456      CMP.L       (A3),D2     (An),Dn
0000745E  6D00 0002                457      BLT         B3
00007462                           458  B3
00007462  B61C                     459      CMP.B       (A4)+,D3    (An)+,Dn
00007464  6600 0002                460      BNE         B4
00007468                           461  B4
00007468  B865                     462      CMP.W       -(A5),D4    -(An),Dn
0000746A  6200 0002                463      BHI         B5
0000746E                           464  B5
0000746E  BAB9 0000DADA            465      CMP.L       VHEX2,D5    (xxx).W,Dn
00007474  BC39 ADADDADA            466      CMP.B       VHEX3,D6    (xxx).L,Dn
0000747A  BEBC FFCFCFCF            467      CMP.L       #VBIN1,D7   #<data>,Dn
00007480                           468  
00007480                           469  
00007480  B028 00FF                470      CMP.B       ($FF,A0),D0     (d16,An),Dn
00007484  B47A 983B                471      CMP.W       ($CC1,PC),D2    (d16,PC),Dn
00007488                           472      
00007488                           473  
00007488  B0C0                     474      CMPA.W      D0,A0       Dn,An
0000748A  B3C8                     475      CMPA.L      A0,A1       An,An
0000748C  6700 0002                476      BEQ         Ba1
00007490                           477  Ba1
00007490  B4D1                     478      CMPA.W      (A1),A2     (An),An
00007492  6D00 0002                479      BLT         Ba2
00007496                           480  Ba2
00007496  B7DA                     481      CMPA.L      (A2)+,A3    (An)+,An
00007498  6600 0002                482      BNE         Ba3
0000749C                           483  Ba3
0000749C  B8E3                     484      CMPA.W      -(A3),A4    -(An),An
0000749E  6200 0002                485      BHI         Ba4
000074A2                           486  Ba4
000074A2  BBF9 0000DADA            487      CMPA.L      VHEX2,A5    (xxx).W,An
000074A8  BCF9 ADADDADA            488      CMPA.W      VHEX3,A6    (xxx).L,An
000074AE  BFFC 000004D2            489      CMPA.L      #1234,A7    #<data>,An
000074B4                           490      
000074B4                           491  
000074B4  B0E9 0033                492      CMPA.W      ($33,A1),A0     (d16,An),An
000074B8  B5FA 8B57                493      CMPA.L      ($11,PC),A2     (d16,PC),An
000074BC                           494      
000074BC                           495  
000074BC  0C00 00FA                496      CMPI.B      #VHEX1,D0       #<data>,Dn
000074C0  6700 0002                497      BEQ         Bb1
000074C4                           498  Bb1
000074C4  0C51 DADA                499      CMPI.W      #VHEX2,(A1)     #<data>,(An)
000074C8  6600 0002                500      BNE         Bb2
000074CC                           501  Bb2
000074CC  0C9A ADADDADA            502      CMPI.L      #VHEX3,(A2)+    #<data>,(An)+
000074D2  6200 0002                503      BHI         Bb3
000074D6                           504  Bb3
000074D6  0C23 0012                505      CMPI.B      #$12,-(A3)      #<data>,-(An)
000074DA  6D00 000A                506      BLT         Bb4
000074DE  0C79 1234 0000DADA       507      CMPI.W      #$1234,VHEX2    #<data>,(xxx).W
000074E6                           508  Bb4
000074E6  0CB9 FFCFCFCF ADADDADA   509      CMPI.L      #VBIN1,VHEX3    #<data>,(xxx).L
000074F0                           510      
000074F0                           511  
000074F0  0C2A 00FF 0099           512      CMPI.B      #$FF,($99,A2)       #<data>,(d16,An)
000074F6  B30A                     513      CMPM.B      (A2)+,(A1)+         CMPM
000074F8                           514      
000074F8                           515  
000074F8  41D1                     516      LEA     (A1),A0         (An),An
000074FA  43F9 0000DADA            517      LEA     VHEX2,A1        (xxx).W,An
00007500  45F9 ADADDADA            518      LEA     VHEX3,A2        (xxx).L,An
00007506                           519   
00007506                           520  
00007506  43E9 0010                521      LEA     ($10,A1),A1     (d16,An),An
0000750A  45FA 948D                522      LEA     ($999,PC),A2    (d16,PC),An
0000750E                           523      
0000750E  4EB9 0000752A            524      JSR     JUMP
00007514  4E91                     525      JSR     (A1)        (An)
00007516  4EB9 0000DADA            526      JSR     VHEX2       (xxx).W
0000751C  4EB9 ADADDADA            527      JSR     VHEX3       (xxx).L
00007522  4EAA 0019                528      JSR     ($19,A2)    (d16,An)
00007526  4EBA 8BD8                529      JSR     ($100,PC)   (d16,PC)
0000752A                           530      
0000752A                           531  JUMP    *For JSR & RTS test
0000752A  1201                     532          MOVE.B  D1, D1
0000752C  4E75                     533          RTS
0000752E  4E71                     534          NOP         NOP
00007530                           535  
00007530                           536  
00007530                           537  
00007530                           538  
00007530                           539  
00007530                           540  -------------------- end include --------------------
00007530                           541  *----------------------------------------------------------------------------
00007530                           542  * Title      : 3B Disassembler
00007530                           543  * Written by : The Three Bears: Joseph Schooley, Nguyen Tong, Terence Calhoun
00007530                           544  * Date       : 11/30/2013
00007530                           545  * Description: A Motorola MC68000 Microprocessor Disassembler 
00007530                           546  *----------------------------------------------------------------------------
00001000                           547          ORG     $1000
00001000  =0000000D                548  CR      EQU     $0D         ASCII: carriage return
00001000  =0000000A                549  LF      EQU     $0A         ASCII: line feed
00001000  =00000009                550  TB      EQU     $09         ASCII: horizontal tab
00001000  =00007000                551  MNADDR  EQU     $7000       Min address
00001000  =00FFFFFF                552  MXADDR  EQU     $00FFFFFF   Max address
00001000                           553  
00001000                           554  GBUFF   DS.L    1           Pointer to next location in "Good buffer"
00001004                           555  SLOC    DS.B    4           Starting location storage
00001008                           556  ELOC    DS.B    4           Ending location storage
0000100C                           557  
0000100C                           558  *-----I/O Memory-----
0000100C                           559  IOOPCD  DS.B    1           IO offset value for OPNAME, or FF if none
0000100D                           560  IOBDCD  DS.B    1           IO offset value for BAD OPNAME, or FF if none
0000100E                           561  IOSIZE  DS.B    1           IO size for OP code, or FF if none
00001010                           562  IOADDR  DS.L    1           IO address value for instruction memory location
00001014                           563  IOLC    DS.B    1           IO line counter for screen
00001015                           564  QDATA   DS.B    1           OP immediate data for xxxxQ instructions
00001016                           565  
00001016                           566  
00001016                           567  * OP code name memory
00001016                           568  * Example to display MULU:
00001016                           569  *       LEA     OPNAME,A1
00001016                           570  *       ADD.L   #$2D,A1
00001016                           571  *       MOVE.B  #14,D0
00001016                           572  *       TRAP    #15
00001016                           573  *                NAME           DEC     HEX
00001016= 4D 4F 56 45 00           574  OPNAME  DC.B    'MOVE',0        00      00
0000101B= 4D 4F 56 45 41 00        575          DC.B    'MOVEA',0       05      05
00001021= 4D 4F 56 45 4D 00        576          DC.B    'MOVEM',0       11      0B
00001027= 41 44 44 00              577          DC.B    'ADD',0         17      11
0000102B= 41 44 44 41 00           578          DC.B    'ADDA',0        21      15
00001030= 41 44 44 51 00           579          DC.B    'ADDQ',0        26      1A
00001035= 53 55 42 00              580          DC.B    'SUB',0         31      1F
00001039= 53 55 42 41 00           581          DC.B    'SUBA',0        35      23
0000103E= 53 55 42 49 00           582          DC.B    'SUBI',0        40      28
00001043= 4D 55 4C 55 00           583          DC.B    'MULU',0        45      2D
00001048= 44 49 56 53 00           584          DC.B    'DIVS',0        50      32
0000104D= 4C 45 41 00              585          DC.B    'LEA',0         55      37
00001051= 41 4E 44 00              586          DC.B    'AND',0         59      3B
00001055= 4F 52 49 00              587          DC.B    'ORI',0         63      3F
00001059= 45 4F 52 00              588          DC.B    'EOR',0         67      43
0000105D= 45 4F 52 49 00           589          DC.B    'EORI',0        71      47
00001062= 4E 4F 54 00              590          DC.B    'NOT',0         76      4C
00001066= 41 53 4C 00              591          DC.B    'ASL',0         80      50
0000106A= 4C 53 52 00              592          DC.B    'LSR',0         84      54
0000106E= 42 54 53 54 00           593          DC.B    'BTST',0        88      58
00001073= 43 4D 50 00              594          DC.B    'CMP',0         93      5D
00001077= 43 4D 50 41 00           595          DC.B    'CMPA',0        97      61
0000107C= 43 4D 50 49 00           596          DC.B    'CMPI',0        102     66
00001081= 42 43 43 00              597          DC.B    'BCC',0         107     6B
00001085= 42 45 51 00              598          DC.B    'BEQ',0         111     6F
00001089= 42 4C 54 00              599          DC.B    'BLT',0         115     73
0000108D= 42 4E 45 00              600          DC.B    'BNE',0         119     77
00001091= 42 48 49 00              601          DC.B    'BHI',0         123     7B
00001095= 4A 53 52 00              602          DC.B    'JSR',0         127     7F
00001099= 52 54 53 00              603          DC.B    'RTS',0         131     83
0000109D= 42 41 44 00              604          DC.B    'BAD',0         135     87
000010A1= 4D 4F 56 45 51 00        605          DC.B    'MOVEQ',0       139     8B
000010A7= 4C 53 4C 00              606          DC.B    'LSL',0         145     91
000010AB= 41 53 52 00              607          DC.B    'ASR',0         149     95
000010AF= 41 44 44 49 00           608          DC.B    'ADDI',0        153     99
000010B4                           609  
000010B4= 2E 42 00                 610  IOOPSZ  DC.B    '.B',0          0       00
000010B7= 2E 57 00                 611          DC.B    '.W',0          3       03
000010BA= 2E 4C 00                 612          DC.B    '.L',0          6,      06
000010BD= 20 20 00                 613          DC.B    '  ',0          9,      09
000010C0                           614  
000010C0                           615  *-----EA Memory------
000010C0                           616  DMD     DS.B    1               Destination mode
000010C1                           617  DRG     DS.B    1               Destination register
000010C2                           618  SMD     DS.B    1               Source mode
000010C3                           619  SRG     DS.B    1               Source register
000010C4                           620  RGMD    DS.B    1               Last register + mod (00REGMOD)
000010C5                           621  DIS     DS.B    1               Last displacement
000010C6                           622  
000010C6                           623  *--------------------
000010C6                           624  
000010C6= 20 20 5F 20 20 20 ...    625  MSSG0   DC.B    '  _     _     _     _     _     _ ',CR,LF
000010EA= 20 28 6F 5C 2D 2D ...    626          DC.B    ' (o\---/o)   (o\---/o)   (o\---/o)',CR,LF
0000110E= 20 20 7C 20 2D 20 ...    627          DC.B    '  | - - |     | ^ ^ |     | . . |',CR,LF
00001131= 20 5F 28 20 28 59 ...    628          DC.B    ' _( (Y)_)_,--.(_(Y)_),--._(_(Y) )_',CR,LF
00001155= 2F 20 2F 5F 5F 5F ...    629          DC.B    '/ /___|_  ".."       ".."  _|___\ \',CR,LF
0000117A= 5C 5F 5F 5F 5F 5F ...    630          DC.B    '\_______):     THREE     :(_______/',CR,LF
0000119F= 7C 20 7C 20 20 20 ...    631          DC.B    '| |   |        BEARS        |   | |',CR,LF
000011C4= 7C 20 7C 20 20 20 ...    632          DC.B    '| |   |    DISASSEMBLER     |   | |',CR,LF
000011E9= 7C 20 20 5C 5F 5F ...    633          DC.B    '|  \__|__Joey__Terence__Win_|__/  |',CR,LF
0000120E= 20 5C 20 20 20 20 ...    634          DC.B    ' \    I  /_  )   |   (  _\  I    /',CR,LF
00001232= 20 20 5C 5F 5F 5F ...    635          DC.B    '  \____)___)(___/ \___)(___(____/',CR,LF
00001255= 57 65 6C 63 6F 6D ...    636          DC.B    'Welcome to 3B Disassembler. Enter 0 at any time to quit.',CR,LF,0
00001290= 45 6E 74 65 72 20 ...    637  MSSG1   DC.B    'Enter the starting location of the code to be disassembled, or leave it blank',CR,LF,'for the starting address:',0
000012F9= 45 6E 74 65 72 20 ...    638  MSSG2   DC.B    'Enter the ending location of the code to be disassembled, or leave it blank',CR,LF,'for the ending address:',0
0000135E= 50 72 65 73 73 20 ...    639  MSSG4   DC.B    'Press any key for the next page.',0
0000137F= 59 6F 75 20 68 61 ...    640  MSSG5   DC.B    'You have reached the end of the program.',0
000013A8= 41 64 64 72 65 73 ...    641  HEADR   DC.B    'Address      OP-Code    Operand',CR,LF,0
000013CA= 54 68 65 20 69 6E ...    642  ERR0    DC.B    'The input address was too small.',CR,LF,0
000013ED= 54 68 65 20 69 6E ...    643  ERR1    DC.B    'The input address was too big.',CR,LF,0
0000140E                           644  
0000140E  11FC 0000 1014           645  START   MOVE.B  #0,IOLC
00001414                           646          *JMP     $7000
00001414  43F8 10C6                647          LEA     MSSG0,A1        Welcome message
00001418  103C 000E                648          MOVE.B  #14,D0
0000141C  4E4F                     649          TRAP    #15
0000141E  6000 0216                650          BRA     PRMPT1
00001422                           651  
00001422                           652  *-----------------------------------
00001422                           653  *    Conversion & Comparison Methods
00001422                           654  *-----------------------------------
00001422                           655  
00001422                           656  *
00001422                           657  * Flag set / clear: Sets or clears the flag
00001422                           658  *
00001422                           659   
00001422  44FC 0004                660  FLAGST  MOVE.W  #%100,CCR       Set the z-flag
00001426  4E75                     661          RTS                     Return to caller
00001428  44FC 0000                662  FLAGCL  MOVE.W  #%000,CCR       Clear the z-flg
0000142C  4E75                     663          RTS                     Return to caller
0000142E                           664  
0000142E                           665  *
0000142E                           666  * ASCII2HEX: Convert ASCII into HEX.
0000142E                           667  * Input ASCII from D0 output HEX to D1
0000142E                           668  *
0000142E                           669  
0000142E                           670  ASCII2HEX
0000142E  2200                     671          MOVE.L  D0,D1           Move the input to D1
00001430  0441 3030                672          SUB     #$3030,D1       Convert last word
00001434  4841                     673          SWAP    D1              Swap bytes
00001436  0441 3030                674          SUB     #$3030,D1       Convert first word
0000143A  4841                     675          SWAP    D1              Restore order
0000143C                           676          
0000143C  2F02                     677          MOVE.L  D2,-(SP)        Push D2 on stack
0000143E  4282                     678          CLR.L   D2              
00001440  143C 0003                679          MOVE.B  #3,D2           Set rotation count
00001444                           680          
00001444  6100 001A                681          BSR     A2H             Start loop
00001448                           682          
00001448  241F                     683          MOVE.L  (SP)+,D2        Restore D2
0000144A                           684                  
0000144A                           685                                * XAXBXCXD
0000144A  E919                     686          ROL.B   #4,D1           XAXBXCDX
0000144C  E949                     687          LSL.W   #4,D1           XAXBCDX0
0000144E  E159                     688          ROL.W   #8,D1           XAXBX0CD
00001450  4841                     689          SWAP    D1              X0CDXAXB
00001452  E919                     690          ROL.B   #4,D1           X0CDXABX
00001454  E949                     691          LSL.W   #4,D1           X0CDABX0
00001456  E189                     692          LSL.L   #8,D1           CDABX000
00001458  4241                     693          CLR.W   D1              CDAB0000
0000145A  4841                     694          SWAP    D1              0000CDAB
0000145C  E159                     695          ROL.W   #8,D1           0000ABCD
0000145E  4E75                     696          RTS                     Return to caller
00001460                           697          
00001460                           698          
00001460                           699  A2H   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
00001460  B23C 0011                700          CMP.B   #$11,D1         11 = A
00001464  6700 0032                701          BEQ     A2H11
00001468  B23C 0012                702          CMP.B   #$12,D1         12 = B
0000146C  6700 0030                703          BEQ     A2H12
00001470  B23C 0013                704          CMP.B   #$13,D1         13 = C
00001474  6700 002E                705          BEQ     A2H13
00001478  B23C 0014                706          CMP.B   #$14,D1         14 = D
0000147C  6700 002C                707          BEQ     A2H14
00001480  B23C 0015                708          CMP.B   #$15,D1         15 = E
00001484  6700 002A                709          BEQ     A2H15
00001488  B23C 0016                710          CMP.B   #$16,D1         16 = F
0000148C  6700 0028                711          BEQ     A2H16
00001490                           712          
00001490                           713  A2HADV  * A2H conversion branch helper: Rotate to the next byte, and loop back to A2H until all bytes have been analyzed/converted
00001490  E199                     714          ROL.L   #8,D1           Rotate 1st byte to the end
00001492  51CA FFCC                715          DBRA    D2,A2H          If count is > 0, decrement and loop back to A2H
00001496  4E75                     716          RTS                     If count == 0, return to sub-routine
00001498                           717  
00001498                           718  * A2H conversion branches
00001498  123C 000A                719  A2H11   MOVE.B  #$A,D1
0000149C  60F2                     720          BRA     A2HADV
0000149E  123C 000B                721  A2H12   MOVE.B  #$B,D1
000014A2  60EC                     722          BRA     A2HADV
000014A4  123C 000C                723  A2H13   MOVE.B  #$C,D1
000014A8  60E6                     724          BRA     A2HADV
000014AA  123C 000D                725  A2H14   MOVE.B  #$D,D1
000014AE  60E0                     726          BRA     A2HADV
000014B0  123C 000E                727  A2H15   MOVE.B  #$E,D1
000014B4  60DA                     728          BRA     A2HADV
000014B6  123C 000F                729  A2H16   MOVE.B  #$F,D1
000014BA  60D4                     730          BRA     A2HADV
000014BC                           731  
000014BC                           732  *
000014BC                           733  * HEX2ASCII: Convert ASCII into HEX.
000014BC                           734  * Input HEX from D0.W output ASCII to D1.L
000014BC                           735  *
000014BC                           736  
000014BC                           737  HEX2ASCII
000014BC  2200                     738          MOVE.L  D0,D1           Move the input to D1
000014BE                           739  
000014BE                           740                                * XXXXABCD
000014BE  4841                     741          SWAP    D1              ABCDXXXX
000014C0  4241                     742          CLR.W   D1              ABCD0000
000014C2  E999                     743          ROL.L   #4,D1           BCD0000A
000014C4  E909                     744          LSL.B   #4,D1           BCD000A0
000014C6  E159                     745          ROL.W   #8,D1           BCD0A000
000014C8  E999                     746          ROL.L   #4,D1           CD0A000B
000014CA  E159                     747          ROL.W   #8,D1           CD0A0B00
000014CC  E999                     748          ROL.L   #4,D1           D0A0B00C
000014CE  E909                     749          LSL.B   #4,D1           D0A0B0C0
000014D0  E999                     750          ROL.L   #4,D1           0A0B0C0D
000014D2                           751  
000014D2  2F02                     752          MOVE.L  D2,-(SP)        Push D2 on stack
000014D4  4282                     753          CLR.L   D2              
000014D6  143C 0003                754          MOVE.B  #3,D2           Set rotation count
000014DA  6100 0012                755          BSR     H2A             Start loop
000014DE  241F                     756          MOVE.L  (SP)+,D2        Restore D2
000014E0                           757  
000014E0  0641 3030                758          ADD     #$3030,D1       Convert last word
000014E4  4841                     759          SWAP    D1              Swap bytes
000014E6  0641 3030                760          ADD     #$3030,D1       Convert first word
000014EA  4841                     761          SWAP    D1              Restore order
000014EC  4E75                     762          RTS                     Return to caller
000014EE                           763          
000014EE                           764          
000014EE                           765  H2A   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
000014EE  B23C 000A                766          CMP.B   #$A,D1         A = 11
000014F2  6700 0032                767          BEQ     H2AA
000014F6  B23C 000B                768          CMP.B   #$B,D1         B = 12
000014FA  6700 0030                769          BEQ     H2AB
000014FE  B23C 000C                770          CMP.B   #$C,D1         C = 13
00001502  6700 002E                771          BEQ     H2AC
00001506  B23C 000D                772          CMP.B   #$D,D1         D = 14
0000150A  6700 002C                773          BEQ     H2AD
0000150E  B23C 000E                774          CMP.B   #$E,D1         E = 15
00001512  6700 002A                775          BEQ     H2AE
00001516  B23C 000F                776          CMP.B   #$F,D1         F = 16
0000151A  6700 0028                777          BEQ     H2AF
0000151E                           778          
0000151E                           779  H2AADV  * H2A conversion branch helper: Rotate to the next byte, and loop back to H2A until all bytes have been analyzed/converted
0000151E  E199                     780          ROL.L   #8,D1           Rotate 1st byte to the end
00001520  51CA FFCC                781          DBRA    D2,H2A          If count is > 0, decrement and loop back to A2H
00001524  4E75                     782          RTS                     If count == 0, return to sub-routine
00001526                           783  
00001526                           784  * H2A conversion branches
00001526  123C 0011                785  H2AA    MOVE.B  #$11,D1
0000152A  60F2                     786          BRA     H2AADV
0000152C  123C 0012                787  H2AB    MOVE.B  #$12,D1
00001530  60EC                     788          BRA     H2AADV
00001532  123C 0013                789  H2AC    MOVE.B  #$13,D1
00001536  60E6                     790          BRA     H2AADV
00001538  123C 0014                791  H2AD    MOVE.B  #$14,D1
0000153C  60E0                     792          BRA     H2AADV
0000153E  123C 0015                793  H2AE    MOVE.B  #$15,D1
00001542  60DA                     794          BRA     H2AADV
00001544  123C 0016                795  H2AF    MOVE.B  #$16,D1
00001548  60D4                     796          BRA     H2AADV
0000154A                           797  
0000154A                           798  
0000154A                           799  *
0000154A                           800  * Mask: Mask an input
0000154A                           801  * Input value from D0, input mask from D2, output masked value to D1
0000154A                           802  *
0000154A                           803  
0000154A  2200                     804  MASK    MOVE.L  D0,D1           Move the input to D1
0000154C  C282                     805          AND.L   D2,D1           Perform AND on input with the mask
0000154E  4E75                     806          RTS                     Return to caller
00001550                           807  
00001550                           808  *
00001550                           809  * Test Mask: Test an input to a mask.
00001550                           810  * Input value from D0, input mask from D2, and modify z-flag
00001550                           811  *
00001550                           812  
00001550  2F01                     813  TSTMSK  MOVE.L  D1,-(SP)        Push D1 on stack
00001552  61F6                     814          BSR     MASK            Mask the input
00001554  B481                     815          CMP.L   D1,D2           Test if the input matched the mask
00001556  6606                     816          BNE     *+8             If it didn't match, skip two lines
00001558  221F                     817          MOVE.L  (SP)+,D1        Restore D1
0000155A  6000 FEC6                818          BRA     FLAGST          Set flag & return to caller
0000155E  221F                     819          MOVE.L  (SP)+,D1        Restore D1
00001560  6000 FEC6                820          BRA     FLAGCL          Clear flag & return to caller
00001564                           821  
00001564                           822  *
00001564                           823  * Compare Mask: Strictly test an input to two masks allowing don't cares.
00001564                           824  * Input value from D0, input 1 mask from D2, input 0 mask from D3, and modify z-flag
00001564                           825  *
00001564                           826  
00001564  48E7 F800                827  CMPMSK  MOVEM.L D0-D4,-(SP)     Push D1-D4 on stack
00001568  2800                     828          MOVE.L  D0,D4           Copy input to D4
0000156A  C082                     829          AND.L   D2,D0           AND 1 mask to input
0000156C  B480                     830          CMP.L   D0,D2           Compare masked input to 1 mask
0000156E  6708                     831          BEQ     *+10            If it matched, skip two lines
00001570  4CDF 001F                832          MOVEM.L (SP)+,D0-D4     If it didn't match, restore D1-D4
00001574  6000 FEB2                833          BRA     FLAGCL          Clear flag & return to caller
00001578  2004                     834          MOVE.L  D4,D0           Restore input
0000157A  4680                     835          NOT.L   D0              !input
0000157C  C083                     836          AND.L   D3,D0           AND 0 mask on input; effectively, NOR 0 mask to the input
0000157E  B680                     837          CMP.L   D0,D3           Compare masked input to 0 mask
00001580  6608                     838          BNE     *+10            If it didn't match, skip to clear flag
00001582  4CDF 001F                839          MOVEM.L (SP)+,D0-D4     If it matched, restore D1-D4
00001586  6000 FE9A                840          BRA     FLAGST          Set flag & return to caller
0000158A  4CDF 001F                841          MOVEM.L (SP)+,D0-D4     Restore D1-D4
0000158E  6000 FE98                842          BRA     FLAGCL          Clear flag & return to caller
00001592                           843  
00001592                           844  *        
00001592                           845  * Extract Mask: Test an input to a subsequent mask, and return the masked value in LSB format
00001592                           846  * Input value from D0, input mask from D2, output value in D1
00001592                           847  *
00001592                           848  
00001592  2F02                     849  EXTMSK  MOVE.L  D2,-(SP)        Push D2 on stack
00001594  2200                     850          MOVE.L  D0,D1           Move the input to D1
00001596  C282                     851          AND.L   D2,D1           Perform AND on input with the mask
00001598  0802 0000                852  EXTLP   BTST.L  #0,D2           Test the LSB of the mask for 0
0000159C  6700 0006                853          BEQ     EXTADV          If it is 0, rotate the mask until it is 1
000015A0  241F                     854          MOVE.L  (SP)+,D2        Restore the mask
000015A2  4E75                     855          RTS                     Return to caller
000015A4                           856          
000015A4  E28A                     857  EXTADV  LSR.L   #1,D2           Rotate mask right by 1 bit
000015A6  E299                     858          ROR.L   #1,D1           Rotate output in sync with mask
000015A8  60EE                     859          BRA     EXTLP           Return to loop
000015AA                           860  
000015AA                           861  *
000015AA                           862  * Display ASCII: Display the ASCII from D0.L to screen
000015AA                           863  *
000015AA  48E7 E000                864  DSPAX   MOVEM.L D0-D2,-(SP)     Push D0-D2
000015AE  2200                     865          MOVE.L  D0,D1
000015B0  6000 0044                866          BRA     DSPHST          Branch to DISPHX Start
000015B4                           867  
000015B4                           868  *
000015B4                           869  * Display HEX Address: Display the hex from A1 according to the byte length in D2.L
000015B4                           870  *
000015B4                           871  
000015B4  48E7 E040                872  DSPHXA  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
000015B8  51CA 0006                873  DSPHXLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
000015BC  6000 0016                874          BRA     DSPHXRT         If count is <= 0, branch to return
000015C0  1019                     875          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
000015C2  6100 FEF8                876          BSR     HEX2ASCII       Get ASCII in D1
000015C6  E159                     877          ROL.W   #8,D1           Read first byte
000015C8  103C 0006                878          MOVE.B  #6,D0           Display char from D1.B
000015CC  4E4F                     879          TRAP    #15
000015CE  E159                     880          ROL.W   #8,D1           Read second byte
000015D0  4E4F                     881          TRAP    #15
000015D2  60E4                     882          BRA     DSPHXLP         Loop back
000015D4  4CDF 0207                883  DSPHXRT MOVEM.L (SP)+,D0-D2/A1  Else, restore values
000015D8  4E75                     884          RTS                     Return to caller
000015DA                           885          
000015DA                           886  
000015DA                           887  
000015DA                           888  *
000015DA                           889  * Display HEX Nibble: Display the hex from D0.B to screen
000015DA                           890  *
000015DA                           891  
000015DA  48E7 C000                892  DSPHXN  MOVEM.L D0/D1,-(SP)     Push D0 and D1 to stack
000015DE  6100 FEDC                893          BSR     HEX2ASCII       Get ASCII in D1
000015E2  103C 0006                894          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
000015E6  4E4F                     895          TRAP    #15
000015E8  4CDF 0003                896          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
000015EC  4E75                     897          RTS                     Return to caller
000015EE                           898  
000015EE                           899  *
000015EE                           900  * Display HEX Word: Display the hex from D0.W to screen
000015EE                           901  *
000015EE                           902  
000015EE  48E7 E000                903  DSPHXW  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
000015F2  6100 FEC8                904          BSR     HEX2ASCII       Get ASCII in D1
000015F6                           905  
000015F6  4282                     906  DSPHST  CLR.L   D2              
000015F8  143C 0003                907          MOVE.B  #3,D2           Set rotation count
000015FC  103C 0006                908          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
00001600  6100 0008                909          BSR     DSPHADV         Start loop
00001604                           910  
00001604  4CDF 0007                911          MOVEM.L  (SP)+,D0-D2    Restore D0-D2
00001608  4E75                     912          RTS                     Return to caller
0000160A                           913  
0000160A  E199                     914  DSPHADV ROL.L   #8,D1           Rotate bytes left
0000160C  4E4F                     915          TRAP    #15             Display char in D1.B
0000160E  51CA FFFA                916          DBRA    D2,DSPHADV      If count is > 0, decrement and loop back to DSPHADV
00001612  4E75                     917          RTS                     If count == 0, return to sub-routine
00001614                           918  
00001614                           919  *
00001614                           920  * Display HEX Long: Display the hex from D0.L to screen
00001614                           921  *
00001614                           922  
00001614  4840                     923  DSPHXL  SWAP    D0              Swap first half to D0.W
00001616  61D6                     924          BSR     DSPHXW          Display first half
00001618  4840                     925          SWAP    D0              Swap lower half to D0.W
0000161A  61D2                     926          BSR     DSPHXW          Display lower half
0000161C  4E75                     927          RTS                     Return to caller
0000161E                           928          
0000161E                           929  
0000161E                           930          
0000161E                           931  *--------------------
0000161E                           932  *   I/O
0000161E                           933  *--------------------                   
0000161E  43F8 13CA                934  ILL0    LEA     ERR0,A1         Starting location was too small
00001622  103C 000E                935          MOVE.B  #14,D0
00001626  4E4F                     936          TRAP    #15
00001628  6000 000C                937          BRA     PRMPT1
0000162C                           938          
0000162C  43F8 13ED                939  ILL1    LEA     ERR1,A1         Starting location was too big
00001630  103C 000E                940          MOVE.B  #14,D0
00001634  4E4F                     941          TRAP    #15
00001636                           942          
00001636  43F8 1290                943  PRMPT1  LEA     MSSG1,A1        Starting location request message
0000163A  103C 000E                944          MOVE.B  #14,D0
0000163E  4E4F                     945          TRAP    #15
00001640                           946          
00001640  43F8 1004                947          LEA     SLOC,A1         Input will be stored in SLOC
00001644  103C 0002                948          MOVE.B  #2,D0           Input starting location (as string / hex)
00001648  4E4F                     949          TRAP    #15
0000164A                           950          
0000164A  2038 1004                951          MOVE.L  (SLOC),D0       Move input to D0
0000164E                           952  
0000164E  B0BC 00FFFFFF            953          CMP.L   #$00FFFFFF,D0   Check if input was NULL
00001654  660C                     954          BNE     *+14            If the input was not null, branch to convert input
00001656  21FC 00007000 1004       955          MOVE.L  #MNADDR,(SLOC)  If the input was null, move the min address to SLOC
0000165E  6000 003E                956          BRA     PRMPT2          Branch to the next prompt
00001662                           957          
00001662  6100 FDCA                958          BSR     ASCII2HEX       Convert D0 to HEX in D1
00001666                           959          
00001666  2281                     960          MOVE.L  D1,(A1)         Set SLOC to HEX value
00001668                           961                          
00001668  B2BC 00000000            962          CMP.L   #0,D1           Compare starting location to 0
0000166E  6700 047A                963          BEQ     DONE            End program if 0
00001672                           964          
00001672  B2BC 00007000            965          CMP.L   #MNADDR,D1      Compare starting location to min
00001678  65A4                     966          BLO     ILL0            Branch to ILL0 if < min
0000167A                           967          
0000167A  B2BC 00FFFFFF            968          CMP.L   #MXADDR,D1      Compare ending location to max
00001680  64AA                     969          BHS     ILL1            Branch to ILL1 if >= max
00001682                           970                  
00001682  6000 001A                971          BRA     PRMPT2          Branch to the next prompt
00001686                           972  
00001686  43F8 13CA                973  ILL2    LEA     ERR0,A1         Ending location was too small
0000168A  103C 000E                974          MOVE.B  #14,D0
0000168E  4E4F                     975          TRAP    #15
00001690  6000 000C                976          BRA     PRMPT2
00001694                           977          
00001694  43F8 13ED                978  ILL3    LEA     ERR1,A1         Ending location was too big
00001698  103C 000E                979          MOVE.B  #14,D0
0000169C  4E4F                     980          TRAP    #15
0000169E                           981          
0000169E  43F8 12F9                982  PRMPT2  LEA     MSSG2,A1        Ending location request message
000016A2  103C 000E                983          MOVE.B  #14,D0
000016A6  4E4F                     984          TRAP    #15
000016A8                           985          
000016A8  43F8 1008                986          LEA     ELOC,A1         Input will be stored in SLOC
000016AC  103C 0002                987          MOVE.B  #2,D0           Input starting location (as string / hex)
000016B0  4E4F                     988          TRAP    #15
000016B2                           989          
000016B2  2038 1008                990          MOVE.L  (ELOC),D0       Move input to D0
000016B6                           991  
000016B6  B0BC 00FFFFFF            992          CMP.L   #$00FFFFFF,D0   Check if input was NULL
000016BC  660C                     993          BNE     *+14            If the input was not null, branch to convert input
000016BE  21FC 00FFFFFF 1008       994          MOVE.L  #MXADDR,(ELOC)  If the input was null, move the max address to ELOC
000016C6  6000 002A                995          BRA     PRMPTDN         Branch to prompt done
000016CA                           996          
000016CA  6100 FD62                997          BSR     ASCII2HEX       Convert D0 to HEX in D1
000016CE                           998          
000016CE  2281                     999          MOVE.L  D1,(A1)         Set ELOC to HEX value
000016D0                          1000  
000016D0  B2BC 00000000           1001          CMP.L   #0,D1           Compare ending location to 0
000016D6  6700 0412               1002          BEQ     DONE            End program if 0
000016DA                          1003          
000016DA  B2BC 00007000           1004          CMP.L   #MNADDR,D1      Compare min ending location to min
000016E0  63A4                    1005          BLS     ILL2            Branch to ILL2 if <= min
000016E2                          1006          
000016E2  B2BC 00FFFFFF           1007          CMP.L   #MXADDR,D1      Compare ending location to max
000016E8  62AA                    1008          BHI     ILL3            Branch to ILL3 if > max
000016EA                          1009          
000016EA  2038 1004               1010          MOVE.L  (SLOC),D0       Move starting location data to D0
000016EE  B280                    1011          CMP.L   D0,D1           Compare ending location to starting location
000016F0  6394                    1012          BLS     ILL2            Branch to ILL3 if <= starting location
000016F2                          1013          
000016F2  21F8 1004 1000          1014  PRMPTDN MOVE.L  SLOC,GBUFF      Store starting location in GBUFF for OP
000016F8  6000 03D4               1015          BRA     DSPHDR          Branch to display method
000016FC                          1016  
000016FC                          1017  *
000016FC                          1018  * Display string: Displays string until NULL char
000016FC                          1019  * Input string at A1, output length of string at D1.B
000016FC                          1020  * Max length: 255
000016FC                          1021  *
000016FC                          1022          
000016FC  48E7 E040               1023  DSPSTR  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
00001700  243C 000000FF           1024          MOVE.L  #255,D2         Set count to 255
00001706  51CA 0006               1025  DSPSTLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
0000170A  6000 0016               1026          BRA     DSPSTRT         If count is <= 0, branch to return
0000170E  1019                    1027          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
00001710  B03C 0000               1028          CMP.B   #0,D0           Check if byte is NULL char
00001714  6700 000C               1029          BEQ     DSPSTRT         If byte is NULL char, branch to return
00001718  6100 FDA2               1030          BSR     HEX2ASCII       Else, get ASCII in D1
0000171C  6100 FE8C               1031          BSR     DSPAX           Display ASCII
00001720  60E4                    1032          BRA     DSPSTLP         Loop back
00001722  4482                    1033  DSPSTRT NEG.L   D2              Negate count
00001724  0682 000000FE           1034          ADD.L   #254,D2         Add 254; effectively 255 - count - null byte
0000172A  4CDF 0003               1035          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
0000172E  1202                    1036          MOVE.B  D2,D1           Move length to D1
00001730  4CDF 0204               1037          MOVEM.L (SP)+,D2/A1     Restore D2 and A1
00001734  4E75                    1038          RTS                     Return to caller
00001736                          1039  
00001736                          1040  *
00001736                          1041  * Display offset space: Display space according to offset length
00001736                          1042  * Input offset length in D2.B
00001736                          1043  *
00001736                          1044  
00001736  48E7 E000               1045  DSPOFS  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
0000173A                          1046          * Ensure count is strictly in one byte
0000173A  4280                    1047          CLR.L   D0
0000173C  1002                    1048          MOVE.B  D2,D0
0000173E  2400                    1049          MOVE.L  D0,D2
00001740  51CA 0006               1050  DSPOFLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001744  6000 000E               1051          BRA     DSPOFRT         If count is <= 0, branch to return
00001748  103C 0006               1052          MOVE.B  #6,D0           Display character
0000174C  123C 0020               1053          MOVE.B  #' ',D1         Read space
00001750  4E4F                    1054          TRAP    #15
00001752  60EC                    1055          BRA     DSPOFLP         Loop back
00001754  4CDF 0007               1056  DSPOFRT MOVEM.L (SP)+,D0-D2     Restore D0-D2
00001758  4E75                    1057          RTS                     Return to callr
0000175A                          1058  
0000175A                          1059  *
0000175A                          1060  * Display operand: Displays operand according to mode and register
0000175A                          1061  * Input mode in D2.B, input reg in D3.B
0000175A                          1062  *
0000175A                          1063  
0000175A  48E7 E000               1064  DISPOP  MOVEM.L D0-D2,-(SP)         Push D0-D2 to stack
0000175E  103C 0006               1065          MOVE.B  #6,D0               Display character
00001762  C4FC 0004               1066          MULU.W  #4,D2
00001766  4EFB 2002               1067          JMP     DMDTBL(PC,D2.W)     Jump to mode
0000176A  6000 001E               1068  DMDTBL  BRA     DISP0               Dn
0000176E  6000 002A               1069          BRA     DISP1               An
00001772  6000 0036               1070          BRA     DISP2               (An)
00001776  6000 0052               1071          BRA     DISP3               (An)+
0000177A  6000 0074               1072          BRA     DISP4               -(An)
0000177E  6000 0096               1073          BRA     DISP5               (d,An)
00001782  6000 00AE               1074          BRA     DISP6               (d,An,Xn)
00001786  6000 00D2               1075          BRA     DISP7               (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
0000178A                          1076  * Dn            000 XXX
0000178A  123C 0044               1077  DISP0   MOVE.B  #'D',D1             Read D
0000178E  4E4F                    1078          TRAP    #15
00001790  2003                    1079          MOVE.L  D3,D0               Read reg from D3
00001792  6100 FE46               1080          BSR     DSPHXN              Display as hex nibble
00001796  6000 0192               1081          BRA     DISPD               Branch to return
0000179A                          1082  * An            001 XXX
0000179A  123C 0041               1083  DISP1   MOVE.B  #'A',D1             Read A
0000179E  4E4F                    1084          TRAP    #15
000017A0  2003                    1085          MOVE.L  D3,D0               Read reg from D3
000017A2  6100 FE36               1086          BSR     DSPHXN              Display as hex byte
000017A6  6000 0182               1087          BRA     DISPD               Branch to return
000017AA                          1088  * (An)          010 XXX
000017AA  123C 0028               1089  DISP2   MOVE.B  #'(',D1             Read (
000017AE  4E4F                    1090          TRAP    #15
000017B0  123C 0041               1091          MOVE.B  #'A',D1             Read A
000017B4  4E4F                    1092          TRAP    #15
000017B6  2003                    1093          MOVE.L  D3,D0               Read reg from D3
000017B8  6100 FE20               1094          BSR     DSPHXN              Display as hex nibble
000017BC  103C 0006               1095          MOVE.B  #6,D0               Display character
000017C0  123C 0029               1096          MOVE.B  #')',D1             Read )
000017C4  4E4F                    1097          TRAP    #15
000017C6  6000 0162               1098          BRA     DISPD               Branch to return
000017CA                          1099  * (An)+         011 XXX
000017CA  123C 0028               1100  DISP3   MOVE.B  #'(',D1             Read (
000017CE  4E4F                    1101          TRAP    #15
000017D0  123C 0041               1102          MOVE.B  #'A',D1             Read A
000017D4  4E4F                    1103          TRAP    #15
000017D6  2003                    1104          MOVE.L  D3,D0               Read reg from D3
000017D8  6100 FE00               1105          BSR     DSPHXN              Display as hex nibble
000017DC  103C 0006               1106          MOVE.B  #6,D0               Display character
000017E0  123C 0029               1107          MOVE.B  #')',D1             Read )
000017E4  4E4F                    1108          TRAP    #15
000017E6  123C 002B               1109          MOVE.B  #'+',D1             Read +
000017EA  4E4F                    1110          TRAP    #15
000017EC  6000 013C               1111          BRA     DISPD               Branch to return
000017F0                          1112  * -(An)         100 XXX
000017F0  123C 002D               1113  DISP4   MOVE.B  #'-',D1             Read +
000017F4  4E4F                    1114          TRAP    #15
000017F6  123C 0028               1115          MOVE.B  #'(',D1             Read (
000017FA  4E4F                    1116          TRAP    #15
000017FC  123C 0041               1117          MOVE.B  #'A',D1             Read A
00001800  4E4F                    1118          TRAP    #15
00001802  2003                    1119          MOVE.L  D3,D0               Read reg from D3
00001804  6100 FDD4               1120          BSR     DSPHXN              Display as hex nibble
00001808  103C 0006               1121          MOVE.B  #6,D0               Display character
0000180C  123C 0029               1122          MOVE.B  #')',D1             Read )
00001810  4E4F                    1123          TRAP    #15
00001812  6000 0116               1124          BRA     DISPD               Branch to return
00001816                          1125  * (d,An)        101 XXX
00001816  123C 0028               1126  DISP5   MOVE.B  #'(',D1             Read (
0000181A  4E4F                    1127          TRAP    #15
0000181C                          1128          *----TODO---*
0000181C                          1129          * Display d *
0000181C  123C 002C               1130          MOVE.B  #',',D1             Read ,
00001820  4E4F                    1131          TRAP    #15
00001822  123C 0041               1132          MOVE.B  #'A',D1             Read A
00001826  4E4F                    1133          TRAP    #15
00001828                          1134          *----TODO---*
00001828                          1135          * Display A *
00001828  123C 0029               1136          MOVE.B  #')',D1             Read )
0000182C  4E4F                    1137          TRAP    #15
0000182E  6000 00FA               1138          BRA     DISPD               Branch to return
00001832                          1139  * (d,An,Xn)     110 XXX
00001832  123C 0028               1140  DISP6   MOVE.B  #'(',D1             Read (
00001836  4E4F                    1141          TRAP    #15
00001838                          1142          *----TODO---*
00001838                          1143          * Display d *
00001838  123C 002C               1144          MOVE.B  #',',D1             Read ,
0000183C  4E4F                    1145          TRAP    #15
0000183E  123C 0041               1146          MOVE.B  #'A',D1             Read A
00001842  4E4F                    1147          TRAP    #15
00001844                          1148          *----TODO---*
00001844                          1149          * Display A *
00001844  123C 002C               1150          MOVE.B  #',',D1             Read ,
00001848  4E4F                    1151          TRAP    #15
0000184A  123C 0058               1152          MOVE.B  #'X',D1             Read X
0000184E  4E4F                    1153          TRAP    #15
00001850                          1154          *----TODO---*
00001850                          1155          * Display X *
00001850  123C 0029               1156          MOVE.B  #')',D1             Read )
00001854  4E4F                    1157          TRAP    #15
00001856  6000 00D2               1158          BRA     DISPD               Branch to return
0000185A                          1159  * (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
0000185A  C6FC 0004               1160  DISP7   MULU.W  #4,D3
0000185E  4EFB 3002               1161          JMP     DRGTBL(PC,D3.W)     Jump to reg
00001862  6000 0012               1162  DRGTBL  BRA     DISP8               (XXX).W
00001866  6000 002A               1163          BRA     DISP9               (XXX).L
0000186A  6000 0042               1164          BRA     DISPA               (d,PC)
0000186E  6000 0060               1165          BRA     DISPB               (d,PC,Xn)
00001872  6000 008A               1166          BRA     DISPC               #data
00001876                          1167  * (XXX.W)       111 000
00001876                          1168  DISP8   
00001876  123C 0024               1169          MOVE.B  #'$',D1             Read $
0000187A  4E4F                    1170          TRAP    #15
0000187C  2278 1010               1171          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001880  4282                    1172          CLR.L   D2
00001882  143C 0002               1173          MOVE.B  #2,D2               Read word size to D2
00001886  6100 FD2C               1174          BSR     DSPHXA              Display address
0000188A  D5B8 1010               1175          ADD.L   D2,(IOADDR)         Advance IO address by word
0000188E  6000 009A               1176          BRA     DISPD               Branch to return
00001892                          1177  * (XXX.L)       111 001
00001892  123C 0024               1178  DISP9   MOVE.B  #'$',D1             Read $
00001896  4E4F                    1179          TRAP    #15
00001898  2278 1010               1180          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000189C  4282                    1181          CLR.L   D2
0000189E  143C 0004               1182          MOVE.B  #4,D2               Read long size to D2
000018A2  6100 FD10               1183          BSR     DSPHXA              Display address
000018A6  D5B8 1010               1184          ADD.L   D2,(IOADDR)         Advance IO address by long
000018AA  6000 007E               1185          BRA     DISPD               Branch to return
000018AE                          1186  * (d,PC)        111 010
000018AE  123C 0028               1187  DISPA   MOVE.B  #'(',D1             Read (
000018B2  4E4F                    1188          TRAP    #15
000018B4                          1189          *----TODO---*
000018B4                          1190          * Display d *
000018B4  123C 002C               1191          MOVE.B  #',',D1             Read ,
000018B8  4E4F                    1192          TRAP    #15
000018BA  123C 0050               1193          MOVE.B  #'P',D1             Read P
000018BE  4E4F                    1194          TRAP    #15
000018C0  123C 0043               1195          MOVE.B  #'C',D1             Read C
000018C4  4E4F                    1196          TRAP    #15
000018C6  123C 0029               1197          MOVE.B  #')',D1             Read )
000018CA  4E4F                    1198          TRAP    #15
000018CC  6000 005C               1199          BRA     DISPD
000018D0                          1200  * (d,PC,Xn)     111 011
000018D0  123C 0028               1201  DISPB   MOVE.B  #'(',D1             Read (
000018D4  4E4F                    1202          TRAP    #15
000018D6                          1203          *----TODO---*
000018D6                          1204          * Display d *
000018D6  123C 002C               1205          MOVE.B  #',',D1             Read ,
000018DA  4E4F                    1206          TRAP    #15
000018DC  123C 0050               1207          MOVE.B  #'P',D1             Read P
000018E0  4E4F                    1208          TRAP    #15
000018E2  123C 0043               1209          MOVE.B  #'C',D1             Read C
000018E6  4E4F                    1210          TRAP    #15
000018E8  123C 002C               1211          MOVE.B  #',',D1             Read ,
000018EC  4E4F                    1212          TRAP    #15
000018EE  123C 0058               1213          MOVE.B  #'X',D1             Read X
000018F2  4E4F                    1214          TRAP    #15
000018F4                          1215          *----TODO---*
000018F4                          1216          * Display X *
000018F4  123C 0029               1217          MOVE.B  #')',D1             Read )
000018F8  4E4F                    1218          TRAP    #15
000018FA  6000 002E               1219          BRA     DISPD               Branch to return
000018FE                          1220  * #<data>       111 100
000018FE  123C 0023               1221  DISPC   MOVE.B  #'#',D1             Read #
00001902  4E4F                    1222          TRAP    #15
00001904  2278 1010               1223          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001908  4282                    1224          CLR.L   D2
0000190A  1438 100E               1225          MOVE.B  (IOSIZE),D2         Read instruction size to D2
0000190E  B43C 0000               1226          CMP.B   #0,D2               Test if size is byte
00001912  6604                    1227          BNE     *+6                 If !=, skip next line
00001914  143C 0001               1228          MOVE.B  #1,D2               If ==, change byte to word
00001918  C4FC 0002               1229          MULU.W  #2,D2               Translate size to value
0000191C  6100 FC96               1230          BSR     DSPHXA              Display address
00001920  D3C2                    1231          ADD.L   D2,A1               Advance A1 by instruction size
00001922  21C9 1010               1232          MOVE.L  A1,(IOADDR)         Move A1 to IOADDR
00001926  6000 0002               1233          BRA     DISPD               Branch to return
0000192A  4CDF 0007               1234  DISPD   MOVEM.L (SP)+,D0-D2         Restore D0-D2
0000192E  4E75                    1235          RTS                         Return to caller
00001930                          1236          
00001930  11F8 100C 100D          1237  BRBAD   MOVE.B  (IOOPCD),(IOBDCD)   Move OPCODE to BAD OPCODE
00001936  11FC 0087 100C          1238          MOVE.B  #$87,(IOOPCD)       Set OPCODE to BAD
0000193C                          1239          * Clear bad data
0000193C  11FC 00FF 10C2          1240          MOVE.B  #$FF,(SMD)
00001942  11FC 00FF 10C3          1241          MOVE.B  #$FF,(SRG)
00001948  11FC 00FF 10C0          1242          MOVE.B  #$FF,(DMD)
0000194E  11FC 00FF 10C1          1243          MOVE.B  #$FF,(DRG)
00001954  11FC 00FF 100E          1244          MOVE.B  #$FF,(IOSIZE)
0000195A                          1245          
0000195A                          1246  PRINT   *----TODO----*
0000195A                          1247          * If OP code exists as BAD and BAD OPCODE don't exist, assume that the last
0000195A                          1248          * OP display was BAD, and display then next word as raw data
0000195A  0C38 00FF 100C          1249          CMP.B   #$FF,(IOOPCD)       Test if OP code exists
00001960  67CE                    1250          BEQ     BRBAD               If it does not, display BAD
00001962                          1251  
00001962  2038 1010               1252          MOVE.L  (IOADDR),D0         Read memory location
00001966  6100 FCAC               1253          BSR     DSPHXL              Display as hex long
0000196A  103C 0006               1254          MOVE.B  #6,D0               Display character
0000196E  123C 0009               1255          MOVE.B  #TB,D1              Read tab
00001972  4E4F                    1256          TRAP    #15
00001974                          1257  
00001974  4280                    1258          CLR.L   D0
00001976  4282                    1259          CLR.L   D2
00001978  43F8 1016               1260          LEA     OPNAME,A1           Read OP-code
0000197C  1038 100C               1261          MOVE.B  (IOOPCD),D0         Get offset
00001980  D3C0                    1262          ADD.L   D0,A1               Add offset
00001982  6100 FD78               1263          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001986  1401                    1264          MOVE.B  D1,D2               Store length in D2 to be used as space offset
00001988                          1265      
00001988  0C38 00FF 100D          1266          CMP.B   #$FF,(IOBDCD)       Test if BAD OP code exists
0000198E  6732                    1267          BEQ     *+52                If it doesn't exist, don't display it
00001990  103C 0006               1268          MOVE.B  #6,D0               Display character
00001994  123C 0020               1269          MOVE.B  #' ',D1             Read space
00001998  4E4F                    1270          TRAP    #15
0000199A  123C 0028               1271          MOVE.B  #'(',D1             Read (
0000199E  4E4F                    1272          TRAP    #15
000019A0  43F8 1016               1273          LEA     OPNAME,A1           Read OP-code
000019A4  1038 100D               1274          MOVE.B  (IOBDCD),D0         Get offset
000019A8  D3C0                    1275          ADD.L   D0,A1               Add offset
000019AA  6100 FD50               1276          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000019AE  D401                    1277          ADD.B   D1,D2               Add length to space offset
000019B0  103C 0006               1278          MOVE.B  #6,D0               Display character
000019B4  123C 003F               1279          MOVE.B  #'?',D1
000019B8  4E4F                    1280          TRAP    #15                 Read ?
000019BA  123C 0029               1281          MOVE.B  #')',D1             Read )
000019BE  4E4F                    1282          TRAP    #15
000019C0  5402                    1283          ADD.B   #2,D2               Add 2 to space offset to account for ( and )
000019C2                          1284  
000019C2  43F8 10B4               1285          LEA     IOOPSZ,A1           Read OP code size
000019C6  103C 0003               1286          MOVE.B  #$03,D0             Set size to 3
000019CA  0C38 00FF 100E          1287          CMP.B   #$FF,(IOSIZE)       Test if OP size exists
000019D0  6704                    1288          BEQ     *+6                 If OP size doesn't exist, skip the next line
000019D2  1038 100E               1289          MOVE.B  (IOSIZE),D0         If OP size exists, move it to D0
000019D6  C0FC 0003               1290          MULU.W  #$3,D0              Multiply size by 3 for correct offset
000019DA  D3C0                    1291          ADD.L   D0,A1               Add offset
000019DC  6100 FD1E               1292          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000019E0                          1293          
000019E0  D401                    1294          ADD.B   D1,D2               Add length to space offset
000019E2  4442                    1295          NEG.W   D2                  Negate space offset
000019E4  0642 000B               1296          ADD.W   #11,D2              Add 11 to space offset; effectively 11 - space offset
000019E8                          1297  
000019E8  6100 FD4C               1298          BSR     DSPOFS              Display space offset with tab
000019EC                          1299  
000019EC  54B8 1010               1300          ADD.L   #2,(IOADDR)         Move memory location past first word
000019F0                          1301  
000019F0  4204                    1302          CLR.B   D4                  Set source to false
000019F2  4242                    1303          CLR.W   D2
000019F4  4243                    1304          CLR.W   D3
000019F6  1438 10C2               1305          MOVE.B  (SMD),D2            Read source mode to D2
000019FA  B43C 00FF               1306          CMP.B   #$FF,D2             Test if it exists
000019FE  6700 0016               1307          BEQ     NOSRC               If it does not exist, do not display source
00001A02  1638 10C3               1308          MOVE.B  (SRG),D3            Read source reg to D3
00001A06  B63C 00FF               1309          CMP.B   #$FF,D3             Test if it exists
00001A0A  6700 000A               1310          BEQ     NOSRC               If it does not exist, do not display source
00001A0E  6100 FD4A               1311          BSR     DISPOP              If both mode & register exist, display accordingly
00001A12  183C 0001               1312          MOVE.B  #1,D4               Set source to true
00001A16                          1313  
00001A16  4242                    1314  NOSRC   CLR.W   D2
00001A18  4243                    1315          CLR.W   D3
00001A1A  1438 10C0               1316          MOVE.B  (DMD),D2            Read dest mode to D2
00001A1E  B43C 00FF               1317          CMP.B   #$FF,D2             Test if it exists
00001A22  6700 0024               1318          BEQ     NODST               If it does not exist, do not display dest
00001A26  1638 10C1               1319          MOVE.B  (DRG),D3            Read dest reg to D3
00001A2A  B63C 00FF               1320          CMP.B   #$FF,D3             Test if it exists
00001A2E  6700 0018               1321          BEQ     NODST               If it does not exist, do not display dest
00001A32                          1322  
00001A32  103C 0006               1323          MOVE.B  #6,D0               Display character
00001A36  123C 002C               1324          MOVE.B  #',',D1             Read comma
00001A3A  B83C 0001               1325          CMP.B   #1,D4               Test if source was displayed
00001A3E  6600 0000               1326          BNE     *+2                 If it was not displayed, don't display a comma
00001A42  4E4F                    1327          TRAP    #15                 If it was displayed, display a comma
00001A44                          1328  
00001A44  6100 FD14               1329          BSR     DISPOP              If both mode & register exist, display accordingly
00001A48                          1330  
00001A48  103C 0006               1331  NODST   MOVE.B  #6,D0               Display character
00001A4C  123C 0009               1332          MOVE.B  #TB,D1              Read tab
00001A50  4E4F                    1333          TRAP    #15
00001A52                          1334  
00001A52  123C 000D               1335          MOVE.B  #CR,D1
00001A56  4E4F                    1336          TRAP    #15
00001A58  123C 000A               1337          MOVE.B  #LF,D1
00001A5C  4E4F                    1338          TRAP    #15
00001A5E                          1339  
00001A5E                          1340          *DISPLAY IO OPERAND
00001A5E                          1341          
00001A5E  2078 1000               1342          MOVE.L  GBUFF,A0            Set A0 to ELOC location
00001A62  B1F8 1008               1343          CMPA.L  ELOC,A0             Compare next buffer to ending location
00001A66  6C00 0082               1344          BGE     DONE                Branch to DONE if >= ending location
00001A6A                          1345  
00001A6A  5238 1014               1346          ADD.B   #1,IOLC
00001A6E  0C38 001E 1014          1347          CMP.B   #30,IOLC            Compare #30 to line counter
00001A74  6700 0034               1348          BEQ     PAUSE               If ==, branch to PAUSE
00001A78                          1349  
00001A78                          1350          * Reset IO instruction values
00001A78  11FC 00FF 10C2          1351          MOVE.B  #$FF,(SMD)
00001A7E  11FC 00FF 10C3          1352          MOVE.B  #$FF,(SRG)
00001A84  11FC 00FF 10C0          1353          MOVE.B  #$FF,(DMD)
00001A8A  11FC 00FF 10C1          1354          MOVE.B  #$FF,(DRG)
00001A90  11FC 00FF 100C          1355          MOVE.B  #$FF,(IOOPCD)
00001A96  11FC 00FF 100D          1356          MOVE.B  #$FF,(IOBDCD)
00001A9C  11FC 00FF 100E          1357          MOVE.B  #$FF,(IOSIZE)
00001AA2  54B8 1000               1358          ADD.L   #$2,(GBUFF)     Advance buffer
00001AA6                          1359  
00001AA6  6000 006A               1360          BRA     OP                  Branch to OP for next instruction
00001AAA                          1361  
00001AAA  43F8 135E               1362  PAUSE   LEA     MSSG4,A1            Display keypress prompt
00001AAE  103C 000E               1363          MOVE.B  #14,D0
00001AB2  4E4F                    1364          TRAP    #15
00001AB4  103C 000C               1365          MOVE.B  #12,D0              Hide keyboard input
00001AB8  123C 0000               1366          MOVE.B  #0,D1
00001ABC  4E4F                    1367          TRAP    #15
00001ABE  103C 0005               1368          MOVE.B  #5,D0               Request keyboard input
00001AC2  4E4F                    1369          TRAP    #15
00001AC4                          1370  *----TODO----*
00001AC4                          1371  * Test if keycode was for ENTER
00001AC4  103C 000C               1372          MOVE.B  #12,D0              Show keyboard input
00001AC8  123C 0001               1373          MOVE.B  #1,D1
00001ACC  4E4F                    1374          TRAP    #15
00001ACE  103C 000B               1375  DSPHDR  MOVE.B  #11,D0              Clear the screen
00001AD2  323C FF00               1376          MOVE.W  #$FF00,D1
00001AD6  4E4F                    1377          TRAP    #15
00001AD8  43F8 13A8               1378          LEA     HEADR,A1            Display header
00001ADC  103C 000E               1379          MOVE.B  #14,D0
00001AE0  4E4F                    1380          TRAP    #15
00001AE2  4238 1014               1381          CLR.B   (IOLC)              Reset line counter
00001AE6  6000 002A               1382          BRA     OP
00001AEA                          1383  
00001AEA  43F8 137F               1384  DONE    LEA     MSSG5,A1            Display end message
00001AEE  103C 000E               1385          MOVE.B  #14,D0
00001AF2  4E4F                    1386          TRAP    #15
00001AF4  103C 0009               1387          MOVE.B  #9,D0
00001AF8  4E4F                    1388          TRAP    #15
00001AFA                          1389  
00001AFA                          1390  *--------------------
00001AFA                          1391  *   OP
00001AFA                          1392  *--------------------
00001AFA                          1393  
00001AFA                          1394  *
00001AFA                          1395  * Jump Mask: Use CMPMSK, and jumps to the OP branch if it returns true
00001AFA                          1396  * Input CMPMSK inputs, input A0 for OP branch
00001AFA                          1397  *
00001AFA                          1398  
00001AFA  6100 FA68               1399  JMPMSK  BSR     CMPMSK          Branch to CMPMSK
00001AFE  6610                    1400          BNE.S   *+18            If the bits did not match, return to caller
00001B00  4E90                    1401          JSR     (A0)            If the bits matched, branch to the OP address
00001B02  660A                    1402          BNE     *+12            If the OP address was read ybsuccessful, skip the next two lines
00001B04  21C9 1000               1403          MOVE.L  A1,GBUFF        The buffer was good, move it to GBUFF
00001B08  6000 FE50               1404          BRA     PRINT           Branch to PRINT     
00001B0C  2278 1000               1405          MOVE.L  GBUFF,A1        The buffer was bad, restore A1
00001B10  4E75                    1406          RTS                     Return to caller for next instruction
00001B12                          1407  
00001B12  2078 1000               1408  OP      MOVE.L  GBUFF,A0        Set A0 to GBUFF location
00001B16  2278 1000               1409          MOVE.L  GBUFF,A1        Set A1 to GBUFF location for sub-routines
00001B1A  143C 0000               1410          MOVE.B  #0,D2           Set NULL count to 0
00001B1E  0C90 FFFFFFFF           1411          CMP.L   #$FFFFFFFF,(A0) Check for NULL
00001B24  67C4                    1412          BEQ     DONE            If NULL, branch to DONE
00001B26  3018                    1413          MOVE.W  (A0)+,D0        Transfer word data to D0, post-increment location
00001B28  3210                    1414          MOVE.W  (A0),D1         Transfer next word data to D1
00001B2A  21F8 1000 1010          1415          MOVE.L   GBUFF,IOADDR   Set memory location for IO
00001B30                          1416  *-----
00001B30                          1417  * 0000
00001B30                          1418  *-----
00001B30                          1419          * ORI:    00000000XXXXXXXX
00001B30  343C 0000               1420          MOVE.W  #%0000000000000000,D2
00001B34  363C FF00               1421          MOVE.W  #%1111111100000000,D3
00001B38  207C 000020F8           1422          MOVE.L  #BRORI,A0
00001B3E  61BA                    1423          BSR     JMPMSK
00001B40                          1424  
00001B40                          1425          * SUBI:   00000100XXXXXXXX
00001B40  343C 0400               1426          MOVE.W  #%0000010000000000,D2
00001B44  363C FB00               1427          MOVE.W  #%1111101100000000,D3
00001B48  207C 0000212A           1428          MOVE.L  #BRSUBI,A0
00001B4E  61AA                    1429          BSR     JMPMSK
00001B50                          1430  
00001B50                          1431          * ADDI:   00000110XXXXXXXX
00001B50  343C 0600               1432          MOVE.W  #%0000011000000000,D2
00001B54  363C F900               1433          MOVE.W  #%1111100100000000,D3
00001B58  207C 00001F42           1434          MOVE.L  #BRADDI,A0
00001B5E  619A                    1435          BSR     JMPMSK
00001B60                          1436  
00001B60                          1437          * BTST:   0000100000XXXXXX
00001B60  343C 0800               1438          MOVE.W  #%0000100000000000,D2
00001B64  363C F7C0               1439          MOVE.W  #%1111011111000000,D3
00001B68  207C 00001F56           1440          MOVE.L  #BRBTST,A0
00001B6E  618A                    1441          BSR     JMPMSK
00001B70                          1442  
00001B70                          1443          * EORI:   00001010XXXXXXXX
00001B70  343C 0A00               1444          MOVE.W  #%0000101000000000,D2
00001B74  363C F500               1445          MOVE.W  #%1111010100000000,D3
00001B78  207C 00002102           1446          MOVE.L  #BREORI,A0
00001B7E  6100 FF7A               1447          BSR     JMPMSK
00001B82                          1448  
00001B82                          1449          * CMPI:   00001100XXXXXXXX
00001B82  343C 0C00               1450          MOVE.W  #%0000110000000000,D2
00001B86  363C F300               1451          MOVE.W  #%1111001100000000,D3
00001B8A  207C 00001FA6           1452          MOVE.L  #BRCMPI,A0
00001B90  6100 FF68               1453          BSR     JMPMSK
00001B94                          1454  *-----
00001B94                          1455  * 0001
00001B94                          1456  *-----
00001B94                          1457          * MOVE.B: 0001XXXXXXXXXXXX
00001B94  343C 1000               1458          MOVE.W  #%0001000000000000,D2
00001B98  363C E000               1459          MOVE.W  #%1110000000000000,D3
00001B9C  207C 0000202C           1460          MOVE.L  #BRMOVE,A0
00001BA2  6100 FF56               1461          BSR     JMPMSK
00001BA6                          1462  *-----
00001BA6                          1463  * 0010
00001BA6                          1464  *-----
00001BA6                          1465          * MOVE.L: 0010XXXXXXXXXXXX
00001BA6  343C 2000               1466          MOVE.W  #%0010000000000000,D2
00001BAA  363C D000               1467          MOVE.W  #%1101000000000000,D3
00001BAE  6100 FF4A               1468          BSR     JMPMSK
00001BB2                          1469  *-----
00001BB2                          1470  * 0011
00001BB2                          1471  *-----
00001BB2                          1472          * MOVE.W: 0011XXXXXXXXXXXX 
00001BB2  343C 3000               1473          MOVE.W  #%0011000000000000,D2
00001BB6  363C C000               1474          MOVE.W  #%1100000000000000,D3
00001BBA  6100 FF3E               1475          BSR     JMPMSK
00001BBE                          1476  *-----
00001BBE                          1477  * 0100
00001BBE                          1478  *-----
00001BBE                          1479          * NOT:    01000110XXXXXXXX
00001BBE  343C 4600               1480          MOVE.W  #%0100011000000000,D2
00001BC2  363C B900               1481          MOVE.W  #%1011100100000000,D3
00001BC6  207C 0000210C           1482          MOVE.L  #BRNOT,A0
00001BCC  6100 FF2C               1483          BSR     JMPMSK
00001BD0                          1484  
00001BD0                          1485          * MULU:   0100110000XXXXXX
00001BD0  343C 4C00               1486          MOVE.W  #%0100110000000000,D2
00001BD4  363C B3C0               1487          MOVE.W  #%1011001111000000,D3
00001BD8  207C 000020DA           1488          MOVE.L  #BRMULU,A0
00001BDE  6100 FF1A               1489          BSR     JMPMSK
00001BE2                          1490  
00001BE2                          1491          * DIVS:   0100110001XXXXXX
00001BE2  343C 4C40               1492          MOVE.W  #%0100110001000000,D2
00001BE6  363C B380               1493          MOVE.W  #%1011001110000000,D3
00001BEA  207C 000020E4           1494          MOVE.L  #BRDIVS,A0
00001BF0  6100 FF08               1495          BSR     JMPMSK
00001BF4                          1496  
00001BF4                          1497          * MOVEM:  01001X001XXXXXXX
00001BF4  343C 4880               1498          MOVE.W  #%0100100010000000,D2
00001BF8  363C B300               1499          MOVE.W  #%1011001100000000,D3
00001BFC  207C 000020BE           1500          MOVE.L  #BRMOVEM,A0
00001C02  6100 FEF6               1501          BSR     JMPMSK
00001C06                          1502  
00001C06                          1503          * RTS:    0100111001110101
00001C06  343C 4E75               1504          MOVE.W  #%0100111001110101,D2
00001C0A  363C B18A               1505          MOVE.W  #%1011000110001010,D3
00001C0E  207C 00001FFE           1506          MOVE.L  #BRRTS,A0
00001C14  6100 FEE4               1507          BSR     JMPMSK
00001C18                          1508  
00001C18                          1509          * JSR:    0100111010XXXXXX
00001C18  343C 4E80               1510          MOVE.W  #%0100111010000000,D2
00001C1C  363C B140               1511          MOVE.W  #%1011000101000000,D3
00001C20  207C 00002022           1512          MOVE.L  #BRJSR,A0
00001C26  6100 FED2               1513          BSR     JMPMSK
00001C2A                          1514  
00001C2A                          1515          * LEA:    0100XXX111XXXXXX
00001C2A  343C 41C0               1516          MOVE.W  #%0100000111000000,D2
00001C2E  363C B000               1517          MOVE.W  #%1011000000000000,D3
00001C32  207C 00002008           1518          MOVE.L  #BRLEA,A0
00001C38  6100 FEC0               1519          BSR     JMPMSK
00001C3C                          1520  *-----
00001C3C                          1521  * 0101
00001C3C                          1522  *-----
00001C3C                          1523          * ADDQ:   0101XXX0XXXXXXXX
00001C3C  343C 5000               1524          MOVE.W  #%0101000000000000,D2
00001C40  363C A100               1525          MOVE.W  #%1010000100000000,D3
00001C44  207C 00001F38           1526          MOVE.L  #BRADDQ,A0
00001C4A  6100 FEAE               1527          BSR     JMPMSK
00001C4E                          1528  *-----
00001C4E                          1529  * 0110
00001C4E                          1530  *-----
00001C4E                          1531          * BCC:    01100000XXXXXXXX
00001C4E  343C 6000               1532          MOVE.W  #%0110000000000000,D2
00001C52  363C 9F00               1533          MOVE.W  #%1001111100000000,D3
00001C56  207C 00001F60           1534          MOVE.L  #BRBCC,A0
00001C5C  6100 FE9C               1535          BSR     JMPMSK
00001C60                          1536  *-----
00001C60                          1537  * 0111
00001C60                          1538  *-----
00001C60                          1539          * MOVEQ:  0111XXX0XXXXXXXX
00001C60  343C 7000               1540          MOVE.W  #%0111000000000000,D2
00001C64  363C 8100               1541          MOVE.W  #%1000000100000000,D3
00001C68  207C 000020C8           1542          MOVE.L  #BRMOVEQ,A0
00001C6E  6100 FE8A               1543          BSR     JMPMSK
00001C72                          1544  *-----
00001C72                          1545  * 1000
00001C72                          1546  *-----
00001C72                          1547          * DIVS:   1000XXX111XXXXXX
00001C72  343C 81C0               1548          MOVE.W  #%1000000111000000,D2
00001C76  363C 7000               1549          MOVE.W  #%0111000000000000,D3
00001C7A  207C 000020E4           1550          MOVE.L  #BRDIVS,A0
00001C80  6100 FE78               1551          BSR     JMPMSK
00001C84                          1552  *-----
00001C84                          1553  * 1001
00001C84                          1554  *-----
00001C84                          1555          * SUB:    1001XXXXXXXXXXXX
00001C84  343C 9000               1556          MOVE.W  #%1001000000000000,D2
00001C88  363C 6000               1557          MOVE.W  #%0110000000000000,D3
00001C8C  207C 00002116           1558          MOVE.L  #BRSUB,A0
00001C92  6100 FE66               1559          BSR     JMPMSK
00001C96                          1560  *-----
00001C96                          1561  * 1010
00001C96                          1562  *-----
00001C96                          1563  *-----
00001C96                          1564  * 1011
00001C96                          1565  *-----
00001C96                          1566          * CMP:    1011XXXXXXXXXXXX
00001C96  343C B000               1567          MOVE.W  #%1011000000000000,D2
00001C9A  363C 4000               1568          MOVE.W  #%0100000000000000,D3
00001C9E  207C 00001F92           1569          MOVE.L  #BRCMP,A0
00001CA4  6100 FE54               1570          BSR     JMPMSK
00001CA8                          1571  
00001CA8                          1572          * EOR:    1011XXXXXXXXXXXX
00001CA8  207C 000020EE           1573          MOVE.L  #BREOR,A0
00001CAE  6100 FE4A               1574          BSR     JMPMSK
00001CB2                          1575  *-----
00001CB2                          1576  * 1100
00001CB2                          1577  *-----
00001CB2                          1578          * AND:    1100XXXXXXXXXXXX
00001CB2  343C C000               1579          MOVE.W  #%1100000000000000,D2
00001CB6  363C 3000               1580          MOVE.W  #%0011000000000000,D3
00001CBA  207C 00001F4C           1581          MOVE.L  #BRAND,A0
00001CC0  6100 FE38               1582          BSR     JMPMSK
00001CC4                          1583  
00001CC4                          1584          * MULU:   1100XXX011XXXXXX
00001CC4  343C C0C0               1585          MOVE.W  #%1100000011000000,D2
00001CC8  363C 3100               1586          MOVE.W  #%0011000100000000,D3
00001CCC  207C 000020DA           1587          MOVE.L  #BRMULU,A0
00001CD2  6100 FE26               1588          BSR     JMPMSK
00001CD6                          1589  *-----
00001CD6                          1590  * 1101
00001CD6                          1591  *-----
00001CD6                          1592          * ADD:    1101XXXXXXXXXXXX
00001CD6  343C D000               1593          MOVE.W  #%1101000000000000,D2
00001CDA  363C 2000               1594          MOVE.W  #%0010000000000000,D3
00001CDE  207C 00001EF2           1595          MOVE.L  #BRADD,A0
00001CE4  6100 FE14               1596          BSR     JMPMSK
00001CE8                          1597  *-----
00001CE8                          1598  * 1110
00001CE8                          1599  *-----
00001CE8                          1600          * ASL/ASR:1110XXXXXXX00XXX
00001CE8  343C E000               1601          MOVE.W  #%1110000000000000,D2
00001CEC  363C 1018               1602          MOVE.W  #%0001000000011000,D3
00001CF0  207C 000020D2           1603          MOVE.L  #BRASd,A0
00001CF6  6100 FE02               1604          BSR     JMPMSK
00001CFA                          1605  
00001CFA                          1606          * LSL/LSR:1110XXXXXXX01XXX
00001CFA  343C E008               1607          MOVE.W  #%1110000000001000,D2
00001CFE  363C 1010               1608          MOVE.W  #%0001000000010000,D3
00001D02  207C 000020D6           1609          MOVE.L  #BRLSd,A0
00001D08  6100 FDF0               1610          BSR     JMPMSK
00001D0C                          1611  
00001D0C                          1612          * ASL/ASR:1110000X11XXXXXX
00001D0C  343C E0C0               1613          MOVE.W  #%1110000011000000,D2
00001D10  363C 1E00               1614          MOVE.W  #%0001111000000000,D3
00001D14  207C 000020D2           1615          MOVE.L  #BRASd,A0
00001D1A  6100 FDDE               1616          BSR     JMPMSK
00001D1E                          1617  
00001D1E                          1618          * LSL/LSR:1110001X11XXXXXX
00001D1E  343C E2C0               1619          MOVE.W  #%1110001011000000,D2
00001D22  363C 1C00               1620          MOVE.W  #%0001110000000000,D3
00001D26  207C 000020D6           1621          MOVE.L  #BRLSd,A0
00001D2C  6100 FDCC               1622          BSR     JMPMSK
00001D30                          1623  *-----
00001D30                          1624  * 1111
00001D30                          1625  *-----     
00001D30  6000 FBFE               1626          BRA     BRBAD           No mask matched, branch to BRBAD
00001D34                          1627  
00001D34                          1628  *--------------------------
00001D34                          1629  *  Instruction Subroutines
00001D34                          1630  *--------------------------
00001D34                          1631  
00001D34                          1632  *
00001D34                          1633  * Test Addressing Modes: Tests last register and mode for valid addressing modes
00001D34                          1634  * Input valid modes in D0.W, output found addressing mode to D1.B, or FF if not found
00001D34                          1635  * Set Z-flag if mode was valid, or clear Z-flag if mode was invalid
00001D34                          1636  *
00001D34                          1637  * D0.W addressing modes (set to 0 for invalid, 1 for valid):
00001D34                          1638  *   0   Dn
00001D34                          1639  *   1   An
00001D34                          1640  *   2   (An)
00001D34                          1641  *   3   (An)+
00001D34                          1642  *   4   -(An)
00001D34                          1643  *   5   (d,An)
00001D34                          1644  *   6   (d,An,Xn)
00001D34                          1645  *   7   (xxx).W
00001D34                          1646  *   8   (xxx).L
00001D34                          1647  *   9   (d,PC)
00001D34                          1648  *   A   (d,PC,Xn)
00001D34                          1649  *   B   #<data>
00001D34                          1650  *
00001D34                          1651  * Modes         %XXXXBA9876543210
00001D34  =00000FFF               1652  M_ALL   EQU     %0000111111111111   All modes
00001D34  =00000FFD               1653  M_DAT   EQU     %0000111111111101   Data modes
00001D34  =00000FFC               1654  M_MEM   EQU     %0000111111111100   Memory modes
00001D34  =000007E4               1655  M_CTR   EQU     %0000011111100100   Control modes
00001D34  =0000007F               1656  M_ALT   EQU     %0000000001111111   Alterable modes
00001D34  =000001FC               1657  M_MALT  EQU     %0000000111111100   Memory alterable modes
00001D34  =000001FD               1658  M_DALT  EQU     %0000000111111101   Data alterable modes
00001D34                          1659  
00001D34  1F02                    1660  TSTAM   MOVE.B  D2,-(SP)        Push D2 to stack
00001D36  4281                    1661          CLR.L   D1
00001D38  1238 10C4               1662          MOVE.B  (RGMD),D1       Move REGMOD to D1
00001D3C  1401                    1663          MOVE.B  D1,D2           Copy REGMOD to D2
00001D3E  EB09                    1664          LSL.B   #5,D1
00001D40  EA09                    1665          LSR.B   #5,D1           D1 = Mode
00001D42  E60A                    1666          LSR.B   #3,D2           D2 = Register
00001D44  B23C 0007               1667          CMP.B   #%111,D1        Test mode to 111
00001D48  6602                    1668          BNE     *+4             If !=, skip next line
00001D4A  D202                    1669          ADD.B   D2,D1           Add register to mode-- effectively creating a 4 bit mode
00001D4C  0300                    1670          BTST    D1,D0           Test mode for validity
00001D4E  6706                    1671          BEQ     *+8             If it is invalid, skip to clear flag
00001D50  141F                    1672          MOVE.B  (SP)+,D2        If it is valid, restore D2
00001D52  6000 F6CE               1673          BRA     FLAGST          Set flag & return to caller
00001D56  141F                    1674          MOVE.B  (SP)+,D2        Restore D2
00001D58  6000 F6CE               1675          BRA     FLAGCL          Clear flag & return to caller
00001D5C                          1676  
00001D5C                          1677  *
00001D5C                          1678  * Advance Buffer: Advances buffer based on last register and mode
00001D5C                          1679  * Input buffer in A1, reg & mode in RGMD, output displacement to DIS
00001D5C                          1680  *
00001D5C                          1681  
00001D5C  48E7 6000               1682  ADVBFR  MOVEM.L D1/D2,-(SP)     Push D1 & D2 to the stack
00001D60  11FC 00FF 10C5          1683          MOVE.B  #$FF,(DIS)      Set displacement to NULL
00001D66  1238 10C4               1684          MOVE.B  (RGMD),D1       Move Reg & Mod to D1
00001D6A  2409                    1685          MOVE.L  A1,D2           Copy buffer to D2
00001D6C  B23C 0007               1686          CMP.B   #$07,D1         Test 000 111 = Address (Word)
00001D70  6602                    1687          BNE.S   *+4             Skip next line
00001D72  5489                    1688          ADD.L   #$2,A1          Advance buffer by word
00001D74  B23C 000F               1689          CMP.B   #$0F,D1         Test 001 111 = Address (Long)
00001D78  6602                    1690          BNE.S   *+4             Skip next line
00001D7A  5889                    1691          ADD.L   #$4,A1          Advance buffer by long
00001D7C  B23C 0027               1692          CMP.B   #$27,D1         Test 100 111 = Immediate (OP code size)
00001D80  6700 0010               1693          BEQ     ADVBSZ          If ==, branch to Advance Buffer by Size
00001D84  4482                    1694          NEG.L   D2              Else, negate original buffer
00001D86  D489                    1695          ADD.L   A1,D2           Add buffer to get difference
00001D88  11C2 10C5               1696          MOVE.B  D2,(DIS)        Store displacement in DIS
00001D8C  4CDF 0006               1697          MOVEM.L (SP)+,D1/D2     Restore D1 & D2
00001D90  4E75                    1698          RTS                     Return to caller
00001D92                          1699  
00001D92                          1700  *
00001D92                          1701  * Advance Buffer by Size: Advances buffer based on instruction size
00001D92                          1702  * Input buffer in A1, input size from (IOSIZE), output displacement to DIS
00001D92                          1703  *
00001D92                          1704  
00001D92  0C38 00FF 10C5          1705  ADVBSZ  CMP.B   #$FF,(DIS)      Check if DIS is NULL (255 is odd so displacement should never be FF)
00001D98  6704                    1706          BEQ     *+6             If it is null, values have already been pushed to the stack, skip the next line
00001D9A  48E7 6000               1707          MOVEM.L D1/D2,-(SP)     Else, push D1 & D2 to the stack
00001D9E  1238 100E               1708          MOVE.B  (IOSIZE),D1     Read size to D1
00001DA2  2409                    1709          MOVE.L  A1,D2           Copy buffer to D2
00001DA4  B03C 0001               1710          CMP.B   #$1,D0          Test 0 = Byte
00001DA8  6602                    1711          BNE.S   *+4             Skip next line
00001DAA  5489                    1712          ADD.L   #$2,A1          Advance buffer by word (00BB)
00001DAC  B23C 0001               1713          CMP.B   #$1,D1          Test 1 = Word
00001DB0  6602                    1714          BNE.S   *+4             Skip next line
00001DB2  5489                    1715          ADD.L   #$2,A1          Advance buffer by word        
00001DB4  B23C 0002               1716          CMP.B   #$2,D1          Test 2 = Long
00001DB8  6602                    1717          BNE.S   *+4             Skip next line
00001DBA  5889                    1718          ADD.L   #$4,A1          Advance buffer by long
00001DBC  4442                    1719          NEG     D2              Negate original buffer
00001DBE  D489                    1720          ADD.L   A1,D2           Add buffer to get difference
00001DC0  11C2 10C5               1721          MOVE.B  D2,(DIS)        Store displacement in DIS
00001DC4  4CDF 0006               1722          MOVEM.L (SP)+,D2/D1     Restore D1 and D2
00001DC8  4E75                    1723          RTS                     Return to caller
00001DCA                          1724  
00001DCA                          1725  *
00001DCA                          1726  * OP Size: Test the standard OP size code
00001DCA                          1727  * Inputs size from (DMD), outputs size to IOSIZE, operation to D2.B, correct mode to DMD
00001DCA                          1728  * OPM (OP-MODE):  Byte | Word | Long | Operation | D2.B
00001DCA                          1729  *                  000 |  001 |  010 |   <ea>,Dn |    0
00001DCA                          1730  *                  100 |  101 |  110 |   Dn,<ea> |    1
00001DCA                          1731  *                         011 |  111 |   <ea>,An |    2
00001DCA                          1732  *
00001DCA                          1733  
00001DCA  48E7 C000               1734  OPSIZE  MOVEM.L D0/D1,-(SP)     Push D0 & D1 to stack
00001DCE  4241                    1735          CLR.W   D1              Ensure displacement will be <= 7
00001DD0  1238 10C0               1736          MOVE.B  (DMD),D1        Get destination mode in D1
00001DD4  C2FC 0004               1737          MULU.W  #4,D1           Convert to displacement
00001DD8  4EFB 1002               1738          JMP     OPTBL(PC,D1.W)  Jump to OP mode
00001DDC  6000 001E               1739  OPTBL   BRA     OP0             000
00001DE0  6000 002C               1740          BRA     OP1             001
00001DE4  6000 003A               1741          BRA     OP2             010
00001DE8  6000 0048               1742          BRA     OP3             011
00001DEC  6000 0056               1743          BRA     OP4             100
00001DF0  6000 0064               1744          BRA     OP5             101
00001DF4  6000 0072               1745          BRA     OP6             110
00001DF8  6000 0080               1746          BRA     OP7             111
00001DFC  143C 0000               1747  OP0     MOVE.B  #0,D2           Set OP to 0 for Dn
00001E00  11FC 0000 10C0          1748          MOVE.B  #0,(DMD)        Set mode to Dn
00001E06  103C 0000               1749          MOVE.B  #0,D0           Set size to byte
00001E0A  6000 0080               1750          BRA     OP8             Branch to end
00001E0E  143C 0000               1751  OP1     MOVE.B  #0,D2           Set OP to 0 for Dn
00001E12  11FC 0000 10C0          1752          MOVE.B  #0,(DMD)        Set mode to Dn
00001E18  103C 0001               1753          MOVE.B  #1,D0           Set size to word
00001E1C  6000 006E               1754          BRA     OP8             Branch to end
00001E20  143C 0000               1755  OP2     MOVE.B  #0,D2           Set OP to 0 for Dn
00001E24  11FC 0000 10C0          1756          MOVE.B  #0,(DMD)        Set mode to Dn
00001E2A  103C 0002               1757          MOVE.B  #2,D0           Set size to long
00001E2E  6000 005C               1758          BRA     OP8             Branch to end
00001E32  143C 0002               1759  OP3     MOVE.B  #2,D2           Set OP to 2 for An
00001E36  11FC 0001 10C0          1760          MOVE.B  #1,(DMD)        Set mode to An
00001E3C  103C 0001               1761          MOVE.B  #1,D0           Set size to word
00001E40  6000 004A               1762          BRA     OP8             Branch to end
00001E44  143C 0001               1763  OP4     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E48  11FC 0000 10C0          1764          MOVE.B  #0,(DMD)        Set mode to Dn
00001E4E  103C 0000               1765          MOVE.B  #0,D0           Set size to byte
00001E52  6000 0038               1766          BRA     OP8             Branch to end
00001E56  143C 0001               1767  OP5     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E5A  11FC 0000 10C0          1768          MOVE.B  #0,(DMD)        Set mode to Dn
00001E60  103C 0001               1769          MOVE.B  #1,D0           Set size to word
00001E64  6000 0026               1770          BRA     OP8             Branch to end
00001E68  143C 0001               1771  OP6     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E6C  11FC 0000 10C0          1772          MOVE.B  #0,(DMD)        Set mode to Dn
00001E72  103C 0002               1773          MOVE.B  #2,D0           Set size to long
00001E76  6000 0014               1774          BRA     OP8             Branch to end
00001E7A  143C 0002               1775  OP7     MOVE.B  #2,D2           Set OP to 2 for An
00001E7E  11FC 0001 10C0          1776          MOVE.B  #1,(DMD)        Set mode to An
00001E84  103C 0002               1777          MOVE.B  #2,D0           Set size to long
00001E88  6000 0002               1778          BRA     OP8             Branch to end
00001E8C  11C0 100E               1779  OP8     MOVE.B  D0,(IOSIZE)     Store size in IOSIZE
00001E90  4CDF 0003               1780          MOVEM.L (SP)+,D0/D1     Restore D0 & D1
00001E94  4E75                    1781          RTS                     Return to caller
00001E96                          1782  
00001E96                          1783  *
00001E96                          1784  * Extract destination: Extracts destination mode to DMD and destination register to DRG from instruction
00001E96                          1785  * Input instruction from A1, output a combination of reg & mode in RGMD
00001E96                          1786  *
00001E96                          1787  
00001E96  48E7 E000               1788  EXDST   MOVEM.L D0-D2,-(SP)     Push D0 - D2 to stack
00001E9A  3011                    1789          MOVE.W  (A1),D0         Move instruction to D0
00001E9C  243C 000001C0           1790          MOVE.L  #$1C0,D2        Extract dest mode at 0000000111000000
00001EA2  6100 F6EE               1791          BSR     EXTMSK          Get dest mode to D1
00001EA6  11C1 10C0               1792          MOVE.B  D1,(DMD)        Move dest mode to DMD
00001EAA  243C 00000E00           1793          MOVE.L  #$E00,D2        Extract dest reg at 0000111000000000
00001EB0  6100 F6E0               1794          BSR     EXTMSK          Get dest reg to D1
00001EB4  11C1 10C1               1795          MOVE.B  D1,(DRG)        Move dest reg to (DRG)
00001EB8                          1796  
00001EB8  E709                    1797          LSL.B   #3,D1           Shift the reg 3 bits left
00001EBA  8238 10C0               1798          OR.B    (DMD),D1        Add mode after reg
00001EBE  11C1 10C4               1799          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001EC2  4CDF 0007               1800          MOVEM.L (SP)+,D0-D2     Restore D0 - D2
00001EC6  4E75                    1801          RTS                     Return to caller
00001EC8                          1802  
00001EC8                          1803  *
00001EC8                          1804  * Extract source: Extracts source mode to SMD and source register to SRG from instruction
00001EC8                          1805  * Inputs instruction from GBUFF, output a combination of reg & mode in RGMD
00001EC8                          1806  *
00001EC8                          1807  
00001EC8  48E7 E000               1808  EXSRC   MOVEM.L D0-D2,-(SP)     Push D0 - D2 to stack
00001ECC  3011                    1809          MOVE.W  (A1),D0         Move instruction to D0
00001ECE  7438                    1810          MOVE.L  #$38,D2         Extract src mode at 0000000000111000
00001ED0  6100 F6C0               1811          BSR     EXTMSK          Get src mode to D1
00001ED4  11C1 10C2               1812          MOVE.B  D1,(SMD)        Move src mode to (OMD)
00001ED8  7407                    1813          MOVE.L  #$7,D2          Extract src reg at 0000000000000111
00001EDA  6100 F6B6               1814          BSR     EXTMSK          Get src reg to D1
00001EDE  11C1 10C3               1815          MOVE.B  D1,(SRG)        Move src reg to (ORG)
00001EE2  E709                    1816          LSL.B   #3,D1           Shift the reg 3 bits left
00001EE4  8238 10C2               1817          OR.B    (SMD),D1        Add mode after reg
00001EE8  11C1 10C4               1818          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001EEC  4CDF 0007               1819          MOVEM.L (SP)+,D0-D2     Restore D0 - D2
00001EF0  4E75                    1820          RTS                     Return to caller
00001EF2                          1821  
00001EF2                          1822  * ----------------
00001EF2                          1823  * OP Mode Branches
00001EF2                          1824  * ----------------
00001EF2                          1825  * A1 reserved for tentative good buffer
00001EF2                          1826  
00001EF2                          1827  
00001EF2                          1828  * ADD: 1101|REG|OPM|EMD|ERG
00001EF2                          1829  * Syntax: ADD       <ea>,Dn
00001EF2                          1830  *         ADD       Dn,<ea>
00001EF2                          1831  * Note: The Dn mode is used when the destination is a data register;
00001EF2                          1832  *       the destination <ea> mode is invalid for a data register. 
00001EF2                          1833  *       ADDA is used when the destination is an address register.
00001EF2                          1834  *       ADDI and ADDQ are used when the source is immediate data.
00001EF2                          1835  *       Most assemblers automatically make this distinction.  
00001EF2                          1836  
00001EF2  11FC 0011 100C          1837  BRADD   MOVE.B  #$11,(IOOPCD)   Set OP-code name
00001EF8  619C                    1838          BSR     EXDST           Extract OP mode & register
00001EFA  6100 FECE               1839          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00001EFE                          1840          * "If the location specified is a destination operand,
00001EFE                          1841          * only memory alterable addressing modes can be used [...]."
00001EFE  B43C 0000               1842          CMP.B   #0,D2           Compare operation to Dn
00001F02  6604                    1843          BNE.S   *+6             If !=, skip next line
00001F04  303C 01FC               1844          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00001F08                          1845          * "If the location specified is a source operand,
00001F08                          1846          * all addressing modes can be used [...]."
00001F08  B43C 0001               1847          CMP.B   #1,D2           Compare operation to <ea>
00001F0C  6604                    1848          BNE.S   *+6             If !=, skip next line
00001F0E  303C 0FFF               1849          MOVE.W  #M_ALL,D0       Set all modes as valid
00001F12                          1850          * "ADDA is used when the destination is an address register."
00001F12  B43C 0002               1851          CMP.B   #2,D2           Compare operation to An
00001F16  6700 000C               1852          BEQ     BRADDA          If ==, branch to BRADDA
00001F1A                          1853  
00001F1A  61AC                    1854          BSR     EXSRC           Extract EA mode & register
00001F1C                          1855          *BSR     TSTAM           Test modes for validity
00001F1C                          1856          *BNE     FLAGCL          If not valid, return unsuccessful
00001F1C  6100 FE3E               1857          BSR     ADVBFR          Else, advance the buffer accordingly
00001F20  6000 F500               1858          BRA     FLAGST          Return return successful
00001F24                          1859  
00001F24                          1860  
00001F24                          1861  * ADDA: 1101|REG|OPM|EMD|ERG
00001F24                          1862  * Syntax: ADDA      <ea>,An
00001F24                          1863  
00001F24  11FC 0015 100C          1864  BRADDA  MOVE.B  #$15,(IOOPCD)   Set OP-code name
00001F2A                          1865          * "All addressing modes can be used [...]."
00001F2A  303C 0FFF               1866          MOVE.W  #M_ALL,D0       Set all modes as valid
00001F2E  6198                    1867          BSR     EXSRC           Extract EA mode & register
00001F30                          1868          *BSR     TSTAM           Test modes for validity
00001F30                          1869          *BNE     FLAGCL          If not valid, return unsuccessful
00001F30  6100 FE2A               1870          BSR     ADVBFR          Else, advance the buffer accordingly
00001F34  6000 F4EC               1871          BRA     FLAGST          Return successful
00001F38                          1872  
00001F38                          1873  * ADDQ: 0101|DAT|0|SZ|EMD|ERG
00001F38                          1874  * Syntax: ADDQ      #<data>,<ea>
00001F38                          1875  
00001F38  11FC 001A 100C          1876  BRADDQ  MOVE.B  #$1A,(IOOPCD)   Set OP-code name
00001F3E  6000 F4E2               1877          BRA     FLAGST          Return successful
00001F42                          1878  
00001F42                          1879  * ADDI: 000000110|SZ|EMD|ERG
00001F42                          1880  * Syntax: ADDI      #<data>,<ea>
00001F42                          1881  
00001F42  11FC 0099 100C          1882  BRADDI  MOVE.B  #$99,(IOOPCD)   Set OP-code name
00001F48  6000 F4D8               1883          BRA     FLAGST          Return successful
00001F4C                          1884  
00001F4C                          1885  * AND: 1100|REG|OPM|EMD|ERG
00001F4C                          1886  * Syntax: AND       <ea>,Dn
00001F4C                          1887  *         AND       Dn,<ea>
00001F4C                          1888  * Note: The Dn mode is used when the destination is a data register;
00001F4C                          1889  *       the destination < ea > mode is invalid for a data register. 
00001F4C                          1890  *       Most assemblers use ANDI when the source is immediate data.
00001F4C                          1891  
00001F4C  11FC 003B 100C          1892  BRAND   MOVE.B  #$3B,(IOOPCD)   Set OP-code name
00001F52  6000 F4CE               1893          BRA     FLAGST          Return successful
00001F56                          1894  
00001F56                          1895  * BTST: 0000|REG|100|EMD|ERG (BIT NUMBER DYNAMIC, SPECIFIED IN A REGISTER)
00001F56                          1896  *       0000100000|EMD|ERG  00000000|_BITNUM_ (BIT NUMBER STATIC, SPECIFIED AS IMMEDIATE DATA)
00001F56                          1897  * Syntax: BTST      Dn,<ea>
00001F56                          1898  *         BTST      #<data>,<ea>
00001F56                          1899  
00001F56  11FC 0058 100C          1900  BRBTST  MOVE.B  #$58,(IOOPCD)   Set OP-code name
00001F5C  6000 F4C4               1901          BRA     FLAGST          Return successful
00001F60                          1902  
00001F60                          1903  * BCC: 0110|COND|_8BTDSP_
00001F60                          1904  * Syntax: BCC       <label>
00001F60                          1905  
00001F60  11FC 006B 100C          1906  BRBCC   MOVE.B  #$6B,(IOOPCD)   Set OP-code name
00001F66  6000 F4BA               1907          BRA     FLAGST          Return successful
00001F6A                          1908  
00001F6A  11FC 006F 100C          1909  BRBEQ   MOVE.B  #$6F,(IOOPCD)   Set OP-code name
00001F70  6000 F4B0               1910          BRA     FLAGST          Return successful
00001F74                          1911          
00001F74  11FC 0073 100C          1912  BRBLT   MOVE.B  #$73,(IOOPCD)   Set OP-code name
00001F7A  6000 F4A6               1913          BRA     FLAGST          Return successful
00001F7E                          1914  
00001F7E  11FC 0077 100C          1915  BRBNE   MOVE.B  #$77,(IOOPCD)   Set OP-code name
00001F84  6000 F49C               1916          BRA     FLAGST          Return successful
00001F88                          1917  
00001F88  11FC 007B 100C          1918  BRBHI   MOVE.B  #$7B,(IOOPCD)   Set OP-code name
00001F8E  6000 F492               1919          BRA     FLAGST          Return successful
00001F92                          1920  
00001F92                          1921  * CMP: 1011|REG|OPM|EMD|ERG
00001F92                          1922  * Syntax: CMP       <ea>,Dn
00001F92                          1923  * Note: CMPA is used when the destination is an address register.
00001F92                          1924  *       CMPI is used when the source is immediate data.
00001F92                          1925  *       CMPM is used for memory-to-memory compares.
00001F92                          1926  *       Most assemblers automatically make the distinction.
00001F92                          1927  
00001F92  11FC 005D 100C          1928  BRCMP   MOVE.B  #$5D,(IOOPCD)   Set OP-code name
00001F98  6000 F488               1929          BRA     FLAGST          Return successful
00001F9C                          1930  
00001F9C                          1931  * CMPA: 1011|REG|OPM|EMD|ERG
00001F9C                          1932  * Syntax: CMPA      <ea>,An       
00001F9C                          1933  
00001F9C  11FC 0061 100C          1934  BRCMPA  MOVE.B  #$61,(IOOPCD)   Set OP-code name
00001FA2  6000 F47E               1935          BRA     FLAGST          Return successful
00001FA6                          1936  
00001FA6                          1937  * CMPI: 00001100|SZ|EMD|ERG
00001FA6                          1938  * Syntax: CMPI      #<data>,<ea>
00001FA6                          1939  
00001FA6  11FC 0066 100C          1940  BRCMPI  MOVE.B  #$66,(IOOPCD)   Set OP-code name
00001FAC  3011                    1941          MOVE.W  (A1),D0         Move instruction to D0
00001FAE  243C 000000C0           1942          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00001FB4  6100 F5DC               1943          BSR     EXTMSK          Get the size to D1
00001FB8                          1944  
00001FB8  B23C 00FF               1945          CMP.B   #$FF,D1         Test if size was found
00001FBC  6700 F46A               1946          BEQ     FLAGCL          If it was not found, branch to clear flag      
00001FC0  11C1 100E               1947          MOVE.B  D1,(IOSIZE)     If it was found, store size in IOSIZE
00001FC4                          1948  
00001FC4                          1949          * Dest EA field: "Only data alterable addressing modes can be used [...]."
00001FC4  303C 01FD               1950          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00001FC8  6100 FEFE               1951          BSR     EXSRC           Extract source EA mode & register 
00001FCC  11F8 10C2 10C0          1952          MOVE.B  SMD,(DMD)       The EA mode is the Destination mode
00001FD2  11F8 10C3 10C1          1953          MOVE.B  SRG,(DRG)       The EA reg is the Destination reg
00001FD8  6100 FD82               1954          BSR     ADVBFR          Advance the buffer accordingly
00001FDC                          1955          * SUBI format is SUBI.(size)  #<data>, <ea>
00001FDC                          1956          * manually set the Source mode and source register
00001FDC  11FC 0007 10C2          1957          MOVE.B  #$07,(SMD)      Source Mode set to 111
00001FE2  11FC 0004 10C3          1958          MOVE.B  #$04,(SRG)      Register Mode set to 100 #<data>
00001FE8  1238 10C3               1959          MOVE.B  SRG,D1          Copy SRG to D1 to manipulate
00001FEC  E709                    1960          LSL.B   #3,D1           Shift the reg 3 bits left
00001FEE  8238 10C2               1961          OR.B    (SMD),D1        Add mode after reg
00001FF2  11C1 10C4               1962          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001FF6                          1963          
00001FF6  6100 FD64               1964          BSR     ADVBFR          Advance the buffer accordingly
00001FFA  6000 F426               1965          BRA     FLAGST          Return successful
00001FFE                          1966  
00001FFE                          1967  * RTS: 0100111001110101
00001FFE                          1968  * Syntax: RTS
00001FFE                          1969  
00001FFE  11FC 0083 100C          1970  BRRTS   MOVE.B  #$83,(IOOPCD)   Set OP-code name
00002004  6000 F41C               1971          BRA     FLAGST          Return successful
00002008                          1972  
00002008                          1973  * LEA: 0100|REG|111|EMD|ERG
00002008                          1974  * Syntax: LEA       <ea>,An
00002008                          1975  
00002008  11FC 0037 100C          1976  BRLEA   MOVE.B  #$37,(IOOPCD)   Set OP-code name
0000200E  6100 FE86               1977          BSR     EXDST           Extract destination mode & register
00002012  6100 FD48               1978          BSR     ADVBFR          Advance the buffer accordingly
00002016  6100 FEB0               1979          BSR     EXSRC           Extract source mode & register
0000201A  6100 FD40               1980          BSR     ADVBFR          Advance the buffer accordingly
0000201E  6000 F402               1981          BRA     FLAGST          Return successful
00002022                          1982  
00002022                          1983  * JSR: 0100111010|EMD|ERG
00002022                          1984  * Syntax: JSR       <ea>
00002022                          1985  
00002022  11FC 007F 100C          1986  BRJSR   MOVE.B  #$7F,(IOOPCD)   Set OP-code name
00002028  6000 F3F8               1987          BRA     FLAGST          Return successful
0000202C                          1988          
0000202C                          1989  * MOVE: 00|SZ|DRG|DMD|SMD|SRG
0000202C                          1990  * Syntax: MOVE      <ea>,<ea>
0000202C                          1991  * Note: Most assemblers use MOVEA when the destination is an address register. 
0000202C                          1992  *       MOVEQ can be used to move an immediate 8-bit value to a data register. 
0000202C                          1993  
0000202C  11FC 0000 100C          1994  BRMOVE  MOVE.B  #$00,(IOOPCD)   Set OP-code name
00002032  3011                    1995          MOVE.W  (A1),D0         Move instruction to D0
00002034  243C 00003000           1996          MOVE.L  #$3000,D2       Extract size at 0011000000000000
0000203A  6100 F556               1997          BSR     EXTMSK          Get the size to D1
0000203E                          1998  
0000203E  103C 00FF               1999          MOVE.B  #$FF,D0         Set size to null
00002042  B23C 0001               2000          CMP.B   #%01,D1         01 = Byte
00002046  6604                    2001          BNE.S   *+6             Branch to next test
00002048  103C 0000               2002          MOVE.B  #$0,D0          Set size to byte
0000204C  B23C 0003               2003          CMP.B   #%11,D1         11 = Word
00002050  6604                    2004          BNE.S   *+6             Branch to next test
00002052  103C 0001               2005          MOVE.B  #$1,D0          Set size to word
00002056  B23C 0002               2006          CMP.B   #%10,D1         10 = Long
0000205A  6604                    2007          BNE.S   *+6             Branch to next test
0000205C  103C 0002               2008          MOVE.B  #$2,D0          Set size to long
00002060  B03C 00FF               2009          CMP.B   #$FF,D0         Test if size was found
00002064  6700 F3C2               2010          BEQ     FLAGCL          If it was not found, branch to clear flag      
00002068  11C0 100E               2011          MOVE.B  D0,(IOSIZE)     If it was found, store size in IOSIZE
0000206C                          2012  
0000206C  6100 FE28               2013          BSR     EXDST           Extract dest EA mode & register
00002070  0C38 0001 10C0          2014          CMP.B   #1,(DMD)        Compare mode to An
00002076  6700 001A               2015          BEQ     BRMOVEA         If ==, branch to BRMOVEA
0000207A                          2016          * Dest EA field: "Only data alterable addressing modes can be used [...]."
0000207A  303C 01FD               2017          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
0000207E                          2018          *BSR     TSTAM           Test modes for validity
0000207E                          2019          *BNE     FLAGCL          If not valid, return unsuccessful
0000207E  6100 FCDC               2020          BSR     ADVBFR          Else, advance the buffer accordingly
00002082  6100 FE44               2021          BSR     EXSRC           Extract source EA mode & register
00002086                          2022          * Source EA field: "All addressing modes can be used [...]."
00002086  303C 0FFF               2023          MOVE.W  #M_ALL,D0       Set all modes as valid
0000208A                          2024          *BSR     TSTAM           Test modes for validity
0000208A                          2025          *BNE     FLAGCL          If not valid, return unsuccessful
0000208A  6100 FCD0               2026          BSR     ADVBFR          Else, advance the buffer accordingly
0000208E                          2027  
0000208E  6000 F392               2028          BRA     FLAGST          Return successful
00002092                          2029  
00002092                          2030  
00002092                          2031  * MOVEA: 00|SZ|DRG|001|SMD|SRG
00002092                          2032  * Syntax: MOVEA     <ea>,An
00002092                          2033  
00002092  11FC 0005 100C          2034  BRMOVEA MOVE.B  #$05,(IOOPCD)   Set Op-code name
00002098  0C38 0000 100E          2035          CMP.B   #0,(IOSIZE)     Compare size to byte
0000209E  6700 F388               2036          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
000020A2  6100 FCB8               2037          BSR     ADVBFR          Else, advance the buffer accordingly
000020A6  6100 FE20               2038          BSR     EXSRC           Extract source EA mode & register
000020AA                          2039          * Source EA field: "All addressing modes can be used [...]."
000020AA  303C 0FFF               2040          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
000020AE  6100 FC84               2041          BSR     TSTAM           Test modes for validity
000020B2  6600 F374               2042          BNE     FLAGCL          If not valid, return unsuccessful
000020B6  6100 FCA4               2043          BSR     ADVBFR          Advance the buffer accordingly
000020BA  6000 F366               2044          BRA     FLAGST          Return successful
000020BE                          2045  
000020BE                          2046  * MOVEM: 01001|D|001|S|EMD|ERG
000020BE                          2047  * Syntax: MOVEM     <list>,<ea>
000020BE                          2048  *         MOVEM     <ea>,<list>
000020BE                          2049  
000020BE  11FC 000B 100C          2050  BRMOVEM MOVE.B  #$0B,(IOOPCD)   Set OP-code name
000020C4  6000 F35C               2051          BRA     FLAGST          Return successful
000020C8                          2052  
000020C8                          2053  * MOVEQ: 0111|REG|0|__DATA__
000020C8                          2054  * Syntax: MOVEQ     #<data>,Dn
000020C8                          2055  
000020C8  11FC 008B 100C          2056  BRMOVEQ MOVE.B  #$8B,(IOOPCD)   Set OP-code name
000020CE  6600 F352               2057          BNE     FLAGST          Return unsuccessful
000020D2                          2058  
000020D2                          2059  * ASd: 1110000|d|11|EMD|ERG (memory shifts)
000020D2                          2060  *      1110|CRG|d|SZ|i|00|REG (register shifts)
000020D2                          2061  * Syntax: ASd       Dx,Dy
000020D2                          2062  *         ASd       #<data>,Dy
000020D2                          2063  *         ASd       <ea>
000020D2                          2064  
000020D2                          2065  BRASd   *MOVE.B  #$50,(IOOPCD)   ASL
000020D2                          2066          *MOVE.B  #$95,(IOOPCD)   ASR
000020D2  6000 F34E               2067          BRA     FLAGST          Return successful
000020D6                          2068  
000020D6                          2069  * LSd: 1110001|d|11|EMD|ERG (memory shifts)
000020D6                          2070  *      1110|CRG|d|SZ|i|01|REG (register shifts)
000020D6                          2071  * Syntax: LSd       Dx,Dy
000020D6                          2072  *         LSd       #<data>,Dy
000020D6                          2073  *         LSd       <ea>
000020D6                          2074  
000020D6                          2075  BRLSd   *MOVE.B  #$91,(IOOPCD)   LSL
000020D6                          2076          *MOVE.B  #$54,(IOOPCD)   LSR
000020D6  6000 F34A               2077          BRA     FLAGST          Return successful
000020DA                          2078  
000020DA                          2079  * MULU: 1100|REG|011|EMD|ERG (WORD)
000020DA                          2080  *       0100110000|EMD|ERG  0|RDI|0|SZ|0000000|RDH (LONG)
000020DA                          2081  * Syntax: MULU.W    <ea>,Dn    16x16 -> 32
000020DA                          2082  *         MULU.L    <ea>,Dl    32x32 -> 32
000020DA                          2083  *         MULU.L    <ea>,Dh?Dl 32x32 -> 64 
000020DA                          2084  
000020DA  11FC 002D 100C          2085  BRMULU  MOVE.B  #$2D,(IOOPCD)   Set OP-code name
000020E0  6000 F340               2086          BRA     FLAGST          Return successful
000020E4                          2087  
000020E4                          2088  * DIVS: 1000|REG|111|EMD|ERG (WORD)
000020E4                          2089  *       0100110001|EMD|ERG  0|RDQ|1|S|0000000|RDR (LONG)
000020E4                          2090  * Synax: DIVS.W     <ea>,Dn     32/16 -> 16r ? 16q
000020E4                          2091  *        DIVS.L     <ea>,Dq     32/32 -> 32q
000020E4                          2092  *        DIVS.L     <ea>,Dr:Dq  64/32 -> 32r ? 32q
000020E4                          2093  *        DIVSL.L    <ea>,Dr:Dq 32/32 -> 32r ? 32q
000020E4                          2094  
000020E4  11FC 0032 100C          2095  BRDIVS  MOVE.B  #$32,(IOOPCD)   Set OP-code name     
000020EA  6000 F336               2096          BRA     FLAGST          Return successful
000020EE                          2097  
000020EE                          2098  * EOR: 1011|REG|OPM|EMD|ERG
000020EE                          2099  * Syntax: EOR       Dn,<ea>
000020EE                          2100  * Note: Memory-to-data-register operations are not allowed.
000020EE                          2101  *       Most assemblers use EORI when the source is immediate data.
000020EE                          2102  
000020EE  11FC 0043 100C          2103  BREOR   MOVE.B  #$43,(IOOPCD)   Set OP-code name
000020F4  6000 F32C               2104          BRA     FLAGST          Return successful
000020F8                          2105  
000020F8                          2106  * ORI: 00000000|SZ|EMD|ERG
000020F8                          2107  * Syntax: ORI       #<data>,<ea>
000020F8                          2108  
000020F8  11FC 003F 100C          2109  BRORI   MOVE.B  #$3F,(IOOPCD)   Set OP-code name
000020FE  6000 F322               2110          BRA     FLAGST          Return successful
00002102                          2111  
00002102                          2112  * EORI: 00001010|SZ|EMD|ERG
00002102                          2113  * Syntax: EORI      #<data>,<ea>
00002102                          2114  
00002102  11FC 0047 100C          2115  BREORI  MOVE.B  #$47,(IOOPCD)   Set OP-code name
00002108  6000 F318               2116          BRA     FLAGST          Return successful
0000210C                          2117  
0000210C                          2118  * NOT: 01000110|SZ|EMD|ERG
0000210C                          2119  * Syntax:  NOT      <ea>
0000210C                          2120  
0000210C  11FC 004C 100C          2121  BRNOT   MOVE.B  #$4C,(IOOPCD)   Set OP-code name
00002112  6000 F30E               2122          BRA     FLAGST          Return successful
00002116                          2123  
00002116                          2124  * SUB: 1001|REG|OPM|EMD|ERG
00002116                          2125  * Syntax: SUB       <ea>,Dn
00002116                          2126  *         SUB       Dn,<ea>
00002116                          2127  * Note: Most assemblers use SUBA when the destination is an address register
00002116                          2128  *       and SUBI or SUBQ when the source is immediate data.
00002116                          2129  
00002116  11FC 001F 100C          2130  BRSUB   MOVE.B  #$1F,(IOOPCD)   Set OP-code name
0000211C  6000 F304               2131          BRA     FLAGST          Else, return successful
00002120                          2132  
00002120                          2133  * SUBA: 1001|REG|OPM|EMD|ERG
00002120                          2134  * Syntax: SUBA      <ea>,An
00002120                          2135  
00002120  11FC 0023 100C          2136  BRSUBA  MOVE.B  #$23,(IOOPCD)   Set OP-code name 
00002126  6000 F2FA               2137          BRA     FLAGST          Else, return successful
0000212A                          2138  
0000212A                          2139  * SUBI: 0000|0100|SZ|EMD|ERG
0000212A                          2140  * Syntax: SUBI      #<data>,<ea> 
0000212A                          2141  
0000212A  11FC 0028 100C          2142  BRSUBI  MOVE.B  #$28,(IOOPCD)   Set OP-code name
00002130  3011                    2143          MOVE.W  (A1),D0         Move instruction to D0
00002132  243C 000000C0           2144          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002138  6100 F458               2145          BSR     EXTMSK          Get the size to D1
0000213C                          2146  
0000213C  B23C 00FF               2147          CMP.B   #$FF,D1         Test if size was found
00002140  6700 F2E6               2148          BEQ     FLAGCL          If it was not found, branch to clear flag      
00002144  11C1 100E               2149          MOVE.B  D1,(IOSIZE)     If it was found, store size in IOSIZE
00002148                          2150  
00002148                          2151          * Dest EA field: "Only data alterable addressing modes can be used [...]."
00002148  303C 01FD               2152          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
0000214C  6100 FD7A               2153          BSR     EXSRC           Extract source EA mode & register 
00002150  11F8 10C2 10C0          2154          MOVE.B  SMD,(DMD)       The EA mode is the Destination mode
00002156  11F8 10C3 10C1          2155          MOVE.B  SRG,(DRG)       The EA reg is the Destination reg
0000215C  6100 FBFE               2156          BSR     ADVBFR          Advance the buffer accordingly
00002160                          2157          * SUBI format is SUBI.(size)  #<data>, <ea>
00002160                          2158          * manually set the Source mode and source register
00002160  11FC 0007 10C2          2159          MOVE.B  #$07,(SMD)      Source Mode set to 111
00002166  11FC 0004 10C3          2160          MOVE.B  #$04,(SRG)      Register Mode set to 100 #<data>
0000216C  1238 10C3               2161          MOVE.B  SRG,D1          Copy SRG to D1 to manipulate
00002170  E709                    2162          LSL.B   #3,D1           Shift the reg 3 bits left
00002172  8238 10C2               2163          OR.B    (SMD),D1        Add mode after reg
00002176  11C1 10C4               2164          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000217A                          2165          
0000217A  6100 FBE0               2166          BSR     ADVBFR          Advance the buffer accordingly
0000217E  6000 F2A2               2167          BRA     FLAGST          Else, return successful
00002182                          2168  
00002182                          2169  
00002182                          2170  * SUBQ: 0101|DAT|1|SZ|EMD|ERG
00002182                          2171  * Syntax: SUBQ      #<data>,<ea>
00002182                          2172  
00002182                          2173          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 1460
A2H11               1498
A2H12               149E
A2H13               14A4
A2H14               14AA
A2H15               14B0
A2H16               14B6
A2HADV              1490
ADVBFR              1D5C
ADVBSZ              1D92
ASCII2HEX           142E
B1A                 7456
B2A                 745C
B3                  7462
B4                  7468
B5                  746E
BA1                 7490
BA2                 7496
BA3                 749C
BA4                 74A2
BB1                 74C4
BB2                 74CC
BB3                 74D6
BB4                 74E6
BRADD               1EF2
BRADDA              1F24
BRADDI              1F42
BRADDQ              1F38
BRAND               1F4C
BRASD               20D2
BRBAD               1930
BRBCC               1F60
BRBEQ               1F6A
BRBHI               1F88
BRBLT               1F74
BRBNE               1F7E
BRBTST              1F56
BRCMP               1F92
BRCMPA              1F9C
BRCMPI              1FA6
BRDIVS              20E4
BREOR               20EE
BREORI              2102
BRJSR               2022
BRLEA               2008
BRLSD               20D6
BRMOVE              202C
BRMOVEA             2092
BRMOVEM             20BE
BRMOVEQ             20C8
BRMULU              20DA
BRNOT               210C
BRORI               20F8
BRRTS               1FFE
BRSUB               2116
BRSUBA              2120
BRSUBI              212A
CBITS               0
CMPMSK              1564
CR                  D
DIS                 10C5
DISP0               178A
DISP1               179A
DISP2               17AA
DISP3               17CA
DISP4               17F0
DISP5               1816
DISP6               1832
DISP7               185A
DISP8               1876
DISP9               1892
DISPA               18AE
DISPB               18D0
DISPC               18FE
DISPD               192A
DISPOP              175A
DMD                 10C0
DMDTBL              176A
DONE                1AEA
DRG                 10C1
DRGTBL              1862
DSPAX               15AA
DSPHADV             160A
DSPHDR              1ACE
DSPHST              15F6
DSPHXA              15B4
DSPHXL              1614
DSPHXLP             15B8
DSPHXN              15DA
DSPHXRT             15D4
DSPHXW              15EE
DSPOFLP             1740
DSPOFRT             1754
DSPOFS              1736
DSPSTLP             1706
DSPSTR              16FC
DSPSTRT             1722
ELOC                1008
ERR0                13CA
ERR1                13ED
EXDST               1E96
EXSRC               1EC8
EXTADV              15A4
EXTLP               1598
EXTMSK              1592
FLAGCL              1428
FLAGST              1422
GBUFF               1000
H2A                 14EE
H2AA                1526
H2AADV              151E
H2AB                152C
H2AC                1532
H2AD                1538
H2AE                153E
H2AF                1544
HEADR               13A8
HEX2ASCII           14BC
ILL0                161E
ILL1                162C
ILL2                1686
ILL3                1694
IOADDR              1010
IOBDCD              100D
IOLC                1014
IOOPCD              100C
IOOPSZ              10B4
IOSIZE              100E
JMPMSK              1AFA
JUMP                752A
LF                  A
MASK                154A
MNADDR              7000
MSSG0               10C6
MSSG1               1290
MSSG2               12F9
MSSG4               135E
MSSG5               137F
MXADDR              FFFFFF
M_ALL               FFF
M_ALT               7F
M_CTR               7E4
M_DALT              1FD
M_DAT               FFD
M_MALT              1FC
M_MEM               FFC
NODST               1A48
NOSRC               1A16
OP                  1B12
OP0                 1DFC
OP1                 1E0E
OP2                 1E20
OP3                 1E32
OP4                 1E44
OP5                 1E56
OP6                 1E68
OP7                 1E7A
OP8                 1E8C
OPNAME              1016
OPSIZE              1DCA
OPTBL               1DDC
PAUSE               1AAA
PRINT               195A
PRMPT1              1636
PRMPT2              169E
PRMPTDN             16F2
QDATA               1015
RGMD                10C4
SLOC                1004
SMD                 10C2
SRG                 10C3
START               140E
TB                  9
TSTAM               1D34
TSTMSK              1550
VBIN1               FFCFCFCF
VHEX1               FA
VHEX2               DADA
VHEX3               ADADDADA
VHEX4               45
