0000140E Starting Address
Assembler used: EASy68K Editor/Assembler v5.13.01
Created On: 12/5/2013 7:51:09 PM

00000000                             1          INCLUDE 'TEST.x68'
00007000                             2      ORG    $7000
00007000                             3  
00007000  =000000FA                  4  VHEX1   EQU $FA
00007000  =0000DADA                  5  VHEX2   EQU $DADA
00007000  =ADADDADA                  6  VHEX3   EQU $ADADDADA
00007000  =00000045                  7  VHEX4   EQU $45
00007000  =00000000                  8  CBITS   EQU $00000000
00007000  =FFCFCFCF                  9  VBIN1   EQU %11111111110011111100111111001111
00007000                            10  
00007000                            11  
00007000                            12  
00007000                            13  
00007000  1038 00FA                 14      MOVE.B  VHEX1, D0           <ea>,Dn
00007004  3239 0000DADA             15      MOVE.W  VHEX2, D1
0000700A  243C ADADDADA             16      MOVE.L  #VHEX3, D2
00007010                            17      
00007010  10B8 00FA                 18      MOVE.B  VHEX1, (A0)         <ea>,(An)
00007014  32BC DADA                 19      MOVE.W  #VHEX2, (A1)
00007018  24B9 ADADDADA             20      MOVE.L  VHEX3, (A2)
0000701E                            21      
0000701E  16FC 00FA                 22      MOVE.B  #VHEX1, (A3)+       <ea>,(An)+
00007022  38F9 0000DADA             23      MOVE.W  VHEX2, (A4)+
00007028  2AF9 ADADDADA             24      MOVE.L  VHEX3, (A5)+
0000702E                            25      
0000702E  1138 00FA                 26      MOVE.B  VHEX1, -(A0)        <ea>,-(An)
00007032  3539 0000DADA             27      MOVE.W  VHEX2, -(A2)
00007038  293C ADADDADA             28      MOVE.L  #VHEX3, -(A4)
0000703E                            29              
0000703E  13F8 00FA 0000DADA        30      MOVE.B  VHEX1, VHEX2        <ea>,(xxx).W
00007046  33F9 0000DADA ADADDADA    31      MOVE.W  VHEX2, VHEX3        <ea>,(xxx).L
00007050  23F8 0000 00F00200        32      MOVE.L  CBITS, $00F00200    <ea>,#<data>
00007058                            33      
00007058  13C0 0000DADA             34      MOVE.B  D0, VHEX2           Dn,<ea>
0000705E  33C1 00F00210             35      MOVE.W  D1, $00F00210
00007064  22C2                      36      MOVE.L  D2, (A1)+
00007066                            37      
00007066  13D1 0000FF00             38      MOVE.B  (A1),$FF00          (An),<ea>
0000706C  3613                      39      MOVE.W  (A3),D3
0000706E  2315                      40      MOVE.L  (A5),-(A1)
00007070                            41      
00007070  2488                      42      MOVE.L  A0, (A2)            An,<ea>
00007072  36C9                      43      MOVE.W  A1, (A3)+
00007074  23CA ADADDADA             44      MOVE.L  A2, VHEX3
0000707A                            45      
0000707A  13E0 0000DADA             46      MOVE.B  -(A0),VHEX2         -(An),<ea>
00007080  3221                      47      MOVE.W  -(A1),D1
00007082  24E2                      48      MOVE.L  -(A2),(A2)+
00007084                            49      
00007084  3239 0000DADA             50      MOVE.W  VHEX2, D1           (xxx).W, <ea>
0000708A  23F9 ADADDADA 0000DADA    51      MOVE.L  VHEX3, VHEX2        (xxx).L, <ea>
00007094  23FC 000013CF ADADDADA    52      MOVE.L  #%0001001111001111, VHEX3   #<data>,<ea>
0000709E                            53      
0000709E                            54  
0000709E  1F38 00FA                 55      MOVE.B  VHEX1, -(SP)        <ea>, -(SP)
000070A2  34A9 00FA                 56      MOVE.W  (VHEX1,A1),(A2)     (d16,An),<ea>
000070A6  333A 6A32                 57      MOVE.W  (VHEX2,PC),-(A1)    (d16,PC),<ea>
000070AA  261F                      58      MOVE.L  (SP)+, D3           (SP)+, <ea>
000070AC  70FA                      59      MOVEQ.L #VHEX1,D0           MOVEQ
000070AE                            60      
000070AE                            61  
000070AE                            62  
000070AE  3040                      63      MOVEA.W  D0,A0              Dn,An
000070B0  2248                      64      MOVEA.L  A0,A1              An,An
000070B2  2451                      65      MOVEA.L  (A1),A2            (An),An
000070B4                            66      
000070B4  265A                      67      MOVEA.L  (A2)+,A3           (An)+,An
000070B6  3863                      68      MOVEA.W  -(A3),A4           -(An),An
000070B8  3A79 0000DADA             69      MOVEA.W  VHEX2,A5            (xxx).W,An
000070BE                            70      
000070BE  2079 ADADDADA             71      MOVEA.L   VHEX3,A0           (xxx).L,An
000070C4  227C 0000DADA             72      MOVEA.L  #VHEX2,A1           #<data>,An
000070CA  2C79 FFCFCFCF             73      MOVEA.L   VBIN1,A6            (xxx).L,An
000070D0                            74  
000070D0  3C6D 00FA                 75      MOVEA.W  (VHEX1,A5),A6        (d16,An),An
000070D4  3E7A 6A04                 76      MOVEA.W  (VHEX2,PC),A7        (d16,PC),An
000070D8  70FA                      77      MOVEQ.L   #VHEX1, D0           MOVEQ
000070DA  72FA                      78      MOVEQ.L   #VHEX1, D1           MOVEQ
000070DC                            79      
000070DC                            80  
000070DC                            81  
000070DC  4890 020E                 82      MOVEM.W     D1-D3/A1, (A0)      <list>,(An)
000070E0  48B9 0302 0000DADA        83      MOVEM.W     D1/A0-A1, VHEX2     <list>,(xxx).W
000070E8  48E1 F8F8                 84      MOVEM.L     D0-D4/A0-A4, -(A1)  <list>,-(An)
000070EC  48F9 101C ADADDADA        85      MOVEM.L     D2-D4/A4, VHEX3     <list>,(xxx).L
000070F4                            86      
000070F4  4C91 020E                 87      MOVEM.W     (A1),D1-D3/A1       (An),<list>
000070F8  4CB9 0302 0000DADA        88      MOVEM.W     VHEX2, D1/A0-A1     (xxx).W,<list>
00007100  4CDA 1F1F                 89      MOVEM.L     (A2)+, D0-D4/A0-A4  (An)+,<list>
00007104  4CF9 101C ADADDADA        90      MOVEM.L     VHEX3, D2-D4/A4     (xxx).L,<list>
0000710C                            91      
0000710C                            92  
0000710C  48A8 0306 00FA            93      MOVEM.W     D1-D2/A0-A1, (VHEX1,A0) <list>,(d16,An)
00007112  48E9 0306 00FA            94      MOVEM.L     D1-D2/A0-A1, (VHEX1,A1) <list>,(d16,An)
00007118  4CAA 0306 00FA            95      MOVEM.W     (VHEX1,A2),D1-D2/A0-A1  (d16,An),<list>
0000711E  4CFA 0306 69B8            96      MOVEM.L     (VHEX2,PC),D1-D2/A0-A1  (d16,PC),<list>
00007124                            97      
00007124                            98  
00007124  D200                      99      ADD.B       D0,D1       Dn,Dn
00007126  D441                     100      ADD.W       D1,D2
00007128  D682                     101      ADD.L       D2,D3
0000712A                           102      
0000712A  D249                     103      ADD.W       A1,D1       An,Dn
0000712C  D48A                     104      ADD.L       A2,D2
0000712E  DA8B                     105      ADD.L       A3,D5
00007130                           106      
00007130  D410                     107      ADD.B       (A0),D2     (An),Dn
00007132  D651                     108      ADD.W       (A1),D3
00007134  D892                     109      ADD.L       (A2),D4
00007136                           110      
00007136  D01B                     111      ADD.B       (A3)+,D0    (An)+,Dn
00007138  D25C                     112      ADD.W       (A4)+,D1
0000713A  D49D                     113      ADD.L       (A5)+,D2
0000713C                           114      
0000713C  D620                     115      ADD.B       -(A0),D3    -(An),Dn
0000713E  D861                     116      ADD.W       -(A1),D4    
00007140  DAA2                     117      ADD.L       -(A2),D5
00007142                           118      
00007142  D039 0000DADA            119      ADD.B       VHEX2,D0    (xxx).W,Dn
00007148  D279 ADADDADA            120      ADD.W       VHEX3,D1    (xxx).L,Dn
0000714E  0683 000000FA            121      ADD.L       #VHEX1,D3   #<data>,Dn
00007154                           122      
00007154                           123  
00007154  D2C0                     124      ADD.W       D0,A1       Dn,An
00007156  D4C1                     125      ADD.W       D1,A2
00007158  D7C2                     126      ADD.L       D2,A3
0000715A                           127      
0000715A  D714                     128      ADD.B       D3,(A4)     Dn,(An)
0000715C  D955                     129      ADD.W       D4,(A5) 
0000715E  DB96                     130      ADD.L       D5,(A6)
00007160                           131      
00007160  D118                     132      ADD.B       D0,(A0)+    Dn,(An)+
00007162  D359                     133      ADD.W       D1,(A1)+
00007164  D59A                     134      ADD.L       D2,(A2)+
00007166                           135      
00007166  D723                     136      ADD.B       D3,-(A3)    Dn,-(An)
00007168  D964                     137      ADD.W       D4,-(A4)
0000716A  DBA5                     138      ADD.L       D5,-(A5)
0000716C                           139      
0000716C  D339 0000DADA            140      ADD.B       D1,VHEX2    Dn,(xxx).W
00007172  D5B9 ADADDADA            141      ADD.L       D2,VHEX3    Dn,(xxx).L
00007178  D779 FFCFCFCF            142      ADD.W       D3,VBIN1    Dn,(xxx).L
0000717E                           143      
0000717E                           144  
0000717E  D029 00FA                145      ADD.B       (VHEX1,A1),D0   (d16,An),Dn
00007182  D27A 6956                146      ADD.W       (VHEX2,PC),D1   (d16,PC),Dn
00007186  D7A9 00FA                147      ADD.L       D3,(VHEX1,A1)   Dn,(d16,An)
0000718A                           148  
0000718A                           149  
0000718A  D0C0                     150      ADDA.W       D0,A0           Dn,An
0000718C  D3C1                     151      ADDA.L       D1,A1   
0000718E                           152      
0000718E  D7CA                     153      ADDA.L       A2,A3           An,An
00007190  D8CB                     154      ADDA.W       A3,A4
00007192                           155      
00007192  D0D0                     156      ADDA.W       (A0),A0         (An),An
00007194  D5D2                     157      ADDA.L       (A2),A2
00007196                           158      
00007196  D3D9                     159      ADDA.L       (A1)+,A1        (An)+,An
00007198  D4DA                     160      ADDA.W       (A2)+,A2
0000719A                           161     
0000719A  D4E3                     162      ADDA.W       -(A3),A2        -(An),An
0000719C  D7E2                     163      ADDA.L       -(A2),A3
0000719E                           164      
0000719E  D1F9 0000DADA            165      ADDA.L       VHEX2,A0        (xxx).W,An
000071A4  D4F9 0000DADA            166      ADDA.W       VHEX2,A2    
000071AA                           167      
000071AA  D6F9 ADADDADA            168      ADDA.W       VHEX3,A3        (xxx).L,An
000071B0  D9F9 ADADDADA            169      ADDA.L       VHEX3,A4
000071B6                           170      
000071B6  DBFC FFCFCFCF            171      ADDA.L       #VBIN1,A5       #<data>,An
000071BC                           172  
000071BC                           173  
000071BC  D2EA 00FA                174      ADDA.W       (VHEX1,A2),A1   (d16,An),An
000071C0  D7FA 6918                175      ADDA.L       (VHEX2,PC),A3   (d16,PC),An
000071C4  D7EB 00FA                176      ADDA.L       (VHEX1,A3),A3   (d16,An),An
000071C8                           177  
000071C8                           178  
000071C8  5201                     179      ADDQ.B      #$1,D1       #<data>,Dn
000071CA  5442                     180      ADDQ.W      #$2,D2
000071CC  5683                     181      ADDQ.L      #3,D3
000071CE                           182      
000071CE  5848                     183      ADDQ.W      #$4,A0       #<data>,An
000071D0  5A89                     184      ADDQ.L      #$5,A1
000071D2  5C8A                     185      ADDQ.L      #$6,A2
000071D4                           186      
000071D4  5E10                     187      ADDQ.B      #$7,(A0)     #<data>,(An)
000071D6  5051                     188      ADDQ.W      #$8,(A1)
000071D8  5292                     189      ADDQ.L      #1,(A2)
000071DA                           190      
000071DA  541A                     191      ADDQ.B      #$2,(A2)+    #<data>,(An)+
000071DC  565B                     192      ADDQ.W      #$3,(A3)+
000071DE  589C                     193      ADDQ.L      #$4,(A4)+
000071E0                           194      
000071E0  5A25                     195      ADDQ.B      #$5,-(A5)    #<data>,-(An)
000071E2  5C66                     196      ADDQ.W      #6,-(A6)
000071E4  5EA7                     197      ADDQ.L      #$7,-(A7)
000071E6                           198      
000071E6  5239 0000DADA            199      ADDQ.B      #1,VHEX2     #<data>,(xxx).W
000071EC  54B9 ADADDADA            200      ADDQ.L      #2,VHEX3     #<data>,(xxx).L
000071F2  5879 FFCFCFCF            201      ADDQ.W      #$4,VBIN1    #<data>,(xxx).L
000071F8                           202      
000071F8  506A 00FA                203      ADDQ.W      #8,(VHEX1,A2)   #<data>,(d16,An)
000071FC  0640 00FA                204      ADDI.W      #VHEX1,D0       ADDI
00007200  D380                     205      ADDX.L      D0,D1           ADDX
00007202                           206      
00007202                           207  
00007202                           208  
00007202  9200                     209      SUB.B       D0,D1       Dn,Dn
00007204  9642                     210      SUB.W       D2,D3
00007206                           211      
00007206  9089                     212      SUB.L       A1,D0       An,Dn
00007208  964C                     213      SUB.W       A4,D3
0000720A                           214      
0000720A  9613                     215      SUB.B       (A3),D3     (An),Dn
0000720C  9092                     216      SUB.L       (A2),D0
0000720E                           217      
0000720E  9218                     218      SUB.B       (A0)+,D1    (An)+,Dn
00007210  945B                     219      SUB.W       (A3)+,D2
00007212                           220      
00007212  94A1                     221      SUB.L       -(A1),D2    -(An),Dn
00007214  9222                     222      SUB.B       -(A2),D1    
00007216                           223      
00007216  9079 0000DADA            224      SUB.W       VHEX2,D0    (xxx).W,Dn
0000721C  94B9 FFCFCFCF            225      SUB.L       VBIN1,D2    (xxx).L,Dn
00007222  0404 00F0                226      SUB.B       #$F0,D4     #<data>,Dn
00007226                           227      
00007226                           228  
00007226  92C0                     229      SUB.W       D0,A1       Dn,An
00007228  99C3                     230      SUB.L       D3,A4
0000722A                           231      
0000722A  9713                     232      SUB.B       D3,(A3)     Dn,(An)
0000722C  9152                     233      SUB.W       D0,(A2)
0000722E                           234      
0000722E  9398                     235      SUB.L       D1,(A0)+    Dn,(An)+
00007230  951B                     236      SUB.B       D2,(A3)+
00007232                           237      
00007232  9561                     238      SUB.W       D2,-(A1)    Dn,-(An)
00007234  93A2                     239      SUB.L       D1,-(A2)
00007236                           240      
00007236  9139 0000DADA            241      SUB.B       D0,VHEX2    Dn,(xxx).W
0000723C  9579 FFCFCFCF            242      SUB.W       D2,VBIN1    Dn,(xxx).L
00007242  97B9 ADADDADA            243      SUB.L       D3,VHEX3    Dn,(xxx).L
00007248                           244      
00007248                           245  
00007248  902A 00FA                246      SUB.B       (VHEX1,A2),D0   (d16,An),Dn
0000724C  927A 688C                247      SUB.W       (VHEX2,PC),D1   (d16,PC),Dn
00007250  93A9 00FA                248      SUB.L       D1, (VHEX1,A1)  Dn,(d16,An)
00007254                           249      
00007254                           250  
00007254                           251  
00007254  90C0                     252      SUBA.W      D0,A0       Dn,An
00007256  93C1                     253      SUBA.L      D1,A1
00007258                           254      
00007258  94C9                     255      SUBA.W      A1,A2       An,An
0000725A  97CA                     256      SUBA.L      A2,A3
0000725C                           257      
0000725C  96D3                     258      SUBA.W      (A3),A3     (An),An
0000725E  99D4                     259      SUBA.L      (A4),A4
00007260                           260      
00007260  90DD                     261      SUBA.W      (A5)+,A0    (An)+,An
00007262  93DE                     262      SUBA.L      (A6)+,A1
00007264                           263      
00007264  94E0                     264      SUBA.W      -(A0),A2    -(An),An
00007266  97E1                     265      SUBA.L      -(A1),A3
00007268                           266      
00007268  98F9 0000DADA            267      SUBA.W      VHEX2,A4    (xxx).W,An
0000726E  9BF9 ADADDADA            268      SUBA.L      VHEX3,A5    (xxx).L,An
00007274  9DFC FFCFCFCF            269      SUBA.L      #VBIN1,A6   #<data>,An
0000727A                           270      
0000727A                           271  
0000727A  98E9 0F0F                272      SUBA.W      ($F0F,A1),A4   (d16,An),An
0000727E  95FA 9E91                273      SUBA.L      ($1111,PC),A2  (d16,PC),An
00007282                           274      
00007282                           275  
00007282  0400 00FA                276      SUBI.B      #VHEX1,D0       #<data>,Dn
00007286  0442 DADA                277      SUBI.W      #VHEX2,D2
0000728A                           278      
0000728A  0492 ADADDADA            279      SUBI.L      #VHEX3,(A2)       #<data>,(An)
00007290  0411 000A                280      SUBI.B      #10,(A1)
00007294                           281      
00007294  0458 0000                282      SUBI.W      #CBITS,(A0)+      #<data>,(An)+
00007298  049A ADADDADA            283      SUBI.L      #VHEX3,(A2)+
0000729E                           284      
0000729E  0424 000A                285      SUBI.B      #10,-(A4)            #<data>,-(An)
000072A2  0461 000F                286      SUBI.W      #$F,-(A1)
000072A6                           287      
000072A6  04B9 0000DADA 0000DADA   288      SUBI.L      #VHEX2,VHEX2        #<data>,(xxx).W
000072B0  0439 0009 ADADDADA       289      SUBI.B      #09,VHEX3        #<data>,(xxx).L
000072B8                           290      
000072B8                           291  
000072B8  0469 0009 0030           292      SUBI.W      #9,($30,A1)         #<data>,(d16,An)
000072BE  5380                     293      SUBQ.L      #1,D0           SUBQ
000072C0                           294      
000072C0                           295     
000072C0                           296  
000072C0                           297  
000072C0  C2C0                     298      MULU.W      D0,D1           Dn,Dn
000072C2  C2D0                     299      MULU.W      (A0),D1         (An),Dn
000072C4  C4DA                     300      MULU.W      (A2)+,D2        (An)+,Dn
000072C6  C6E3                     301      MULU.W      -(A3),D3        -(An),Dn
000072C8  C8F9 0000DADA            302      MULU.W      VHEX2,D4        (xxx).W,Dn
000072CE  CAF9 ADADDADA            303      MULU.W      VHEX3,D5        (xxx).L,Dn
000072D4  CCFC 2345                304      MULU.W      #$2345,D6       #<data>,Dn
000072D8                           305      
000072D8                           306  
000072D8  C0EA 0032                307      MULU.W      ($32,A2),D0     (d16,An),Dn
000072DC  C2FA 9D22                308      MULU.W      ($1000,PC),D1   (d16,PC),Dn
000072E0                           309      
000072E0                           310      
000072E0                           311  
000072E0  85C1                     312      DIVS.W      D1,D2           Dn,Dn
000072E2  85D1                     313      DIVS.W      (A1),D2         (An),Dn
000072E4  87DA                     314      DIVS.W      (A2)+,D3        (An)+,Dn
000072E6  89E3                     315      DIVS.W      -(A3),D4        -(An),Dn
000072E8  8BF9 0000DADA            316      DIVS.W      VHEX2,D5        (xxx).W,Dn
000072EE  8DF9 ADADDADA            317      DIVS.W      VHEX3,D6        (xxx).L,Dn
000072F4  8FFC FF00                318      DIVS.W      #$FF00,D7       #<data>,Dn
000072F8                           319      
000072F8                           320  
000072F8  83EB 0401                321      DIVS.W      ($401,A3),D1     (d16,An),Dn
000072FC  85FA AF13                322      DIVS.W      ($2211,PC),D2    (d16,PC),Dn
00007300                           323      
00007300                           324     
00007300                           325  
00007300  B101                     326      EOR.B       D0,D1           Dn,Dn
00007302  B342                     327      EOR.W       D1,D2
00007304                           328      
00007304  B592                     329      EOR.L       D2,(A2)         Dn,(An)
00007306  B713                     330      EOR.B       D3,(A3)
00007308                           331      
00007308  B95C                     332      EOR.W       D4,(A4)+        Dn,(An)+
0000730A  BB9D                     333      EOR.L       D5,(A5)+
0000730C                           334      
0000730C  BD26                     335      EOR.B       D6,-(A6)        Dn,-(An)
0000730E  BF67                     336      EOR.W       D7,-(A7)
00007310                           337      
00007310  B1B9 0000DADA            338      EOR.L       D0,VHEX2        Dn,(xxx).W
00007316  B339 ADADDADA            339      EOR.B       D1,VHEX3        Dn,(xxx).L
0000731C                           340  
0000731C                           341  
0000731C  B56C 0101                342      EOR.W       D2,($101,A4)    Dn,(d16,An)
00007320  0A3C 0001                343      EORI.B      #$1,CCR         EORI to CCR
00007324                           344      
00007324                           345  
00007324                           346  
00007324  0A00 00FA                347      EORI.B      #VHEX1,D0       #<data>,Dn
00007328  0A41 000A                348      EORI.W      #10,D1
0000732C                           349      
0000732C  0A91 ADADDADA            350      EORI.L      #VHEX3,(A1)     #<data>,An
00007332  0A13 0012                351      EORI.B      #$12,(A3)
00007336                           352      
00007336  0A5A DADA                353      EORI.W      #VHEX2,(A2)+    #<data>,(An)+
0000733A  0A9C FFCFCFCF            354      EORI.L      #VBIN1,(A4)+
00007340                           355      
00007340  0A20 00FF                356      EORI.B      #$FF, -(A0)     #<data>,-(An)
00007344  0A65 1222                357      EORI.W      #$1222,-(A5)
00007348                           358      
00007348  0AB9 0000DADA 0000DADA   359      EORI.L      #VHEX2,VHEX2    #<data>,(xxx).W
00007352  0A39 0011 ADADDADA       360      EORI.B      #$11, VHEX3     #<data>,(xxx).L
0000735A                           361      
0000735A                           362  
0000735A  0A6A 000A 0011           363      EORI.W      #10, ($11,A2)   #<data>,(d16,An)
00007360  C342                     364      EXG.L       D1,D2           EXG
00007362                           365      
00007362                           366  
00007362                           367  
00007362  C200                     368      AND.B       D0,D1           Dn,Dn
00007364  C451                     369      AND.W       (A1),D2         (An),Dn
00007366  C69A                     370      AND.L       (A2)+,D3        (An)+,Dn
00007368  C823                     371      AND.B       -(A3),D4        -(An),Dn
0000736A  CA79 0000DADA            372      AND.W       VHEX2,D5        (xxx).W,Dn
00007370  CCB9 ADADDADA            373      AND.L       VHEX3,D6        (xxx).L,Dn
00007376  CE3C 00FF                374      AND.B       #$FF,D7         #<data>,Dn
0000737A                           375      
0000737A                           376  
0000737A  C151                     377      AND.W       D0,(A1)         Dn,(An)
0000737C  C39A                     378      AND.L       D1,(A2)+        Dn,(An)+
0000737E  C523                     379      AND.B       D2,-(A3)        Dn,-(An)
00007380  C779 0000DADA            380      AND.W       D3,VHEX2        Dn,(xxx).W
00007386  C9B9 FFCFCFCF            381      AND.L       D4,VBIN1        Dn,(xxx).L
0000738C                           382      
0000738C                           383  
0000738C  C42A 0012                384      AND.B       ($12,A2),D2     (d16,An),Dn
00007390  C67A 9D8F                385      AND.W       ($1121,PC),D3   (d16,PC),Dn
00007394  C9AC 0112                386      AND.L       D4, ($112,A4)   Dn,(d16,An)
00007398                           387      
00007398                           388  
00007398  0000 00F1                389      ORI.B       #$F1,D0         #<data>,Dn
0000739C  0052 DADA                390      ORI.W       #VHEX2,(A2)     #<data>,(An)
000073A0  009B ADADDADA            391      ORI.L       #VHEX3,(A3)+    #<data>,(An)+
000073A6  0024 0011                392      ORI.B       #$11,-(A4)      #<data>,-(An)
000073AA  0079 0062 0000DADA       393      ORI.W       #98,VHEX2       #<data>,(xxx).W
000073B2  00B9 00000064 ADADDADA   394      ORI.L       #100,VHEX3      #<data>,(xxx).L
000073BC                           395      
000073BC                           396  
000073BC  002A 0004 00FF           397      ORI.B       #4,($FF,A2)     #<data>,(d16,An)
000073C2  8441                     398      OR.W        D1,D2           OR
000073C4                           399      
000073C4                           400  
000073C4  E121                     401      ASL.B       D0,D1       Dx,Dy
000073C6  E562                     402      ASL.W       D2,D2       
000073C8  E982                     403      ASL.L       #4,D2       #<data>,Dy
000073CA  E1D2                     404      ASL.W       (A2)        (An)
000073CC  E1DB                     405      ASL.W       (A3)+       (An)+
000073CE  E1E4                     406      ASL.W       -(A4)       -(An)
000073D0  E1F9 0000DADA            407      ASL.W       VHEX2       (xxx).W
000073D6  E1F9 ADADDADA            408      ASL.W       VHEX3       (xxx).L
000073DC                           409      
000073DC                           410  
000073DC  E1EC 0022                411      ASL.W       ($22,A4)    (d16,An)
000073E0  E0F9 0000DADA            412      ASR.W       VHEX2       ASR
000073E6                           413      
000073E6  E029                     414      LSR.B       D0,D1       Dx,Dy
000073E8  E46A                     415      LSR.W       D2,D2       
000073EA  E88A                     416      LSR.L       #4,D2       #<data>,Dy
000073EC  E2D2                     417      LSR.W       (A2)        (An)
000073EE  E2DB                     418      LSR.W       (A3)+       (An)+
000073F0  E2E4                     419      LSR.W       -(A4)       -(An)
000073F2  E2F9 0000DADA            420      LSR.W       VHEX2       (xxx).W
000073F8  E2F9 ADADDADA            421      LSR.W       VHEX3       (xxx).L
000073FE                           422      
000073FE                           423  
000073FE  E2EC 0022                424      LSR.W       ($22,A4)    (d16,An)
00007402  E3F9 0000DADA            425      LSL.W       VHEX2       LSL
00007408                           426      
00007408                           427  
00007408  0101                     428      BTST.L      D0, D1      Dn,Dn
0000740A  0311                     429      BTST.B      D1,(A1)     Dn,(An)
0000740C  051A                     430      BTST.B      D2,(A2)+    Dn,(An)+
0000740E  0723                     431      BTST.B      D3,-(A3)    Dn,-(An)
00007410  0939 0000DADA            432      BTST.B      D4,VHEX2    Dn,(xxx).W
00007416  0B38 0045                433      BTST.B      D5,VHEX4    Dn,(xxx).L
0000741A  0D3C 0004                434      BTST.B      D6,#4       Dn,#<data>
0000741E                           435      
0000741E                           436  
0000741E  0800 00DA                437      BTST.L      #VHEX2,D0       #<data>,Dn
00007422  0810 00FA                438      BTST.B      #VHEX1,(A0)     #<data>,(An)
00007426  0818 00DA                439      BTST.B      #VHEX3,(A0)+    #<data>,(An)+
0000742A  0824 00CF                440      BTST.B      #VBIN1,-(A4)    #<data>,-(An)
0000742E  0839 0011 0000DADA       441      BTST.B      #$11,VHEX2      #<data>,(xxx).W
00007436  0839 0099 ADADDADA       442      BTST.B      #$99,VHEX3      #<data>,(xxx).L
0000743E                           443      
0000743E                           444  
0000743E  0F2B 0011                445      BTST.B      D7, ($11,A3)    Dn,(d16,An)
00007442  0D3A 8C66                446      BTST.B      D6, ($AA,PC)    Dn,(d16,PC)
00007446  082A 0057 00BB           447      BTST.B      #1111,($BB,A2)  #<data>,(d16,An)
0000744C                           448      
0000744C  B001                     449      CMP.B       D1,D0       Dn,Dn
0000744E  6700 0002                450      BEQ         B1a
00007452                           451  B1a    
00007452  B24A                     452      CMP.W       A2,D1       An,Dn
00007454  6700 0002                453      BEQ         B2a
00007458                           454  B2a
00007458  B493                     455      CMP.L       (A3),D2     (An),Dn
0000745A  6D00 0002                456      BLT         B3
0000745E                           457  B3
0000745E  B61C                     458      CMP.B       (A4)+,D3    (An)+,Dn
00007460  6600 0002                459      BNE         B4
00007464                           460  B4
00007464  B865                     461      CMP.W       -(A5),D4    -(An),Dn
00007466  6200 0002                462      BHI         B5
0000746A                           463  B5
0000746A  BAB9 0000DADA            464      CMP.L       VHEX2,D5    (xxx).W,Dn
00007470  BC39 ADADDADA            465      CMP.B       VHEX3,D6    (xxx).L,Dn
00007476  BEBC FFCFCFCF            466      CMP.L       #VBIN1,D7   #<data>,Dn
0000747C                           467  
0000747C                           468  
0000747C  B028 00FF                469      CMP.B       ($FF,A0),D0     (d16,An),Dn
00007480  B47A 983F                470      CMP.W       ($CC1,PC),D2    (d16,PC),Dn
00007484                           471      
00007484                           472  
00007484  B0C0                     473      CMPA.W      D0,A0       Dn,An
00007486  B3C8                     474      CMPA.L      A0,A1       An,An
00007488  6700 0002                475      BEQ         Ba1
0000748C                           476  Ba1
0000748C  B4D1                     477      CMPA.W      (A1),A2     (An),An
0000748E  6D00 0002                478      BLT         Ba2
00007492                           479  Ba2
00007492  B7DA                     480      CMPA.L      (A2)+,A3    (An)+,An
00007494  6600 0002                481      BNE         Ba3
00007498                           482  Ba3
00007498  B8E3                     483      CMPA.W      -(A3),A4    -(An),An
0000749A  6200 0002                484      BHI         Ba4
0000749E                           485  Ba4
0000749E  BBF9 0000DADA            486      CMPA.L      VHEX2,A5    (xxx).W,An
000074A4  BCF9 ADADDADA            487      CMPA.W      VHEX3,A6    (xxx).L,An
000074AA  BFFC 000004D2            488      CMPA.L      #1234,A7    #<data>,An
000074B0                           489      
000074B0                           490  
000074B0  B0E9 0033                491      CMPA.W      ($33,A1),A0     (d16,An),An
000074B4  B5FA 8B5B                492      CMPA.L      ($11,PC),A2     (d16,PC),An
000074B8                           493      
000074B8                           494  
000074B8  0C00 00FA                495      CMPI.B      #VHEX1,D0       #<data>,Dn
000074BC  6700 0002                496      BEQ         Bb1
000074C0                           497  Bb1
000074C0  0C51 DADA                498      CMPI.W      #VHEX2,(A1)     #<data>,(An)
000074C4  6600 0002                499      BNE         Bb2
000074C8                           500  Bb2
000074C8  0C9A ADADDADA            501      CMPI.L      #VHEX3,(A2)+    #<data>,(An)+
000074CE  6200 0002                502      BHI         Bb3
000074D2                           503  Bb3
000074D2  0C23 0012                504      CMPI.B      #$12,-(A3)      #<data>,-(An)
000074D6  6D00 000A                505      BLT         Bb4
000074DA  0C79 1234 0000DADA       506      CMPI.W      #$1234,VHEX2    #<data>,(xxx).W
000074E2                           507  Bb4
000074E2  0CB9 FFCFCFCF ADADDADA   508      CMPI.L      #VBIN1,VHEX3    #<data>,(xxx).L
000074EC                           509      
000074EC                           510  
000074EC  0C2A 00FF 0099           511      CMPI.B      #$FF,($99,A2)       #<data>,(d16,An)
000074F2  B30A                     512      CMPM.B      (A2)+,(A1)+         CMPM
000074F4                           513      
000074F4                           514  
000074F4  41D1                     515      LEA     (A1),A0         (An),An
000074F6  43F9 0000DADA            516      LEA     VHEX2,A1        (xxx).W,An
000074FC  45F9 ADADDADA            517      LEA     VHEX3,A2        (xxx).L,An
00007502                           518   
00007502                           519  
00007502  43E9 0010                520      LEA     ($10,A1),A1     (d16,An),An
00007506  45FA 9491                521      LEA     ($999,PC),A2    (d16,PC),An
0000750A                           522      
0000750A  4EB9 00007526            523      JSR     JUMP
00007510  4E91                     524      JSR     (A1)        (An)
00007512  4EB9 0000DADA            525      JSR     VHEX2       (xxx).W
00007518  4EB9 ADADDADA            526      JSR     VHEX3       (xxx).L
0000751E  4EAA 0019                527      JSR     ($19,A2)    (d16,An)
00007522  4EBA 8BDC                528      JSR     ($100,PC)   (d16,PC)
00007526                           529      
00007526                           530  JUMP    *For JSR & RTS test
00007526  1201                     531          MOVE.B  D1, D1
00007528  4E75                     532          RTS
0000752A  4E71                     533          NOP         NOP
0000752C                           534  
0000752C                           535  
0000752C                           536  
0000752C                           537  
0000752C                           538  -------------------- end include --------------------
0000752C                           539  *----------------------------------------------------------------------------
0000752C                           540  * Title      : 3B Disassembler
0000752C                           541  * Written by : The Three Bears: Joseph Schooley, Nguyen Tong, Terence Calhoun
0000752C                           542  * Date       : 11/30/2013
0000752C                           543  * Description: A Motorola MC68000 Microprocessor Disassembler 
0000752C                           544  *----------------------------------------------------------------------------
00001000                           545          ORG     $1000
00001000  =0000000D                546  CR      EQU     $0D         ASCII: carriage return
00001000  =0000000A                547  LF      EQU     $0A         ASCII: line feed
00001000  =00000009                548  TB      EQU     $09         ASCII: horizontal tab
00001000  =00007000                549  MNADDR  EQU     $7000       Min address
00001000  =00FFFFFF                550  MXADDR  EQU     $00FFFFFF   Max address
00001000                           551  
00001000                           552  GBUFF   DS.L    1           Pointer to next location in "Good buffer"
00001004                           553  SLOC    DS.B    4           Starting location storage
00001008                           554  ELOC    DS.B    4           Ending location storage
0000100C                           555  
0000100C                           556  *-----I/O Memory-----
0000100C                           557  IOOPCD  DS.B    1           IO offset value for OPNAME, or FF if none
0000100D                           558  IOBDCD  DS.B    1           IO offset value for BAD OPNAME, or FF if none
0000100E                           559  IOSIZE  DS.B    1           IO size for OP code, or FF if none
00001010                           560  IOADDR  DS.L    1           IO address value for instruction memory location
00001014                           561  IOLC    DS.B    1           IO line counter for screen
00001015                           562  QDATA   DS.B    1           OP immediate data for xxxxQ instructions
00001016                           563  
00001016                           564  
00001016                           565  * OP code name memory
00001016                           566  * Example to display MULU:
00001016                           567  *       LEA     OPNAME,A1
00001016                           568  *       ADD.L   #$2D,A1
00001016                           569  *       MOVE.B  #14,D0
00001016                           570  *       TRAP    #15
00001016                           571  *                NAME           DEC     HEX
00001016= 4D 4F 56 45 00           572  OPNAME  DC.B    'MOVE',0        00      00
0000101B= 4D 4F 56 45 41 00        573          DC.B    'MOVEA',0       05      05
00001021= 4D 4F 56 45 4D 00        574          DC.B    'MOVEM',0       11      0B
00001027= 41 44 44 00              575          DC.B    'ADD',0         17      11
0000102B= 41 44 44 41 00           576          DC.B    'ADDA',0        21      15
00001030= 41 44 44 51 00           577          DC.B    'ADDQ',0        26      1A
00001035= 53 55 42 00              578          DC.B    'SUB',0         31      1F
00001039= 53 55 42 41 00           579          DC.B    'SUBA',0        35      23
0000103E= 53 55 42 49 00           580          DC.B    'SUBI',0        40      28
00001043= 4D 55 4C 55 00           581          DC.B    'MULU',0        45      2D
00001048= 44 49 56 53 00           582          DC.B    'DIVS',0        50      32
0000104D= 4C 45 41 00              583          DC.B    'LEA',0         55      37
00001051= 41 4E 44 00              584          DC.B    'AND',0         59      3B
00001055= 4F 52 49 00              585          DC.B    'ORI',0         63      3F
00001059= 45 4F 52 00              586          DC.B    'EOR',0         67      43
0000105D= 45 4F 52 49 00           587          DC.B    'EORI',0        71      47
00001062= 4E 4F 54 00              588          DC.B    'NOT',0         76      4C
00001066= 41 53 4C 00              589          DC.B    'ASL',0         80      50
0000106A= 4C 53 52 00              590          DC.B    'LSR',0         84      54
0000106E= 42 54 53 54 00           591          DC.B    'BTST',0        88      58
00001073= 43 4D 50 00              592          DC.B    'CMP',0         93      5D
00001077= 43 4D 50 41 00           593          DC.B    'CMPA',0        97      61
0000107C= 43 4D 50 49 00           594          DC.B    'CMPI',0        102     66
00001081= 42 43 43 00              595          DC.B    'BCC',0         107     6B
00001085= 42 45 51 00              596          DC.B    'BEQ',0         111     6F
00001089= 42 4C 54 00              597          DC.B    'BLT',0         115     73
0000108D= 42 4E 45 00              598          DC.B    'BNE',0         119     77
00001091= 42 48 49 00              599          DC.B    'BHI',0         123     7B
00001095= 4A 53 52 00              600          DC.B    'JSR',0         127     7F
00001099= 52 54 53 00              601          DC.B    'RTS',0         131     83
0000109D= 42 41 44 00              602          DC.B    'BAD',0         135     87
000010A1= 4D 4F 56 45 51 00        603          DC.B    'MOVEQ',0       139     8B
000010A7= 4C 53 4C 00              604          DC.B    'LSL',0         145     91
000010AB= 41 53 52 00              605          DC.B    'ASR',0         149     95
000010AF= 41 44 44 49 00           606          DC.B    'ADDI',0        153     99
000010B4                           607  
000010B4= 2E 42 00                 608  IOOPSZ  DC.B    '.B',0          0       00
000010B7= 2E 57 00                 609          DC.B    '.W',0          3       03
000010BA= 2E 4C 00                 610          DC.B    '.L',0          6,      06
000010BD= 20 20 00                 611          DC.B    '  ',0          9,      09
000010C0                           612  
000010C0                           613  *-----EA Memory------
000010C0                           614  DMD     DS.B    1               Destination mode
000010C1                           615  DRG     DS.B    1               Destination register
000010C2                           616  SMD     DS.B    1               Source mode
000010C3                           617  SRG     DS.B    1               Source register
000010C4                           618  RGMD    DS.B    1               Last register + mod (00REGMOD)
000010C5                           619  DIS     DS.B    1               Last displacement
000010C6                           620  
000010C6                           621  *--------------------
000010C6                           622  
000010C6= 20 20 5F 20 20 20 ...    623  MSSG0   DC.B    '  _     _     _     _     _     _ ',CR,LF
000010EA= 20 28 6F 5C 2D 2D ...    624          DC.B    ' (o\---/o)   (o\---/o)   (o\---/o)',CR,LF
0000110E= 20 20 7C 20 2D 20 ...    625          DC.B    '  | - - |     | ^ ^ |     | . . |',CR,LF
00001131= 20 5F 28 20 28 59 ...    626          DC.B    ' _( (Y)_)_,--.(_(Y)_),--._(_(Y) )_',CR,LF
00001155= 2F 20 2F 5F 5F 5F ...    627          DC.B    '/ /___|_  ".."       ".."  _|___\ \',CR,LF
0000117A= 5C 5F 5F 5F 5F 5F ...    628          DC.B    '\_______):     THREE     :(_______/',CR,LF
0000119F= 7C 20 7C 20 20 20 ...    629          DC.B    '| |   |        BEARS        |   | |',CR,LF
000011C4= 7C 20 7C 20 20 20 ...    630          DC.B    '| |   |    DISASSEMBLER     |   | |',CR,LF
000011E9= 7C 20 20 5C 5F 5F ...    631          DC.B    '|  \__|__Joey__Terence__Win_|__/  |',CR,LF
0000120E= 20 5C 20 20 20 20 ...    632          DC.B    ' \    I  /_  )   |   (  _\  I    /',CR,LF
00001232= 20 20 5C 5F 5F 5F ...    633          DC.B    '  \____)___)(___/ \___)(___(____/',CR,LF
00001255= 57 65 6C 63 6F 6D ...    634          DC.B    'Welcome to 3B Disassembler. Enter 0 at any time to quit.',CR,LF,0
00001290= 45 6E 74 65 72 20 ...    635  MSSG1   DC.B    'Enter the starting location of the code to be disassembled, or leave it blank',CR,LF,'for the starting address:',0
000012F9= 45 6E 74 65 72 20 ...    636  MSSG2   DC.B    'Enter the ending location of the code to be disassembled, or leave it blank',CR,LF,'for the ending address:',0
0000135E= 50 72 65 73 73 20 ...    637  MSSG4   DC.B    'Press any key for the next page.',0
0000137F= 59 6F 75 20 68 61 ...    638  MSSG5   DC.B    'You have reached the end of the program.',0
000013A8= 41 64 64 72 65 73 ...    639  HEADR   DC.B    'Address      OP-Code    Operand',CR,LF,0
000013CA= 54 68 65 20 69 6E ...    640  ERR0    DC.B    'The input address was too small.',CR,LF,0
000013ED= 54 68 65 20 69 6E ...    641  ERR1    DC.B    'The input address was too big.',CR,LF,0
0000140E                           642  
0000140E  11FC 0000 1014           643  START   MOVE.B  #0,IOLC
00001414                           644          *JMP     $7000
00001414  43F8 10C6                645          LEA     MSSG0,A1        Welcome message
00001418  103C 000E                646          MOVE.B  #14,D0
0000141C  4E4F                     647          TRAP    #15
0000141E  6000 0216                648          BRA     PRMPT1
00001422                           649  
00001422                           650  *-----------------------------------
00001422                           651  *    Conversion & Comparison Methods
00001422                           652  *-----------------------------------
00001422                           653  
00001422                           654  *
00001422                           655  * Flag set / clear: Sets or clears the flag
00001422                           656  *
00001422                           657   
00001422  44FC 0004                658  FLAGST  MOVE.W  #%100,CCR       Set the z-flag
00001426  4E75                     659          RTS                     Return to caller
00001428  44FC 0000                660  FLAGCL  MOVE.W  #%000,CCR       Clear the z-flg
0000142C  4E75                     661          RTS                     Return to caller
0000142E                           662  
0000142E                           663  *
0000142E                           664  * ASCII2HEX: Convert ASCII into HEX.
0000142E                           665  * Input ASCII from D0 output HEX to D1
0000142E                           666  *
0000142E                           667  
0000142E                           668  ASCII2HEX
0000142E  2200                     669          MOVE.L  D0,D1           Move the input to D1
00001430  0441 3030                670          SUB     #$3030,D1       Convert last word
00001434  4841                     671          SWAP    D1              Swap bytes
00001436  0441 3030                672          SUB     #$3030,D1       Convert first word
0000143A  4841                     673          SWAP    D1              Restore order
0000143C                           674          
0000143C  2F02                     675          MOVE.L  D2,-(SP)        Push D2 on stack
0000143E  4282                     676          CLR.L   D2              
00001440  143C 0003                677          MOVE.B  #3,D2           Set rotation count
00001444                           678          
00001444  6100 001A                679          BSR     A2H             Start loop
00001448                           680          
00001448  241F                     681          MOVE.L  (SP)+,D2        Restore D2
0000144A                           682                  
0000144A                           683                                * XAXBXCXD
0000144A  E919                     684          ROL.B   #4,D1           XAXBXCDX
0000144C  E949                     685          LSL.W   #4,D1           XAXBCDX0
0000144E  E159                     686          ROL.W   #8,D1           XAXBX0CD
00001450  4841                     687          SWAP    D1              X0CDXAXB
00001452  E919                     688          ROL.B   #4,D1           X0CDXABX
00001454  E949                     689          LSL.W   #4,D1           X0CDABX0
00001456  E189                     690          LSL.L   #8,D1           CDABX000
00001458  4241                     691          CLR.W   D1              CDAB0000
0000145A  4841                     692          SWAP    D1              0000CDAB
0000145C  E159                     693          ROL.W   #8,D1           0000ABCD
0000145E  4E75                     694          RTS                     Return to caller
00001460                           695          
00001460                           696          
00001460                           697  A2H   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
00001460  B23C 0011                698          CMP.B   #$11,D1         11 = A
00001464  6700 0032                699          BEQ     A2H11
00001468  B23C 0012                700          CMP.B   #$12,D1         12 = B
0000146C  6700 0030                701          BEQ     A2H12
00001470  B23C 0013                702          CMP.B   #$13,D1         13 = C
00001474  6700 002E                703          BEQ     A2H13
00001478  B23C 0014                704          CMP.B   #$14,D1         14 = D
0000147C  6700 002C                705          BEQ     A2H14
00001480  B23C 0015                706          CMP.B   #$15,D1         15 = E
00001484  6700 002A                707          BEQ     A2H15
00001488  B23C 0016                708          CMP.B   #$16,D1         16 = F
0000148C  6700 0028                709          BEQ     A2H16
00001490                           710          
00001490                           711  A2HADV  * A2H conversion branch helper: Rotate to the next byte, and loop back to A2H until all bytes have been analyzed/converted
00001490  E199                     712          ROL.L   #8,D1           Rotate 1st byte to the end
00001492  51CA FFCC                713          DBRA    D2,A2H          If count is > 0, decrement and loop back to A2H
00001496  4E75                     714          RTS                     If count == 0, return to sub-routine
00001498                           715  
00001498                           716  * A2H conversion branches
00001498  123C 000A                717  A2H11   MOVE.B  #$A,D1
0000149C  60F2                     718          BRA     A2HADV
0000149E  123C 000B                719  A2H12   MOVE.B  #$B,D1
000014A2  60EC                     720          BRA     A2HADV
000014A4  123C 000C                721  A2H13   MOVE.B  #$C,D1
000014A8  60E6                     722          BRA     A2HADV
000014AA  123C 000D                723  A2H14   MOVE.B  #$D,D1
000014AE  60E0                     724          BRA     A2HADV
000014B0  123C 000E                725  A2H15   MOVE.B  #$E,D1
000014B4  60DA                     726          BRA     A2HADV
000014B6  123C 000F                727  A2H16   MOVE.B  #$F,D1
000014BA  60D4                     728          BRA     A2HADV
000014BC                           729  
000014BC                           730  *
000014BC                           731  * HEX2ASCII: Convert ASCII into HEX.
000014BC                           732  * Input HEX from D0.W output ASCII to D1.L
000014BC                           733  *
000014BC                           734  
000014BC                           735  HEX2ASCII
000014BC  2200                     736          MOVE.L  D0,D1           Move the input to D1
000014BE                           737  
000014BE                           738                                * XXXXABCD
000014BE  4841                     739          SWAP    D1              ABCDXXXX
000014C0  4241                     740          CLR.W   D1              ABCD0000
000014C2  E999                     741          ROL.L   #4,D1           BCD0000A
000014C4  E909                     742          LSL.B   #4,D1           BCD000A0
000014C6  E159                     743          ROL.W   #8,D1           BCD0A000
000014C8  E999                     744          ROL.L   #4,D1           CD0A000B
000014CA  E159                     745          ROL.W   #8,D1           CD0A0B00
000014CC  E999                     746          ROL.L   #4,D1           D0A0B00C
000014CE  E909                     747          LSL.B   #4,D1           D0A0B0C0
000014D0  E999                     748          ROL.L   #4,D1           0A0B0C0D
000014D2                           749  
000014D2  2F02                     750          MOVE.L  D2,-(SP)        Push D2 on stack
000014D4  4282                     751          CLR.L   D2              
000014D6  143C 0003                752          MOVE.B  #3,D2           Set rotation count
000014DA  6100 0012                753          BSR     H2A             Start loop
000014DE  241F                     754          MOVE.L  (SP)+,D2        Restore D2
000014E0                           755  
000014E0  0641 3030                756          ADD     #$3030,D1       Convert last word
000014E4  4841                     757          SWAP    D1              Swap bytes
000014E6  0641 3030                758          ADD     #$3030,D1       Convert first word
000014EA  4841                     759          SWAP    D1              Restore order
000014EC  4E75                     760          RTS                     Return to caller
000014EE                           761          
000014EE                           762          
000014EE                           763  H2A   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
000014EE  B23C 000A                764          CMP.B   #$A,D1         A = 11
000014F2  6700 0032                765          BEQ     H2AA
000014F6  B23C 000B                766          CMP.B   #$B,D1         B = 12
000014FA  6700 0030                767          BEQ     H2AB
000014FE  B23C 000C                768          CMP.B   #$C,D1         C = 13
00001502  6700 002E                769          BEQ     H2AC
00001506  B23C 000D                770          CMP.B   #$D,D1         D = 14
0000150A  6700 002C                771          BEQ     H2AD
0000150E  B23C 000E                772          CMP.B   #$E,D1         E = 15
00001512  6700 002A                773          BEQ     H2AE
00001516  B23C 000F                774          CMP.B   #$F,D1         F = 16
0000151A  6700 0028                775          BEQ     H2AF
0000151E                           776          
0000151E                           777  H2AADV  * H2A conversion branch helper: Rotate to the next byte, and loop back to H2A until all bytes have been analyzed/converted
0000151E  E199                     778          ROL.L   #8,D1           Rotate 1st byte to the end
00001520  51CA FFCC                779          DBRA    D2,H2A          If count is > 0, decrement and loop back to A2H
00001524  4E75                     780          RTS                     If count == 0, return to sub-routine
00001526                           781  
00001526                           782  * H2A conversion branches
00001526  123C 0011                783  H2AA    MOVE.B  #$11,D1
0000152A  60F2                     784          BRA     H2AADV
0000152C  123C 0012                785  H2AB    MOVE.B  #$12,D1
00001530  60EC                     786          BRA     H2AADV
00001532  123C 0013                787  H2AC    MOVE.B  #$13,D1
00001536  60E6                     788          BRA     H2AADV
00001538  123C 0014                789  H2AD    MOVE.B  #$14,D1
0000153C  60E0                     790          BRA     H2AADV
0000153E  123C 0015                791  H2AE    MOVE.B  #$15,D1
00001542  60DA                     792          BRA     H2AADV
00001544  123C 0016                793  H2AF    MOVE.B  #$16,D1
00001548  60D4                     794          BRA     H2AADV
0000154A                           795  
0000154A                           796  
0000154A                           797  *
0000154A                           798  * Mask: Mask an input
0000154A                           799  * Input value from D0, input mask from D2, output masked value to D1
0000154A                           800  *
0000154A                           801  
0000154A  2200                     802  MASK    MOVE.L  D0,D1           Move the input to D1
0000154C  C282                     803          AND.L   D2,D1           Perform AND on input with the mask
0000154E  4E75                     804          RTS                     Return to caller
00001550                           805  
00001550                           806  *
00001550                           807  * Test Mask: Test an input to a mask.
00001550                           808  * Input value from D0, input mask from D2, and modify z-flag
00001550                           809  *
00001550                           810  
00001550  2F01                     811  TSTMSK  MOVE.L  D1,-(SP)        Push D1 on stack
00001552  61F6                     812          BSR     MASK            Mask the input
00001554  B481                     813          CMP.L   D1,D2           Test if the input matched the mask
00001556  6606                     814          BNE     *+8             If it didn't match, skip two lines
00001558  221F                     815          MOVE.L  (SP)+,D1        Restore D1
0000155A  6000 FEC6                816          BRA     FLAGST          Set flag & return to caller
0000155E  221F                     817          MOVE.L  (SP)+,D1        Restore D1
00001560  6000 FEC6                818          BRA     FLAGCL          Clear flag & return to caller
00001564                           819  
00001564                           820  *
00001564                           821  * Compare Mask: Strictly test an input to two masks allowing don't cares.
00001564                           822  * Input value from D0, input 1 mask from D2, input 0 mask from D3, and modify z-flag
00001564                           823  *
00001564                           824  
00001564  48E7 F800                825  CMPMSK  MOVEM.L D0-D4,-(SP)     Push D1-D4 on stack
00001568  2800                     826          MOVE.L  D0,D4           Copy input to D4
0000156A  C082                     827          AND.L   D2,D0           AND 1 mask to input
0000156C  B480                     828          CMP.L   D0,D2           Compare masked input to 1 mask
0000156E  6708                     829          BEQ     *+10            If it matched, skip two lines
00001570  4CDF 001F                830          MOVEM.L (SP)+,D0-D4     If it didn't match, restore D1-D4
00001574  6000 FEB2                831          BRA     FLAGCL          Clear flag & return to caller
00001578  2004                     832          MOVE.L  D4,D0           Restore input
0000157A  4680                     833          NOT.L   D0              !input
0000157C  C083                     834          AND.L   D3,D0           AND 0 mask on input; effectively, NOR 0 mask to the input
0000157E  B680                     835          CMP.L   D0,D3           Compare masked input to 0 mask
00001580  6608                     836          BNE     *+10            If it didn't match, skip to clear flag
00001582  4CDF 001F                837          MOVEM.L (SP)+,D0-D4     If it matched, restore D1-D4
00001586  6000 FE9A                838          BRA     FLAGST          Set flag & return to caller
0000158A  4CDF 001F                839          MOVEM.L (SP)+,D0-D4     Restore D1-D4
0000158E  6000 FE98                840          BRA     FLAGCL          Clear flag & return to caller
00001592                           841  
00001592                           842  *        
00001592                           843  * Extract Mask: Test an input to a subsequent mask, and return the masked value in LSB format
00001592                           844  * Input value from D0, input mask from D2, output value in D1
00001592                           845  *
00001592                           846  
00001592  2F02                     847  EXTMSK  MOVE.L  D2,-(SP)        Push D2 on stack
00001594  2200                     848          MOVE.L  D0,D1           Move the input to D1
00001596  C282                     849          AND.L   D2,D1           Perform AND on input with the mask
00001598  0802 0000                850  EXTLP   BTST.L  #0,D2           Test the LSB of the mask for 0
0000159C  6700 0006                851          BEQ     EXTADV          If it is 0, rotate the mask until it is 1
000015A0  241F                     852          MOVE.L  (SP)+,D2        Restore the mask
000015A2  4E75                     853          RTS                     Return to caller
000015A4                           854          
000015A4  E28A                     855  EXTADV  LSR.L   #1,D2           Rotate mask right by 1 bit
000015A6  E299                     856          ROR.L   #1,D1           Rotate output in sync with mask
000015A8  60EE                     857          BRA     EXTLP           Return to loop
000015AA                           858  
000015AA                           859  *
000015AA                           860  * Display ASCII: Display the ASCII from D0.L to screen
000015AA                           861  *
000015AA  48E7 E000                862  DSPAX   MOVEM.L D0-D2,-(SP)     Push D0-D2
000015AE  2200                     863          MOVE.L  D0,D1
000015B0  6000 0044                864          BRA     DSPHST          Branch to DISPHX Start
000015B4                           865  
000015B4                           866  *
000015B4                           867  * Display HEX Address: Display the hex from A1 according to the byte length in D2.L
000015B4                           868  *
000015B4                           869  
000015B4  48E7 E040                870  DSPHXA  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
000015B8  51CA 0006                871  DSPHXLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
000015BC  6000 0016                872          BRA     DSPHXRT         If count is <= 0, branch to return
000015C0  1019                     873          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
000015C2  6100 FEF8                874          BSR     HEX2ASCII       Get ASCII in D1
000015C6  E159                     875          ROL.W   #8,D1           Read first byte
000015C8  103C 0006                876          MOVE.B  #6,D0           Display char from D1.B
000015CC  4E4F                     877          TRAP    #15
000015CE  E159                     878          ROL.W   #8,D1           Read second byte
000015D0  4E4F                     879          TRAP    #15
000015D2  60E4                     880          BRA     DSPHXLP         Loop back
000015D4  4CDF 0207                881  DSPHXRT MOVEM.L (SP)+,D0-D2/A1  Else, restore values
000015D8  4E75                     882          RTS                     Return to caller
000015DA                           883          
000015DA                           884  
000015DA                           885  
000015DA                           886  *
000015DA                           887  * Display HEX Nibble: Display the hex from D0.B to screen
000015DA                           888  *
000015DA                           889  
000015DA  48E7 C000                890  DSPHXN  MOVEM.L D0/D1,-(SP)     Push D0 and D1 to stack
000015DE  6100 FEDC                891          BSR     HEX2ASCII       Get ASCII in D1
000015E2  103C 0006                892          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
000015E6  4E4F                     893          TRAP    #15
000015E8  4CDF 0003                894          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
000015EC  4E75                     895          RTS                     Return to caller
000015EE                           896  
000015EE                           897  *
000015EE                           898  * Display HEX Word: Display the hex from D0.W to screen
000015EE                           899  *
000015EE                           900  
000015EE  48E7 E000                901  DSPHXW  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
000015F2  6100 FEC8                902          BSR     HEX2ASCII       Get ASCII in D1
000015F6                           903  
000015F6  4282                     904  DSPHST  CLR.L   D2              
000015F8  143C 0003                905          MOVE.B  #3,D2           Set rotation count
000015FC  103C 0006                906          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
00001600  6100 0008                907          BSR     DSPHADV         Start loop
00001604                           908  
00001604  4CDF 0007                909          MOVEM.L  (SP)+,D0-D2    Restore D0-D2
00001608  4E75                     910          RTS                     Return to caller
0000160A                           911  
0000160A  E199                     912  DSPHADV ROL.L   #8,D1           Rotate bytes left
0000160C  4E4F                     913          TRAP    #15             Display char in D1.B
0000160E  51CA FFFA                914          DBRA    D2,DSPHADV      If count is > 0, decrement and loop back to DSPHADV
00001612  4E75                     915          RTS                     If count == 0, return to sub-routine
00001614                           916  
00001614                           917  *
00001614                           918  * Display HEX Long: Display the hex from D0.L to screen
00001614                           919  *
00001614                           920  
00001614  4840                     921  DSPHXL  SWAP    D0              Swap first half to D0.W
00001616  61D6                     922          BSR     DSPHXW          Display first half
00001618  4840                     923          SWAP    D0              Swap lower half to D0.W
0000161A  61D2                     924          BSR     DSPHXW          Display lower half
0000161C  4E75                     925          RTS                     Return to caller
0000161E                           926          
0000161E                           927  
0000161E                           928          
0000161E                           929  *--------------------
0000161E                           930  *   I/O
0000161E                           931  *--------------------                   
0000161E  43F8 13CA                932  ILL0    LEA     ERR0,A1         Starting location was too small
00001622  103C 000E                933          MOVE.B  #14,D0
00001626  4E4F                     934          TRAP    #15
00001628  6000 000C                935          BRA     PRMPT1
0000162C                           936          
0000162C  43F8 13ED                937  ILL1    LEA     ERR1,A1         Starting location was too big
00001630  103C 000E                938          MOVE.B  #14,D0
00001634  4E4F                     939          TRAP    #15
00001636                           940          
00001636  43F8 1290                941  PRMPT1  LEA     MSSG1,A1        Starting location request message
0000163A  103C 000E                942          MOVE.B  #14,D0
0000163E  4E4F                     943          TRAP    #15
00001640                           944          
00001640  43F8 1004                945          LEA     SLOC,A1         Input will be stored in SLOC
00001644  103C 0002                946          MOVE.B  #2,D0           Input starting location (as string / hex)
00001648  4E4F                     947          TRAP    #15
0000164A                           948          
0000164A  2038 1004                949          MOVE.L  (SLOC),D0       Move input to D0
0000164E                           950  
0000164E  B0BC 00FFFFFF            951          CMP.L   #$00FFFFFF,D0   Check if input was NULL
00001654  660C                     952          BNE     *+14            If the input was not null, branch to convert input
00001656  21FC 00007000 1004       953          MOVE.L  #MNADDR,(SLOC)  If the input was null, move the min address to SLOC
0000165E  6000 003E                954          BRA     PRMPT2          Branch to the next prompt
00001662                           955          
00001662  6100 FDCA                956          BSR     ASCII2HEX       Convert D0 to HEX in D1
00001666                           957          
00001666  2281                     958          MOVE.L  D1,(A1)         Set SLOC to HEX value
00001668                           959                          
00001668  B2BC 00000000            960          CMP.L   #0,D1           Compare starting location to 0
0000166E  6700 0470                961          BEQ     DONE            End program if 0
00001672                           962          
00001672  B2BC 00007000            963          CMP.L   #MNADDR,D1      Compare starting location to min
00001678  65A4                     964          BLO     ILL0            Branch to ILL0 if < min
0000167A                           965          
0000167A  B2BC 00FFFFFF            966          CMP.L   #MXADDR,D1      Compare ending location to max
00001680  64AA                     967          BHS     ILL1            Branch to ILL1 if >= max
00001682                           968                  
00001682  6000 001A                969          BRA     PRMPT2          Branch to the next prompt
00001686                           970  
00001686  43F8 13CA                971  ILL2    LEA     ERR0,A1         Ending location was too small
0000168A  103C 000E                972          MOVE.B  #14,D0
0000168E  4E4F                     973          TRAP    #15
00001690  6000 000C                974          BRA     PRMPT2
00001694                           975          
00001694  43F8 13ED                976  ILL3    LEA     ERR1,A1         Ending location was too big
00001698  103C 000E                977          MOVE.B  #14,D0
0000169C  4E4F                     978          TRAP    #15
0000169E                           979          
0000169E  43F8 12F9                980  PRMPT2  LEA     MSSG2,A1        Ending location request message
000016A2  103C 000E                981          MOVE.B  #14,D0
000016A6  4E4F                     982          TRAP    #15
000016A8                           983          
000016A8  43F8 1008                984          LEA     ELOC,A1         Input will be stored in SLOC
000016AC  103C 0002                985          MOVE.B  #2,D0           Input starting location (as string / hex)
000016B0  4E4F                     986          TRAP    #15
000016B2                           987          
000016B2  2038 1008                988          MOVE.L  (ELOC),D0       Move input to D0
000016B6                           989  
000016B6  B0BC 00FFFFFF            990          CMP.L   #$00FFFFFF,D0   Check if input was NULL
000016BC  660C                     991          BNE     *+14            If the input was not null, branch to convert input
000016BE  21FC 00FFFFFF 1008       992          MOVE.L  #MXADDR,(ELOC)  If the input was null, move the max address to ELOC
000016C6  6000 002A                993          BRA     PRMPTDN         Branch to prompt done
000016CA                           994          
000016CA  6100 FD62                995          BSR     ASCII2HEX       Convert D0 to HEX in D1
000016CE                           996          
000016CE  2281                     997          MOVE.L  D1,(A1)         Set ELOC to HEX value
000016D0                           998  
000016D0  B2BC 00000000            999          CMP.L   #0,D1           Compare ending location to 0
000016D6  6700 0408               1000          BEQ     DONE            End program if 0
000016DA                          1001          
000016DA  B2BC 00007000           1002          CMP.L   #MNADDR,D1      Compare min ending location to min
000016E0  63A4                    1003          BLS     ILL2            Branch to ILL2 if <= min
000016E2                          1004          
000016E2  B2BC 00FFFFFF           1005          CMP.L   #MXADDR,D1      Compare ending location to max
000016E8  62AA                    1006          BHI     ILL3            Branch to ILL3 if > max
000016EA                          1007          
000016EA  2038 1004               1008          MOVE.L  (SLOC),D0       Move starting location data to D0
000016EE  B280                    1009          CMP.L   D0,D1           Compare ending location to starting location
000016F0  6394                    1010          BLS     ILL2            Branch to ILL3 if <= starting location
000016F2                          1011          
000016F2  21F8 1004 1000          1012  PRMPTDN MOVE.L  SLOC,GBUFF      Store starting location in GBUFF for OP
000016F8  6000 03CA               1013          BRA     DSPHDR          Branch to display method
000016FC                          1014  
000016FC                          1015  *
000016FC                          1016  * Display string: Displays string until NULL char
000016FC                          1017  * Input string at A1, output length of string at D1.B
000016FC                          1018  * Max length: 255
000016FC                          1019  *
000016FC                          1020          
000016FC  48E7 E040               1021  DSPSTR  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
00001700  243C 000000FF           1022          MOVE.L  #255,D2         Set count to 255
00001706  51CA 0006               1023  DSPSTLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
0000170A  6000 0016               1024          BRA     DSPSTRT         If count is <= 0, branch to return
0000170E  1019                    1025          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
00001710  B03C 0000               1026          CMP.B   #0,D0           Check if byte is NULL char
00001714  6700 000C               1027          BEQ     DSPSTRT         If byte is NULL char, branch to return
00001718  6100 FDA2               1028          BSR     HEX2ASCII       Else, get ASCII in D1
0000171C  6100 FE8C               1029          BSR     DSPAX           Display ASCII
00001720  60E4                    1030          BRA     DSPSTLP         Loop back
00001722  4482                    1031  DSPSTRT NEG.L   D2              Negate count
00001724  0682 000000FE           1032          ADD.L   #254,D2         Add 254; effectively 255 - count - null byte
0000172A  4CDF 0003               1033          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
0000172E  1202                    1034          MOVE.B  D2,D1           Move length to D1
00001730  4CDF 0204               1035          MOVEM.L (SP)+,D2/A1     Restore D2 and A1
00001734  4E75                    1036          RTS                     Return to caller
00001736                          1037  
00001736                          1038  *
00001736                          1039  * Display offset space: Display space according to offset length
00001736                          1040  * Input offset length in D2.B
00001736                          1041  *
00001736                          1042  
00001736  48E7 E000               1043  DSPOFS  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
0000173A                          1044          * Ensure count is strictly in one byte
0000173A  4280                    1045          CLR.L   D0
0000173C  1002                    1046          MOVE.B  D2,D0
0000173E  2400                    1047          MOVE.L  D0,D2
00001740  51CA 0006               1048  DSPOFLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001744  6000 000E               1049          BRA     DSPOFRT         If count is <= 0, branch to return
00001748  103C 0006               1050          MOVE.B  #6,D0           Display character
0000174C  123C 0020               1051          MOVE.B  #' ',D1         Read space
00001750  4E4F                    1052          TRAP    #15
00001752  60EC                    1053          BRA     DSPOFLP         Loop back
00001754  4CDF 0007               1054  DSPOFRT MOVEM.L (SP)+,D0-D2     Restore D0-D2
00001758  4E75                    1055          RTS                     Return to callr
0000175A                          1056  
0000175A                          1057  *
0000175A                          1058  * Display operand: Displays operand according to mode and register
0000175A                          1059  * Input mode in D2.B, input reg in D3.B
0000175A                          1060  *
0000175A                          1061  
0000175A  48E7 E000               1062  DISPOP  MOVEM.L D0-D2,-(SP)         Push D0-D2 to stack
0000175E  103C 0006               1063          MOVE.B  #6,D0               Display character
00001762  C4FC 0004               1064          MULU.W  #4,D2
00001766  4EFB 2002               1065          JMP     DMDTBL(PC,D2.W)     Jump to mode
0000176A  6000 001E               1066  DMDTBL  BRA     DISP0               Dn
0000176E  6000 002A               1067          BRA     DISP1               An
00001772  6000 0036               1068          BRA     DISP2               (An)
00001776  6000 0052               1069          BRA     DISP3               (An)+
0000177A  6000 0074               1070          BRA     DISP4               -(An)
0000177E  6000 0096               1071          BRA     DISP5               (d,An)
00001782  6000 00AE               1072          BRA     DISP6               (d,An,Xn)
00001786  6000 00D2               1073          BRA     DISP7               (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
0000178A                          1074  * Dn            000 XXX
0000178A  123C 0044               1075  DISP0   MOVE.B  #'D',D1             Read D
0000178E  4E4F                    1076          TRAP    #15
00001790  2003                    1077          MOVE.L  D3,D0               Read reg from D3
00001792  6100 FE46               1078          BSR     DSPHXN              Display as hex nibble
00001796  6000 0188               1079          BRA     DISPD               Branch to return
0000179A                          1080  * An            001 XXX
0000179A  123C 0041               1081  DISP1   MOVE.B  #'A',D1             Read A
0000179E  4E4F                    1082          TRAP    #15
000017A0  2003                    1083          MOVE.L  D3,D0               Read reg from D3
000017A2  6100 FE36               1084          BSR     DSPHXN              Display as hex byte
000017A6  6000 0178               1085          BRA     DISPD               Branch to return
000017AA                          1086  * (An)          010 XXX
000017AA  123C 0028               1087  DISP2   MOVE.B  #'(',D1             Read (
000017AE  4E4F                    1088          TRAP    #15
000017B0  123C 0041               1089          MOVE.B  #'A',D1             Read A
000017B4  4E4F                    1090          TRAP    #15
000017B6  2003                    1091          MOVE.L  D3,D0               Read reg from D3
000017B8  6100 FE20               1092          BSR     DSPHXN              Display as hex nibble
000017BC  103C 0006               1093          MOVE.B  #6,D0               Display character
000017C0  123C 0029               1094          MOVE.B  #')',D1             Read )
000017C4  4E4F                    1095          TRAP    #15
000017C6  6000 0158               1096          BRA     DISPD               Branch to return
000017CA                          1097  * (An)+         011 XXX
000017CA  123C 0028               1098  DISP3   MOVE.B  #'(',D1             Read (
000017CE  4E4F                    1099          TRAP    #15
000017D0  123C 0041               1100          MOVE.B  #'A',D1             Read A
000017D4  4E4F                    1101          TRAP    #15
000017D6  2003                    1102          MOVE.L  D3,D0               Read reg from D3
000017D8  6100 FE00               1103          BSR     DSPHXN              Display as hex nibble
000017DC  103C 0006               1104          MOVE.B  #6,D0               Display character
000017E0  123C 0029               1105          MOVE.B  #')',D1             Read )
000017E4  4E4F                    1106          TRAP    #15
000017E6  123C 002B               1107          MOVE.B  #'+',D1             Read +
000017EA  4E4F                    1108          TRAP    #15
000017EC  6000 0132               1109          BRA     DISPD               Branch to return
000017F0                          1110  * -(An)         100 XXX
000017F0  123C 002D               1111  DISP4   MOVE.B  #'-',D1             Read +
000017F4  4E4F                    1112          TRAP    #15
000017F6  123C 0028               1113          MOVE.B  #'(',D1             Read (
000017FA  4E4F                    1114          TRAP    #15
000017FC  123C 0041               1115          MOVE.B  #'A',D1             Read A
00001800  4E4F                    1116          TRAP    #15
00001802  2003                    1117          MOVE.L  D3,D0               Read reg from D3
00001804  6100 FDD4               1118          BSR     DSPHXN              Display as hex nibble
00001808  103C 0006               1119          MOVE.B  #6,D0               Display character
0000180C  123C 0029               1120          MOVE.B  #')',D1             Read )
00001810  4E4F                    1121          TRAP    #15
00001812  6000 010C               1122          BRA     DISPD               Branch to return
00001816                          1123  * (d,An)        101 XXX
00001816  123C 0028               1124  DISP5   MOVE.B  #'(',D1             Read (
0000181A  4E4F                    1125          TRAP    #15
0000181C                          1126          *----TODO---*
0000181C                          1127          * Display d *
0000181C  123C 002C               1128          MOVE.B  #',',D1             Read ,
00001820  4E4F                    1129          TRAP    #15
00001822  123C 0041               1130          MOVE.B  #'A',D1             Read A
00001826  4E4F                    1131          TRAP    #15
00001828                          1132          *----TODO---*
00001828                          1133          * Display A *
00001828  123C 0029               1134          MOVE.B  #')',D1             Read )
0000182C  4E4F                    1135          TRAP    #15
0000182E  6000 00F0               1136          BRA     DISPD               Branch to return
00001832                          1137  * (d,An,Xn)     110 XXX
00001832  123C 0028               1138  DISP6   MOVE.B  #'(',D1             Read (
00001836  4E4F                    1139          TRAP    #15
00001838                          1140          *----TODO---*
00001838                          1141          * Display d *
00001838  123C 002C               1142          MOVE.B  #',',D1             Read ,
0000183C  4E4F                    1143          TRAP    #15
0000183E  123C 0041               1144          MOVE.B  #'A',D1             Read A
00001842  4E4F                    1145          TRAP    #15
00001844                          1146          *----TODO---*
00001844                          1147          * Display A *
00001844  123C 002C               1148          MOVE.B  #',',D1             Read ,
00001848  4E4F                    1149          TRAP    #15
0000184A  123C 0058               1150          MOVE.B  #'X',D1             Read X
0000184E  4E4F                    1151          TRAP    #15
00001850                          1152          *----TODO---*
00001850                          1153          * Display X *
00001850  123C 0029               1154          MOVE.B  #')',D1             Read )
00001854  4E4F                    1155          TRAP    #15
00001856  6000 00C8               1156          BRA     DISPD               Branch to return
0000185A                          1157  * (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
0000185A  C6FC 0004               1158  DISP7   MULU.W  #4,D3
0000185E  4EFB 3002               1159          JMP     DRGTBL(PC,D3.W)     Jump to reg
00001862  6000 0012               1160  DRGTBL  BRA     DISP8               (XXX).W
00001866  6000 002A               1161          BRA     DISP9               (XXX).L
0000186A  6000 0042               1162          BRA     DISPA               (d,PC)
0000186E  6000 0060               1163          BRA     DISPB               (d,PC,Xn)
00001872  6000 008A               1164          BRA     DISPC               #data
00001876                          1165  * (XXX.W)       111 000
00001876                          1166  DISP8   
00001876  123C 0024               1167          MOVE.B  #'$',D1             Read $
0000187A  4E4F                    1168          TRAP    #15
0000187C  2278 1010               1169          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001880  4282                    1170          CLR.L   D2
00001882  143C 0002               1171          MOVE.B  #2,D2               Read word size to D2
00001886  6100 FD2C               1172          BSR     DSPHXA              Display address
0000188A  D5B8 1010               1173          ADD.L   D2,(IOADDR)         Advance IO address by word
0000188E  6000 0090               1174          BRA     DISPD               Branch to return
00001892                          1175  * (XXX.L)       111 001
00001892  123C 0024               1176  DISP9   MOVE.B  #'$',D1             Read $
00001896  4E4F                    1177          TRAP    #15
00001898  2278 1010               1178          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000189C  4282                    1179          CLR.L   D2
0000189E  143C 0004               1180          MOVE.B  #4,D2               Read long size to D2
000018A2  6100 FD10               1181          BSR     DSPHXA              Display address
000018A6  D5B8 1010               1182          ADD.L   D2,(IOADDR)         Advance IO address by long
000018AA  6000 0074               1183          BRA     DISPD               Branch to return
000018AE                          1184  * (d,PC)        111 010
000018AE  123C 0028               1185  DISPA   MOVE.B  #'(',D1             Read (
000018B2  4E4F                    1186          TRAP    #15
000018B4                          1187          *----TODO---*
000018B4                          1188          * Display d *
000018B4  123C 002C               1189          MOVE.B  #',',D1             Read ,
000018B8  4E4F                    1190          TRAP    #15
000018BA  123C 0050               1191          MOVE.B  #'P',D1             Read P
000018BE  4E4F                    1192          TRAP    #15
000018C0  123C 0043               1193          MOVE.B  #'C',D1             Read C
000018C4  4E4F                    1194          TRAP    #15
000018C6  123C 0029               1195          MOVE.B  #')',D1             Read )
000018CA  4E4F                    1196          TRAP    #15
000018CC  6000 0052               1197          BRA     DISPD
000018D0                          1198  * (d,PC,Xn)     111 011
000018D0  123C 0028               1199  DISPB   MOVE.B  #'(',D1             Read (
000018D4  4E4F                    1200          TRAP    #15
000018D6                          1201          *----TODO---*
000018D6                          1202          * Display d *
000018D6  123C 002C               1203          MOVE.B  #',',D1             Read ,
000018DA  4E4F                    1204          TRAP    #15
000018DC  123C 0050               1205          MOVE.B  #'P',D1             Read P
000018E0  4E4F                    1206          TRAP    #15
000018E2  123C 0043               1207          MOVE.B  #'C',D1             Read C
000018E6  4E4F                    1208          TRAP    #15
000018E8  123C 002C               1209          MOVE.B  #',',D1             Read ,
000018EC  4E4F                    1210          TRAP    #15
000018EE  123C 0058               1211          MOVE.B  #'X',D1             Read X
000018F2  4E4F                    1212          TRAP    #15
000018F4                          1213          *----TODO---*
000018F4                          1214          * Display X *
000018F4  123C 0029               1215          MOVE.B  #')',D1             Read )
000018F8  4E4F                    1216          TRAP    #15
000018FA  6000 0024               1217          BRA     DISPD               Branch to return
000018FE                          1218  * #<data>       111 100
000018FE  123C 0023               1219  DISPC   MOVE.B  #'#',D1             Read #
00001902  4E4F                    1220          TRAP    #15
00001904  2278 1010               1221          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001908  4282                    1222          CLR.L   D2
0000190A  1438 100E               1223          MOVE.B  (IOSIZE),D2         Read instruction size to D2
0000190E  C4FC 0002               1224          MULU.W  #2,D2               Translate size to value
00001912  6100 FCA0               1225          BSR     DSPHXA              Display address
00001916  D3C2                    1226          ADD.L   D2,A1               Advance A1 by instruction size
00001918  21C9 1010               1227          MOVE.L  A1,(IOADDR)         Move A1 to IOADDR
0000191C  6000 0002               1228          BRA     DISPD               Branch to return
00001920  4CDF 0007               1229  DISPD   MOVEM.L (SP)+,D0-D2         Restore D0-D2
00001924  4E75                    1230          RTS                         Return to caller
00001926                          1231          
00001926  11F8 100C 100D          1232  BRBAD   MOVE.B  (IOOPCD),(IOBDCD)   Move OPCODE to BAD OPCODE
0000192C  11FC 0087 100C          1233          MOVE.B  #$87,(IOOPCD)       Set OPCODE to BAD
00001932                          1234          * Clear bad data
00001932  11FC 00FF 10C2          1235          MOVE.B  #$FF,(SMD)
00001938  11FC 00FF 10C3          1236          MOVE.B  #$FF,(SRG)
0000193E  11FC 00FF 10C0          1237          MOVE.B  #$FF,(DMD)
00001944  11FC 00FF 10C1          1238          MOVE.B  #$FF,(DRG)
0000194A  11FC 00FF 100E          1239          MOVE.B  #$FF,(IOSIZE)
00001950                          1240          
00001950                          1241  PRINT   *----TODO----*
00001950                          1242          * If OP code exists as BAD and BAD OPCODE don't exist, assume that the last
00001950                          1243          * OP display was BAD, and display then next word as raw data
00001950  0C38 00FF 100C          1244          CMP.B   #$FF,(IOOPCD)       Test if OP code exists
00001956  67CE                    1245          BEQ     BRBAD               If it does not, display BAD
00001958                          1246  
00001958  2038 1010               1247          MOVE.L  (IOADDR),D0         Read memory location
0000195C  6100 FCB6               1248          BSR     DSPHXL              Display as hex long
00001960  103C 0006               1249          MOVE.B  #6,D0               Display character
00001964  123C 0009               1250          MOVE.B  #TB,D1              Read tab
00001968  4E4F                    1251          TRAP    #15
0000196A                          1252  
0000196A  4280                    1253          CLR.L   D0
0000196C  4282                    1254          CLR.L   D2
0000196E  43F8 1016               1255          LEA     OPNAME,A1           Read OP-code
00001972  1038 100C               1256          MOVE.B  (IOOPCD),D0         Get offset
00001976  D3C0                    1257          ADD.L   D0,A1               Add offset
00001978  6100 FD82               1258          BSR     DSPSTR              Display string until NULL char and get length in D1.B
0000197C  1401                    1259          MOVE.B  D1,D2               Store length in D2 to be used as space offset
0000197E                          1260      
0000197E  0C38 00FF 100D          1261          CMP.B   #$FF,(IOBDCD)       Test if BAD OP code exists
00001984  6732                    1262          BEQ     *+52                If it doesn't exist, don't display it
00001986  103C 0006               1263          MOVE.B  #6,D0               Display character
0000198A  123C 0020               1264          MOVE.B  #' ',D1             Read space
0000198E  4E4F                    1265          TRAP    #15
00001990  123C 0028               1266          MOVE.B  #'(',D1             Read (
00001994  4E4F                    1267          TRAP    #15
00001996  43F8 1016               1268          LEA     OPNAME,A1           Read OP-code
0000199A  1038 100D               1269          MOVE.B  (IOBDCD),D0         Get offset
0000199E  D3C0                    1270          ADD.L   D0,A1               Add offset
000019A0  6100 FD5A               1271          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000019A4  D401                    1272          ADD.B   D1,D2               Add length to space offset
000019A6  103C 0006               1273          MOVE.B  #6,D0               Display character
000019AA  123C 003F               1274          MOVE.B  #'?',D1
000019AE  4E4F                    1275          TRAP    #15                 Read ?
000019B0  123C 0029               1276          MOVE.B  #')',D1             Read )
000019B4  4E4F                    1277          TRAP    #15
000019B6  5402                    1278          ADD.B   #2,D2               Add 2 to space offset to account for ( and )
000019B8                          1279  
000019B8  43F8 10B4               1280          LEA     IOOPSZ,A1           Read OP code size
000019BC  103C 0003               1281          MOVE.B  #$03,D0             Set size to 3
000019C0  0C38 00FF 100E          1282          CMP.B   #$FF,(IOSIZE)       Test if OP size exists
000019C6  6704                    1283          BEQ     *+6                 If OP size doesn't exist, skip the next line
000019C8  1038 100E               1284          MOVE.B  (IOSIZE),D0         If OP size exists, move it to D0
000019CC  C0FC 0003               1285          MULU.W  #$3,D0              Multiply size by 3 for correct offset
000019D0  D3C0                    1286          ADD.L   D0,A1               Add offset
000019D2  6100 FD28               1287          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000019D6                          1288          
000019D6  D401                    1289          ADD.B   D1,D2               Add length to space offset
000019D8  4442                    1290          NEG.W   D2                  Negate space offset
000019DA  0642 000B               1291          ADD.W   #11,D2              Add 11 to space offset; effectively 11 - space offset
000019DE                          1292  
000019DE  6100 FD56               1293          BSR     DSPOFS              Display space offset with tab
000019E2                          1294  
000019E2  54B8 1010               1295          ADD.L   #2,(IOADDR)         Move memory location past first word
000019E6                          1296  
000019E6  4204                    1297          CLR.B   D4                  Set source to false
000019E8  4242                    1298          CLR.W   D2
000019EA  4243                    1299          CLR.W   D3
000019EC  1438 10C2               1300          MOVE.B  (SMD),D2            Read source mode to D2
000019F0  B43C 00FF               1301          CMP.B   #$FF,D2             Test if it exists
000019F4  6700 0016               1302          BEQ     NOSRC               If it does not exist, do not display source
000019F8  1638 10C3               1303          MOVE.B  (SRG),D3            Read source reg to D3
000019FC  B63C 00FF               1304          CMP.B   #$FF,D3             Test if it exists
00001A00  6700 000A               1305          BEQ     NOSRC               If it does not exist, do not display source
00001A04  6100 FD54               1306          BSR     DISPOP              If both mode & register exist, display accordingly
00001A08  183C 0001               1307          MOVE.B  #1,D4               Set source to true
00001A0C                          1308  
00001A0C  4242                    1309  NOSRC   CLR.W   D2
00001A0E  4243                    1310          CLR.W   D3
00001A10  1438 10C0               1311          MOVE.B  (DMD),D2            Read dest mode to D2
00001A14  B43C 00FF               1312          CMP.B   #$FF,D2             Test if it exists
00001A18  6700 0024               1313          BEQ     NODST               If it does not exist, do not display dest
00001A1C  1638 10C1               1314          MOVE.B  (DRG),D3            Read dest reg to D3
00001A20  B63C 00FF               1315          CMP.B   #$FF,D3             Test if it exists
00001A24  6700 0018               1316          BEQ     NODST               If it does not exist, do not display dest
00001A28                          1317  
00001A28  103C 0006               1318          MOVE.B  #6,D0               Display character
00001A2C  123C 002C               1319          MOVE.B  #',',D1             Read comma
00001A30  B83C 0001               1320          CMP.B   #1,D4               Test if source was displayed
00001A34  6600 0000               1321          BNE     *+2                 If it was not displayed, don't display a comma
00001A38  4E4F                    1322          TRAP    #15                 If it was displayed, display a comma
00001A3A                          1323  
00001A3A  6100 FD1E               1324          BSR     DISPOP              If both mode & register exist, display accordingly
00001A3E                          1325  
00001A3E  103C 0006               1326  NODST   MOVE.B  #6,D0               Display character
00001A42  123C 0009               1327          MOVE.B  #TB,D1              Read tab
00001A46  4E4F                    1328          TRAP    #15
00001A48                          1329  
00001A48  123C 000D               1330          MOVE.B  #CR,D1
00001A4C  4E4F                    1331          TRAP    #15
00001A4E  123C 000A               1332          MOVE.B  #LF,D1
00001A52  4E4F                    1333          TRAP    #15
00001A54                          1334  
00001A54                          1335          *DISPLAY IO OPERAND
00001A54                          1336          
00001A54  2078 1000               1337          MOVE.L  GBUFF,A0            Set A0 to ELOC location
00001A58  B1F8 1008               1338          CMPA.L  ELOC,A0             Compare next buffer to ending location
00001A5C  6C00 0082               1339          BGE     DONE                Branch to DONE if >= ending location
00001A60                          1340  
00001A60  5238 1014               1341          ADD.B   #1,IOLC
00001A64  0C38 001E 1014          1342          CMP.B   #30,IOLC            Compare #30 to line counter
00001A6A  6700 0034               1343          BEQ     PAUSE               If ==, branch to PAUSE
00001A6E                          1344  
00001A6E                          1345          * Reset IO instruction values
00001A6E  11FC 00FF 10C2          1346          MOVE.B  #$FF,(SMD)
00001A74  11FC 00FF 10C3          1347          MOVE.B  #$FF,(SRG)
00001A7A  11FC 00FF 10C0          1348          MOVE.B  #$FF,(DMD)
00001A80  11FC 00FF 10C1          1349          MOVE.B  #$FF,(DRG)
00001A86  11FC 00FF 100C          1350          MOVE.B  #$FF,(IOOPCD)
00001A8C  11FC 00FF 100D          1351          MOVE.B  #$FF,(IOBDCD)
00001A92  11FC 00FF 100E          1352          MOVE.B  #$FF,(IOSIZE)
00001A98  54B8 1000               1353          ADD.L   #$2,(GBUFF)     Advance buffer
00001A9C                          1354  
00001A9C  6000 006A               1355          BRA     OP                  Branch to OP for next instruction
00001AA0                          1356  
00001AA0  43F8 135E               1357  PAUSE   LEA     MSSG4,A1            Display keypress prompt
00001AA4  103C 000E               1358          MOVE.B  #14,D0
00001AA8  4E4F                    1359          TRAP    #15
00001AAA  103C 000C               1360          MOVE.B  #12,D0              Hide keyboard input
00001AAE  123C 0000               1361          MOVE.B  #0,D1
00001AB2  4E4F                    1362          TRAP    #15
00001AB4  103C 0005               1363          MOVE.B  #5,D0               Request keyboard input
00001AB8  4E4F                    1364          TRAP    #15
00001ABA                          1365  *----TODO----*
00001ABA                          1366  * Test if keycode was for ENTER
00001ABA  103C 000C               1367          MOVE.B  #12,D0              Show keyboard input
00001ABE  123C 0001               1368          MOVE.B  #1,D1
00001AC2  4E4F                    1369          TRAP    #15
00001AC4  103C 000B               1370  DSPHDR  MOVE.B  #11,D0              Clear the screen
00001AC8  323C FF00               1371          MOVE.W  #$FF00,D1
00001ACC  4E4F                    1372          TRAP    #15
00001ACE  43F8 13A8               1373          LEA     HEADR,A1            Display header
00001AD2  103C 000E               1374          MOVE.B  #14,D0
00001AD6  4E4F                    1375          TRAP    #15
00001AD8  4238 1014               1376          CLR.B   (IOLC)              Reset line counter
00001ADC  6000 002A               1377          BRA     OP
00001AE0                          1378  
00001AE0  43F8 137F               1379  DONE    LEA     MSSG5,A1            Display end message
00001AE4  103C 000E               1380          MOVE.B  #14,D0
00001AE8  4E4F                    1381          TRAP    #15
00001AEA  103C 0009               1382          MOVE.B  #9,D0
00001AEE  4E4F                    1383          TRAP    #15
00001AF0                          1384  
00001AF0                          1385  *--------------------
00001AF0                          1386  *   OP
00001AF0                          1387  *--------------------
00001AF0                          1388  
00001AF0                          1389  *
00001AF0                          1390  * Jump Mask: Use CMPMSK, and jumps to the OP branch if it returns true
00001AF0                          1391  * Input CMPMSK inputs, input A0 for OP branch
00001AF0                          1392  *
00001AF0                          1393  
00001AF0  6100 FA72               1394  JMPMSK  BSR     CMPMSK          Branch to CMPMSK
00001AF4  6610                    1395          BNE.S   *+18            If the bits did not match, return to caller
00001AF6  4E90                    1396          JSR     (A0)            If the bits matched, branch to the OP address
00001AF8  660A                    1397          BNE     *+12            If the OP address was read ybsuccessful, skip the next two lines
00001AFA  21C9 1000               1398          MOVE.L  A1,GBUFF        The buffer was good, move it to GBUFF
00001AFE  6000 FE50               1399          BRA     PRINT           Branch to PRINT     
00001B02  2278 1000               1400          MOVE.L  GBUFF,A1        The buffer was bad, restore A1
00001B06  4E75                    1401          RTS                     Return to caller for next instruction
00001B08                          1402  
00001B08  2078 1000               1403  OP      MOVE.L  GBUFF,A0        Set A0 to GBUFF location
00001B0C  2278 1000               1404          MOVE.L  GBUFF,A1        Set A1 to GBUFF location for sub-routines
00001B10  143C 0000               1405          MOVE.B  #0,D2           Set NULL count to 0
00001B14  0C90 FFFFFFFF           1406          CMP.L   #$FFFFFFFF,(A0) Check for NULL
00001B1A  67C4                    1407          BEQ     DONE            If NULL, branch to DONE
00001B1C  3018                    1408          MOVE.W  (A0)+,D0        Transfer word data to D0, post-increment location
00001B1E  3210                    1409          MOVE.W  (A0),D1         Transfer next word data to D1
00001B20  21F8 1000 1010          1410          MOVE.L   GBUFF,IOADDR   Set memory location for IO
00001B26                          1411  *-----
00001B26                          1412  * 0000
00001B26                          1413  *-----
00001B26                          1414          * ORI:    00000000XXXXXXXX
00001B26  343C 0000               1415          MOVE.W  #%0000000000000000,D2
00001B2A  363C FF00               1416          MOVE.W  #%1111111100000000,D3
00001B2E  207C 000020BC           1417          MOVE.L  #BRORI,A0
00001B34  61BA                    1418          BSR     JMPMSK
00001B36                          1419  
00001B36                          1420          * SUBI:   00000100XXXXXXXX
00001B36  343C 0400               1421          MOVE.W  #%0000010000000000,D2
00001B3A  363C FB00               1422          MOVE.W  #%1111101100000000,D3
00001B3E  207C 000020EE           1423          MOVE.L  #BRSUBI,A0
00001B44  61AA                    1424          BSR     JMPMSK
00001B46                          1425  
00001B46                          1426          * ADDI:   00000110XXXXXXXX
00001B46  343C 0600               1427          MOVE.W  #%0000011000000000,D2
00001B4A  363C F900               1428          MOVE.W  #%1111100100000000,D3
00001B4E  207C 00001F44           1429          MOVE.L  #BRADDI,A0
00001B54  619A                    1430          BSR     JMPMSK
00001B56                          1431  
00001B56                          1432          * BTST:   0000100000XXXXXX
00001B56  343C 0800               1433          MOVE.W  #%0000100000000000,D2
00001B5A  363C F7C0               1434          MOVE.W  #%1111011111000000,D3
00001B5E  207C 00001F58           1435          MOVE.L  #BRBTST,A0
00001B64  618A                    1436          BSR     JMPMSK
00001B66                          1437  
00001B66                          1438          * EORI:   00001010XXXXXXXX
00001B66  343C 0A00               1439          MOVE.W  #%0000101000000000,D2
00001B6A  363C F500               1440          MOVE.W  #%1111010100000000,D3
00001B6E  207C 000020C6           1441          MOVE.L  #BREORI,A0
00001B74  6100 FF7A               1442          BSR     JMPMSK
00001B78                          1443  
00001B78                          1444          * CMPI:   00001100XXXXXXXX
00001B78  343C 0C00               1445          MOVE.W  #%0000110000000000,D2
00001B7C  363C F300               1446          MOVE.W  #%1111001100000000,D3
00001B80  207C 00001FA8           1447          MOVE.L  #BRCMPI,A0
00001B86  6100 FF68               1448          BSR     JMPMSK
00001B8A                          1449  *-----
00001B8A                          1450  * 0001
00001B8A                          1451  *-----
00001B8A                          1452          * MOVE.B: 0001XXXXXXXXXXXX
00001B8A  343C 1000               1453          MOVE.W  #%0001000000000000,D2
00001B8E  363C E000               1454          MOVE.W  #%1110000000000000,D3
00001B92  207C 00001FE0           1455          MOVE.L  #BRMOVE,A0
00001B98  6100 FF56               1456          BSR     JMPMSK
00001B9C                          1457  *-----
00001B9C                          1458  * 0010
00001B9C                          1459  *-----
00001B9C                          1460          * MOVE.L: 0010XXXXXXXXXXXX
00001B9C  343C 2000               1461          MOVE.W  #%0010000000000000,D2
00001BA0  363C D000               1462          MOVE.W  #%1101000000000000,D3
00001BA4  6100 FF4A               1463          BSR     JMPMSK
00001BA8                          1464  *-----
00001BA8                          1465  * 0011
00001BA8                          1466  *-----
00001BA8                          1467          * MOVE.W: 0011XXXXXXXXXXXX 
00001BA8  343C 3000               1468          MOVE.W  #%0011000000000000,D2
00001BAC  363C C000               1469          MOVE.W  #%1100000000000000,D3
00001BB0  6100 FF3E               1470          BSR     JMPMSK
00001BB4                          1471  *-----
00001BB4                          1472  * 0100
00001BB4                          1473  *-----
00001BB4                          1474          * NOT:    01000110XXXXXXXX
00001BB4  343C 4600               1475          MOVE.W  #%0100011000000000,D2
00001BB8  363C B900               1476          MOVE.W  #%1011100100000000,D3
00001BBC  207C 000020D0           1477          MOVE.L  #BRNOT,A0
00001BC2  6100 FF2C               1478          BSR     JMPMSK
00001BC6                          1479  
00001BC6                          1480          * MULU:   0100110000XXXXXX
00001BC6  343C 4C00               1481          MOVE.W  #%0100110000000000,D2
00001BCA  363C B3C0               1482          MOVE.W  #%1011001111000000,D3
00001BCE  207C 0000209E           1483          MOVE.L  #BRMULU,A0
00001BD4  6100 FF1A               1484          BSR     JMPMSK
00001BD8                          1485  
00001BD8                          1486          * DIVS:   0100110001XXXXXX
00001BD8  343C 4C40               1487          MOVE.W  #%0100110001000000,D2
00001BDC  363C B380               1488          MOVE.W  #%1011001110000000,D3
00001BE0  207C 000020A8           1489          MOVE.L  #BRDIVS,A0
00001BE6  6100 FF08               1490          BSR     JMPMSK
00001BEA                          1491  
00001BEA                          1492          * MOVEM:  01001X001XXXXXXX
00001BEA  343C 4880               1493          MOVE.W  #%0100100010000000,D2
00001BEE  363C B300               1494          MOVE.W  #%1011001100000000,D3
00001BF2  207C 00002082           1495          MOVE.L  #BRMOVEM,A0
00001BF8  6100 FEF6               1496          BSR     JMPMSK
00001BFC                          1497  
00001BFC                          1498          * RTS:    0100111001110101
00001BFC  343C 4E75               1499          MOVE.W  #%0100111001110101,D2
00001C00  363C B18A               1500          MOVE.W  #%1011000110001010,D3
00001C04  207C 00001FB2           1501          MOVE.L  #BRRTS,A0
00001C0A  6100 FEE4               1502          BSR     JMPMSK
00001C0E                          1503  
00001C0E                          1504          * JSR:    0100111010XXXXXX
00001C0E  343C 4E80               1505          MOVE.W  #%0100111010000000,D2
00001C12  363C B140               1506          MOVE.W  #%1011000101000000,D3
00001C16  207C 00001FD6           1507          MOVE.L  #BRJSR,A0
00001C1C  6100 FED2               1508          BSR     JMPMSK
00001C20                          1509  
00001C20                          1510          * LEA:    0100XXX111XXXXXX
00001C20  343C 41C0               1511          MOVE.W  #%0100000111000000,D2
00001C24  363C B000               1512          MOVE.W  #%1011000000000000,D3
00001C28  207C 00001FBC           1513          MOVE.L  #BRLEA,A0
00001C2E  6100 FEC0               1514          BSR     JMPMSK
00001C32                          1515  *-----
00001C32                          1516  * 0101
00001C32                          1517  *-----
00001C32                          1518          * ADDQ:   0101XXX0XXXXXXXX
00001C32  343C 5000               1519          MOVE.W  #%0101000000000000,D2
00001C36  363C A100               1520          MOVE.W  #%1010000100000000,D3
00001C3A  207C 00001F3A           1521          MOVE.L  #BRADDQ,A0
00001C40  6100 FEAE               1522          BSR     JMPMSK
00001C44                          1523  *-----
00001C44                          1524  * 0110
00001C44                          1525  *-----
00001C44                          1526          * BCC:    01100000XXXXXXXX
00001C44  343C 6000               1527          MOVE.W  #%0110000000000000,D2
00001C48  363C 9F00               1528          MOVE.W  #%1001111100000000,D3
00001C4C  207C 00001F62           1529          MOVE.L  #BRBCC,A0
00001C52  6100 FE9C               1530          BSR     JMPMSK
00001C56                          1531  *-----
00001C56                          1532  * 0111
00001C56                          1533  *-----
00001C56                          1534          * MOVEQ:  0111XXX0XXXXXXXX
00001C56  343C 7000               1535          MOVE.W  #%0111000000000000,D2
00001C5A  363C 8100               1536          MOVE.W  #%1000000100000000,D3
00001C5E  207C 0000208C           1537          MOVE.L  #BRMOVEQ,A0
00001C64  6100 FE8A               1538          BSR     JMPMSK
00001C68                          1539  *-----
00001C68                          1540  * 1000
00001C68                          1541  *-----
00001C68                          1542          * DIVS:   1000XXX111XXXXXX
00001C68  343C 81C0               1543          MOVE.W  #%1000000111000000,D2
00001C6C  363C 7000               1544          MOVE.W  #%0111000000000000,D3
00001C70  207C 000020A8           1545          MOVE.L  #BRDIVS,A0
00001C76  6100 FE78               1546          BSR     JMPMSK
00001C7A                          1547  *-----
00001C7A                          1548  * 1001
00001C7A                          1549  *-----
00001C7A                          1550          * SUB:    1001XXXXXXXXXXXX
00001C7A  343C 9000               1551          MOVE.W  #%1001000000000000,D2
00001C7E  363C 6000               1552          MOVE.W  #%0110000000000000,D3
00001C82  207C 000020DA           1553          MOVE.L  #BRSUB,A0
00001C88  6100 FE66               1554          BSR     JMPMSK
00001C8C                          1555  *-----
00001C8C                          1556  * 1010
00001C8C                          1557  *-----
00001C8C                          1558  *-----
00001C8C                          1559  * 1011
00001C8C                          1560  *-----
00001C8C                          1561          * CMP:    1011XXXXXXXXXXXX
00001C8C  343C B000               1562          MOVE.W  #%1011000000000000,D2
00001C90  363C 4000               1563          MOVE.W  #%0100000000000000,D3
00001C94  207C 00001F94           1564          MOVE.L  #BRCMP,A0
00001C9A  6100 FE54               1565          BSR     JMPMSK
00001C9E                          1566  
00001C9E                          1567          * EOR:    1011XXXXXXXXXXXX
00001C9E  207C 000020B2           1568          MOVE.L  #BREOR,A0
00001CA4  6100 FE4A               1569          BSR     JMPMSK
00001CA8                          1570  *-----
00001CA8                          1571  * 1100
00001CA8                          1572  *-----
00001CA8                          1573          * AND:    1100XXXXXXXXXXXX
00001CA8  343C C000               1574          MOVE.W  #%1100000000000000,D2
00001CAC  363C 3000               1575          MOVE.W  #%0011000000000000,D3
00001CB0  207C 00001F4E           1576          MOVE.L  #BRAND,A0
00001CB6  6100 FE38               1577          BSR     JMPMSK
00001CBA                          1578  
00001CBA                          1579          * MULU:   1100XXX011XXXXXX
00001CBA  343C C0C0               1580          MOVE.W  #%1100000011000000,D2
00001CBE  363C 3100               1581          MOVE.W  #%0011000100000000,D3
00001CC2  207C 0000209E           1582          MOVE.L  #BRMULU,A0
00001CC8  6100 FE26               1583          BSR     JMPMSK
00001CCC                          1584  *-----
00001CCC                          1585  * 1101
00001CCC                          1586  *-----
00001CCC                          1587          * ADD:    1101XXXXXXXXXXXX
00001CCC  343C D000               1588          MOVE.W  #%1101000000000000,D2
00001CD0  363C 2000               1589          MOVE.W  #%0010000000000000,D3
00001CD4  207C 00001EE8           1590          MOVE.L  #BRADD,A0
00001CDA  6100 FE14               1591          BSR     JMPMSK
00001CDE                          1592  *-----
00001CDE                          1593  * 1110
00001CDE                          1594  *-----
00001CDE                          1595          * ASL/ASR:1110XXXXXXX00XXX
00001CDE  343C E000               1596          MOVE.W  #%1110000000000000,D2
00001CE2  363C 1018               1597          MOVE.W  #%0001000000011000,D3
00001CE6  207C 00002096           1598          MOVE.L  #BRASd,A0
00001CEC  6100 FE02               1599          BSR     JMPMSK
00001CF0                          1600  
00001CF0                          1601          * LSL/LSR:1110XXXXXXX01XXX
00001CF0  343C E008               1602          MOVE.W  #%1110000000001000,D2
00001CF4  363C 1010               1603          MOVE.W  #%0001000000010000,D3
00001CF8  207C 0000209A           1604          MOVE.L  #BRLSd,A0
00001CFE  6100 FDF0               1605          BSR     JMPMSK
00001D02                          1606  
00001D02                          1607          * ASL/ASR:1110000X11XXXXXX
00001D02  343C E0C0               1608          MOVE.W  #%1110000011000000,D2
00001D06  363C 1E00               1609          MOVE.W  #%0001111000000000,D3
00001D0A  207C 00002096           1610          MOVE.L  #BRASd,A0
00001D10  6100 FDDE               1611          BSR     JMPMSK
00001D14                          1612  
00001D14                          1613          * LSL/LSR:1110001X11XXXXXX
00001D14  343C E2C0               1614          MOVE.W  #%1110001011000000,D2
00001D18  363C 1C00               1615          MOVE.W  #%0001110000000000,D3
00001D1C  207C 0000209A           1616          MOVE.L  #BRLSd,A0
00001D22  6100 FDCC               1617          BSR     JMPMSK
00001D26                          1618  *-----
00001D26                          1619  * 1111
00001D26                          1620  *-----     
00001D26  6000 FBFE               1621          BRA     BRBAD           No mask matched, branch to BRBAD
00001D2A                          1622  
00001D2A                          1623  *--------------------------
00001D2A                          1624  *  Instruction Subroutines
00001D2A                          1625  *--------------------------
00001D2A                          1626  
00001D2A                          1627  *
00001D2A                          1628  * Test Addressing Modes: Tests last register and mode for valid addressing modes
00001D2A                          1629  * Input valid modes in D0.W, output found addressing mode to D1.B, or FF if not found
00001D2A                          1630  * Set Z-flag if mode was valid, or clear Z-flag if mode was invalid
00001D2A                          1631  *
00001D2A                          1632  * D0.W addressing modes (set to 0 for invalid, 1 for valid):
00001D2A                          1633  *   0   Dn
00001D2A                          1634  *   1   An
00001D2A                          1635  *   2   (An)
00001D2A                          1636  *   3   (An)+
00001D2A                          1637  *   4   -(An)
00001D2A                          1638  *   5   (d,An)
00001D2A                          1639  *   6   (d,An,Xn)
00001D2A                          1640  *   7   (xxx).W
00001D2A                          1641  *   8   (xxx).L
00001D2A                          1642  *   9   (d,PC)
00001D2A                          1643  *   A   (d,PC,Xn)
00001D2A                          1644  *   B   #<data>
00001D2A                          1645  *
00001D2A                          1646  * Modes         %XXXXBA9876543210
00001D2A  =00000FFF               1647  M_ALL   EQU     %0000111111111111   All modes
00001D2A  =00000FFD               1648  M_DAT   EQU     %0000111111111101   Data modes
00001D2A  =00000FFC               1649  M_MEM   EQU     %0000111111111100   Memory modes
00001D2A  =000007E4               1650  M_CTR   EQU     %0000011111100100   Control modes
00001D2A  =0000007F               1651  M_ALT   EQU     %0000000001111111   Alterable modes
00001D2A  =000001FC               1652  M_MALT  EQU     %0000000111111100   Memory alterable modes
00001D2A  =000001FD               1653  M_DALT  EQU     %0000000111111101   Data alterable modes
00001D2A                          1654  
00001D2A  1F02                    1655  TSTAM   MOVE.B  D2,-(SP)        Push D2 to stack
00001D2C  4281                    1656          CLR.L   D1
00001D2E  1238 10C4               1657          MOVE.B  (RGMD),D1       Move REGMOD to D1
00001D32  1401                    1658          MOVE.B  D1,D2           Copy REGMOD to D2
00001D34  EB09                    1659          LSL.B   #5,D1
00001D36  EA09                    1660          LSR.B   #5,D1           D1 = Mode
00001D38  E60A                    1661          LSR.B   #3,D2           D2 = Register
00001D3A  B23C 0007               1662          CMP.B   #%111,D1        Test mode to 111
00001D3E  6602                    1663          BNE     *+4             If !=, skip next line
00001D40  D202                    1664          ADD.B   D2,D1           Add register to mode-- effectively creating a 4 bit mode
00001D42  0300                    1665          BTST    D1,D0           Test mode for validity
00001D44  6706                    1666          BEQ     *+8             If it is invalid, skip to clear flag
00001D46  141F                    1667          MOVE.B  (SP)+,D2        If it is valid, restore D2
00001D48  6000 F6D8               1668          BRA     FLAGST          Set flag & return to caller
00001D4C  141F                    1669          MOVE.B  (SP)+,D2        Restore D2
00001D4E  6000 F6D8               1670          BRA     FLAGCL          Clear flag & return to caller
00001D52                          1671  
00001D52                          1672  *
00001D52                          1673  * Advance Buffer: Advances buffer based on last register and mode
00001D52                          1674  * Input buffer in A1, reg & mode in RGMD, output displacement to DIS
00001D52                          1675  *
00001D52                          1676  
00001D52  48E7 6000               1677  ADVBFR  MOVEM.L D1/D2,-(SP)     Push D1 & D2 to the stack
00001D56  11FC 00FF 10C5          1678          MOVE.B  #$FF,(DIS)      Set displacement to NULL
00001D5C  1238 10C4               1679          MOVE.B  (RGMD),D1       Move Reg & Mod to D1
00001D60  2409                    1680          MOVE.L  A1,D2           Copy buffer to D2
00001D62  B23C 0007               1681          CMP.B   #$07,D1         Test 000 111 = Address (Word)
00001D66  6602                    1682          BNE.S   *+4             Skip next line
00001D68  5489                    1683          ADD.L   #$2,A1          Advance buffer by word
00001D6A  B23C 000F               1684          CMP.B   #$0F,D1         Test 001 111 = Address (Long)
00001D6E  6602                    1685          BNE.S   *+4             Skip next line
00001D70  5889                    1686          ADD.L   #$4,A1          Advance buffer by long
00001D72  B23C 0027               1687          CMP.B   #$27,D1         Test 100 111 = Immediate (OP code size)
00001D76  6700 0010               1688          BEQ     ADVBSZ          If ==, branch to Advance Buffer by Size
00001D7A  4482                    1689          NEG.L   D2              Else, negate original buffer
00001D7C  D489                    1690          ADD.L   A1,D2           Add buffer to get difference
00001D7E  11C2 10C5               1691          MOVE.B  D2,(DIS)        Store displacement in DIS
00001D82  4CDF 0006               1692          MOVEM.L (SP)+,D1/D2     Restore D1 & D2
00001D86  4E75                    1693          RTS                     Return to caller
00001D88                          1694  
00001D88                          1695  *
00001D88                          1696  * Advance Buffer by Size: Advances buffer based on instruction size
00001D88                          1697  * Input buffer in A1, input size from (IOSIZE), output displacement to DIS
00001D88                          1698  *
00001D88                          1699  
00001D88  0C38 00FF 10C5          1700  ADVBSZ  CMP.B   #$FF,(DIS)      Check if DIS is NULL (255 is odd so displacement should never be FF)
00001D8E  6704                    1701          BEQ     *+6             If it is null, values have already been pushed to the stack, skip the next line
00001D90  48E7 6000               1702          MOVEM.L D1/D2,-(SP)     Else, push D1 & D2 to the stack
00001D94  1238 100E               1703          MOVE.B  (IOSIZE),D1     Read size to D1
00001D98  2409                    1704          MOVE.L  A1,D2           Copy buffer to D2
00001D9A  B03C 0001               1705          CMP.B   #$1,D0          Test 0 = Byte
00001D9E  6602                    1706          BNE.S   *+4             Skip next line
00001DA0  5489                    1707          ADD.L   #$2,A1          Advance buffer by word (00BB)
00001DA2  B23C 0001               1708          CMP.B   #$1,D1          Test 1 = Word
00001DA6  6602                    1709          BNE.S   *+4             Skip next line
00001DA8  5489                    1710          ADD.L   #$2,A1          Advance buffer by word        
00001DAA  B23C 0002               1711          CMP.B   #$2,D1          Test 2 = Long
00001DAE  6602                    1712          BNE.S   *+4             Skip next line
00001DB0  5889                    1713          ADD.L   #$4,A1          Advance buffer by long
00001DB2  4442                    1714          NEG     D2              Negate original buffer
00001DB4  D489                    1715          ADD.L   A1,D2           Add buffer to get difference
00001DB6  11C2 10C5               1716          MOVE.B  D2,(DIS)        Store displacement in DIS
00001DBA  4CDF 0006               1717          MOVEM.L (SP)+,D2/D1     Restore D1 and D2
00001DBE  4E75                    1718          RTS                     Return to caller
00001DC0                          1719  
00001DC0                          1720  *
00001DC0                          1721  * OP Size: Test the standard OP size code
00001DC0                          1722  * Inputs size from (DMD), outputs size to IOSIZE, operation to D2.B, correct mode to DMD
00001DC0                          1723  * OPM (OP-MODE):  Byte | Word | Long | Operation | D2.B
00001DC0                          1724  *                  000 |  001 |  010 |   <ea>,Dn |    0
00001DC0                          1725  *                  100 |  101 |  110 |   Dn,<ea> |    1
00001DC0                          1726  *                         011 |  111 |   <ea>,An |    2
00001DC0                          1727  *
00001DC0                          1728  
00001DC0  48E7 C000               1729  OPSIZE  MOVEM.L D0/D1,-(SP)     Push D0 & D1 to stack
00001DC4  4241                    1730          CLR.W   D1              Ensure displacement will be <= 7
00001DC6  1238 10C0               1731          MOVE.B  (DMD),D1        Get destination mode in D1
00001DCA  C2FC 0004               1732          MULU.W  #4,D1           Convert to displacement
00001DCE  4EFB 1002               1733          JMP     OPTBL(PC,D1.W)  Jump to OP mode
00001DD2  6000 001E               1734  OPTBL   BRA     OP0             000
00001DD6  6000 002C               1735          BRA     OP1             001
00001DDA  6000 003A               1736          BRA     OP2             010
00001DDE  6000 0048               1737          BRA     OP3             011
00001DE2  6000 0056               1738          BRA     OP4             100
00001DE6  6000 0064               1739          BRA     OP5             101
00001DEA  6000 0072               1740          BRA     OP6             110
00001DEE  6000 0080               1741          BRA     OP7             111
00001DF2  143C 0000               1742  OP0     MOVE.B  #0,D2           Set OP to 0 for Dn
00001DF6  11FC 0000 10C0          1743          MOVE.B  #0,(DMD)        Set mode to Dn
00001DFC  103C 0000               1744          MOVE.B  #0,D0           Set size to byte
00001E00  6000 0080               1745          BRA     OP8             Branch to end
00001E04  143C 0000               1746  OP1     MOVE.B  #0,D2           Set OP to 0 for Dn
00001E08  11FC 0000 10C0          1747          MOVE.B  #0,(DMD)        Set mode to Dn
00001E0E  103C 0001               1748          MOVE.B  #1,D0           Set size to word
00001E12  6000 006E               1749          BRA     OP8             Branch to end
00001E16  143C 0000               1750  OP2     MOVE.B  #0,D2           Set OP to 0 for Dn
00001E1A  11FC 0000 10C0          1751          MOVE.B  #0,(DMD)        Set mode to Dn
00001E20  103C 0002               1752          MOVE.B  #2,D0           Set size to long
00001E24  6000 005C               1753          BRA     OP8             Branch to end
00001E28  143C 0002               1754  OP3     MOVE.B  #2,D2           Set OP to 2 for An
00001E2C  11FC 0001 10C0          1755          MOVE.B  #1,(DMD)        Set mode to An
00001E32  103C 0001               1756          MOVE.B  #1,D0           Set size to word
00001E36  6000 004A               1757          BRA     OP8             Branch to end
00001E3A  143C 0001               1758  OP4     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E3E  11FC 0000 10C0          1759          MOVE.B  #0,(DMD)        Set mode to Dn
00001E44  103C 0000               1760          MOVE.B  #0,D0           Set size to byte
00001E48  6000 0038               1761          BRA     OP8             Branch to end
00001E4C  143C 0001               1762  OP5     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E50  11FC 0000 10C0          1763          MOVE.B  #0,(DMD)        Set mode to Dn
00001E56  103C 0001               1764          MOVE.B  #1,D0           Set size to word
00001E5A  6000 0026               1765          BRA     OP8             Branch to end
00001E5E  143C 0001               1766  OP6     MOVE.B  #1,D2           Set OP to 1 for <ea>
00001E62  11FC 0000 10C0          1767          MOVE.B  #0,(DMD)        Set mode to Dn
00001E68  103C 0002               1768          MOVE.B  #2,D0           Set size to long
00001E6C  6000 0014               1769          BRA     OP8             Branch to end
00001E70  143C 0002               1770  OP7     MOVE.B  #2,D2           Set OP to 2 for An
00001E74  11FC 0001 10C0          1771          MOVE.B  #1,(DMD)        Set mode to An
00001E7A  103C 0002               1772          MOVE.B  #2,D0           Set size to long
00001E7E  6000 0002               1773          BRA     OP8             Branch to end
00001E82  11C0 100E               1774  OP8     MOVE.B  D0,(IOSIZE)     Store size in IOSIZE
00001E86  4CDF 0003               1775          MOVEM.L (SP)+,D0/D1     Restore D0 & D1
00001E8A  4E75                    1776          RTS                     Return to caller
00001E8C                          1777  
00001E8C                          1778  *
00001E8C                          1779  * Extract destination: Extracts destination mode to DMD and destination register to DRG from instruction
00001E8C                          1780  * Input instruction from A1, output a combination of reg & mode in RGMD
00001E8C                          1781  *
00001E8C                          1782  
00001E8C  48E7 E000               1783  EXDST   MOVEM.L D0-D2,-(SP)     Push D0 - D2 to stack
00001E90  3011                    1784          MOVE.W  (A1),D0         Move instruction to D0
00001E92  243C 000001C0           1785          MOVE.L  #$1C0,D2        Extract dest mode at 0000000111000000
00001E98  6100 F6F8               1786          BSR     EXTMSK          Get dest mode to D1
00001E9C  11C1 10C0               1787          MOVE.B  D1,(DMD)        Move dest mode to DMD
00001EA0  243C 00000E00           1788          MOVE.L  #$E00,D2        Extract dest reg at 0000111000000000
00001EA6  6100 F6EA               1789          BSR     EXTMSK          Get dest reg to D1
00001EAA  11C1 10C1               1790          MOVE.B  D1,(DRG)        Move dest reg to (DRG)
00001EAE  E709                    1791          LSL.B   #3,D1           Shift the reg 3 bits left
00001EB0  8238 10C0               1792          OR.B    (DMD),D1        Add mode after reg
00001EB4  11C1 10C4               1793          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001EB8  4CDF 0007               1794          MOVEM.L (SP)+,D0-D2     Restore D0 - D2
00001EBC  4E75                    1795          RTS                     Return to caller
00001EBE                          1796  
00001EBE                          1797  *
00001EBE                          1798  * Extract source: Extracts source mode to SMD and source register to SRG from instruction
00001EBE                          1799  * Inputs instruction from GBUFF, output a combination of reg & mode in RGMD
00001EBE                          1800  *
00001EBE                          1801  
00001EBE  48E7 E000               1802  EXSRC   MOVEM.L D0-D2,-(SP)     Push D0 - D2 to stack
00001EC2  3011                    1803          MOVE.W  (A1),D0         Move instruction to D0
00001EC4  7438                    1804          MOVE.L  #$38,D2         Extract src mode at 0000000000111000
00001EC6  6100 F6CA               1805          BSR     EXTMSK          Get src mode to D1
00001ECA  11C1 10C2               1806          MOVE.B  D1,(SMD)        Move src mode to (OMD)
00001ECE  7407                    1807          MOVE.L  #$7,D2          Extract src reg at 0000000000000111
00001ED0  6100 F6C0               1808          BSR     EXTMSK          Get src reg to D1
00001ED4  11C1 10C3               1809          MOVE.B  D1,(SRG)        Move src reg to (ORG)
00001ED8  E709                    1810          LSL.B   #3,D1           Shift the reg 3 bits left
00001EDA  8238 10C2               1811          OR.B    (SMD),D1        Add mode after reg
00001EDE  11C1 10C4               1812          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00001EE2  4CDF 0007               1813          MOVEM.L (SP)+,D0-D2     Restore D0 - D2
00001EE6  4E75                    1814          RTS                     Return to caller
00001EE8                          1815  
00001EE8                          1816  * ----------------
00001EE8                          1817  * OP Mode Branches
00001EE8                          1818  * ----------------
00001EE8                          1819  * A1 reserved for tentative good buffer
00001EE8                          1820  
00001EE8                          1821  
00001EE8                          1822  * ADD: 1101|REG|OPM|EMD|ERG
00001EE8                          1823  * Syntax: ADD       <ea>,Dn
00001EE8                          1824  *         ADD       Dn,<ea>
00001EE8                          1825  * Note: The Dn mode is used when the destination is a data register;
00001EE8                          1826  *       the destination <ea> mode is invalid for a data register. 
00001EE8                          1827  *       ADDA is used when the destination is an address register.
00001EE8                          1828  *       ADDI and ADDQ are used when the source is immediate data.
00001EE8                          1829  *       Most assemblers automatically make this distinction.  
00001EE8                          1830  
00001EE8  11FC 0011 100C          1831  BRADD   MOVE.B  #$11,(IOOPCD)   Set OP-code name
00001EEE  619C                    1832          BSR     EXDST           Extract OP mode & register
00001EF0  6100 FECE               1833          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00001EF4                          1834          * "If the location specified is a destination operand,
00001EF4                          1835          * only memory alterable addressing modes can be used [...]."
00001EF4  B43C 0000               1836          CMP.B   #0,D2           Compare operation to Dn
00001EF8  6604                    1837          BNE.S   *+6             If !=, skip next line
00001EFA  303C 01FC               1838          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00001EFE                          1839          * "If the location specified is a source operand,
00001EFE                          1840          * all addressing modes can be used [...]."
00001EFE  B43C 0001               1841          CMP.B   #1,D2           Compare operation to <ea>
00001F02  6604                    1842          BNE.S   *+6             If !=, skip next line
00001F04  303C 0FFF               1843          MOVE.W  #M_ALL,D0       Set all modes as valid
00001F08                          1844          * "ADDA is used when the destination is an address register."
00001F08  B43C 0002               1845          CMP.B   #2,D2           Compare operation to An
00001F0C  6700 0010               1846          BEQ     BRADDA          If ==, branch to BRADDA
00001F10                          1847  
00001F10  61AC                    1848          BSR     EXSRC           Extract EA mode & register
00001F12                          1849          *BSR     TSTAM           Test modes for validity
00001F12  6600 F514               1850          BNE     FLAGCL          If not valid, return unsuccessful
00001F16  6100 FE3A               1851          BSR     ADVBFR          Else, advance the buffer accordingly
00001F1A  6000 F506               1852          BRA     FLAGST          Return return successful
00001F1E                          1853  
00001F1E                          1854  
00001F1E                          1855  * ADDA: 1101|REG|OPM|EMD|ERG
00001F1E                          1856  * Syntax: ADDA      <ea>,An
00001F1E                          1857  
00001F1E  11FC 0015 100C          1858  BRADDA  MOVE.B  #$15,(IOOPCD)   Set OP-code name
00001F24                          1859          * "All addressing modes can be used [...]."
00001F24  303C 0FFF               1860          MOVE.W  #M_ALL,D0       Set all modes as valid
00001F28  6194                    1861          BSR     EXSRC           Extract EA mode & register
00001F2A  6100 FDFE               1862          BSR     TSTAM           Test modes for validity
00001F2E  6600 F4F8               1863          BNE     FLAGCL          If not valid, return unsuccessful
00001F32  6100 FE1E               1864          BSR     ADVBFR          Else, advance the buffer accordingly
00001F36  6000 F4EA               1865          BRA     FLAGST          Return successful
00001F3A                          1866  
00001F3A                          1867  * ADDQ: 0101|DAT|0|SZ|EMD|ERG
00001F3A                          1868  * Syntax: ADDQ      #<data>,<ea>
00001F3A                          1869  
00001F3A  11FC 001A 100C          1870  BRADDQ  MOVE.B  #$1A,(IOOPCD)   Set OP-code name
00001F40  6000 F4E0               1871          BRA     FLAGST          Return successful
00001F44                          1872  
00001F44                          1873  * ADDI: 000000110|SZ|EMD|ERG
00001F44                          1874  * Syntax: ADDI      #<data>,<ea>
00001F44                          1875  
00001F44  11FC 0099 100C          1876  BRADDI  MOVE.B  #$99,(IOOPCD)   Set OP-code name
00001F4A  6000 F4D6               1877          BRA     FLAGST          Return successful
00001F4E                          1878  
00001F4E                          1879  * AND: 1100|REG|OPM|EMD|ERG
00001F4E                          1880  * Syntax: AND       <ea>,Dn
00001F4E                          1881  *         AND       Dn,<ea>
00001F4E                          1882  * Note: The Dn mode is used when the destination is a data register;
00001F4E                          1883  *       the destination < ea > mode is invalid for a data register. 
00001F4E                          1884  *       Most assemblers use ANDI when the source is immediate data.
00001F4E                          1885  
00001F4E  11FC 003B 100C          1886  BRAND   MOVE.B  #$3B,(IOOPCD)   Set OP-code name
00001F54  6000 F4CC               1887          BRA     FLAGST          Return successful
00001F58                          1888  
00001F58                          1889  * BTST: 0000|REG|100|EMD|ERG (BIT NUMBER DYNAMIC, SPECIFIED IN A REGISTER)
00001F58                          1890  *       0000100000|EMD|ERG  00000000|_BITNUM_ (BIT NUMBER STATIC, SPECIFIED AS IMMEDIATE DATA)
00001F58                          1891  * Syntax: BTST      Dn,<ea>
00001F58                          1892  *         BTST      #<data>,<ea>
00001F58                          1893  
00001F58  11FC 0058 100C          1894  BRBTST  MOVE.B  #$58,(IOOPCD)   Set OP-code name
00001F5E  6000 F4C2               1895          BRA     FLAGST          Return successful
00001F62                          1896  
00001F62                          1897  * BCC: 0110|COND|_8BTDSP_
00001F62                          1898  * Syntax: BCC       <label>
00001F62                          1899  
00001F62  11FC 006B 100C          1900  BRBCC   MOVE.B  #$6B,(IOOPCD)   Set OP-code name
00001F68  6000 F4B8               1901          BRA     FLAGST          Return successful
00001F6C                          1902  
00001F6C  11FC 006F 100C          1903  BRBEQ   MOVE.B  #$6F,(IOOPCD)   Set OP-code name
00001F72  6000 F4AE               1904          BRA     FLAGST          Return successful
00001F76                          1905          
00001F76  11FC 0073 100C          1906  BRBLT   MOVE.B  #$73,(IOOPCD)   Set OP-code name
00001F7C  6000 F4A4               1907          BRA     FLAGST          Return successful
00001F80                          1908  
00001F80  11FC 0077 100C          1909  BRBNE   MOVE.B  #$77,(IOOPCD)   Set OP-code name
00001F86  6000 F49A               1910          BRA     FLAGST          Return successful
00001F8A                          1911  
00001F8A  11FC 007B 100C          1912  BRBHI   MOVE.B  #$7B,(IOOPCD)   Set OP-code name
00001F90  6000 F490               1913          BRA     FLAGST          Return successful
00001F94                          1914  
00001F94                          1915  * CMP: 1011|REG|OPM|EMD|ERG
00001F94                          1916  * Syntax: CMP       <ea>,Dn
00001F94                          1917  * Note: CMPA is used when the destination is an address register.
00001F94                          1918  *       CMPI is used when the source is immediate data.
00001F94                          1919  *       CMPM is used for memory-to-memory compares.
00001F94                          1920  *       Most assemblers automatically make the distinction.
00001F94                          1921  
00001F94  11FC 005D 100C          1922  BRCMP   MOVE.B  #$5D,(IOOPCD)   Set OP-code name
00001F9A  6000 F486               1923          BRA     FLAGST          Return successful
00001F9E                          1924  
00001F9E                          1925  * CMPA: 1011|REG|OPM|EMD|ERG
00001F9E                          1926  * Syntax: CMPA      <ea>,An       
00001F9E                          1927  
00001F9E  11FC 0061 100C          1928  BRCMPA  MOVE.B  #$61,(IOOPCD)   Set OP-code name
00001FA4  6000 F47C               1929          BRA     FLAGST          Return successful
00001FA8                          1930  
00001FA8                          1931  * CMPI: 00001100|SZ|EMD|ERG
00001FA8                          1932  * Syntax: CMPI      #<data>,<ea>
00001FA8                          1933  
00001FA8  11FC 0066 100C          1934  BRCMPI  MOVE.B  #$66,(IOOPCD)   Set OP-code name
00001FAE  6000 F472               1935          BRA     FLAGST          Return successful
00001FB2                          1936  
00001FB2                          1937  * RTS: 0100111001110101
00001FB2                          1938  * Syntax: RTS
00001FB2                          1939  
00001FB2  11FC 0083 100C          1940  BRRTS   MOVE.B  #$83,(IOOPCD)   Set OP-code name
00001FB8  6000 F468               1941          BRA     FLAGST          Return successful
00001FBC                          1942  
00001FBC                          1943  * LEA: 0100|REG|111|EMD|ERG
00001FBC                          1944  * Syntax: LEA       <ea>,An
00001FBC                          1945  
00001FBC  11FC 0037 100C          1946  BRLEA   MOVE.B  #$37,(IOOPCD)   Set OP-code name
00001FC2  6100 FEC8               1947          BSR     EXDST           Extract destination mode & register
00001FC6  6100 FD8A               1948          BSR     ADVBFR          Advance the buffer accordingly
00001FCA  6100 FEF2               1949          BSR     EXSRC           Extract source mode & register
00001FCE  6100 FD82               1950          BSR     ADVBFR          Advance the buffer accordingly
00001FD2  6000 F44E               1951          BRA     FLAGST          Return successful
00001FD6                          1952  
00001FD6                          1953  * JSR: 0100111010|EMD|ERG
00001FD6                          1954  * Syntax: JSR       <ea>
00001FD6                          1955  
00001FD6  11FC 007F 100C          1956  BRJSR   MOVE.B  #$7F,(IOOPCD)   Set OP-code name
00001FDC  6000 F444               1957          BRA     FLAGST          Return successful
00001FE0                          1958          
00001FE0                          1959  * MOVE: 00|SZ|DRG|DMD|SMD|SRG
00001FE0                          1960  * Syntax: MOVE      <ea>,<ea>
00001FE0                          1961  * Note: Most assemblers use MOVEA when the destination is an address register. 
00001FE0                          1962  *       MOVEQ can be used to move an immediate 8-bit value to a data register. 
00001FE0                          1963  
00001FE0  11FC 0000 100C          1964  BRMOVE  MOVE.B  #$00,(IOOPCD)   Set OP-code name
00001FE6  3011                    1965          MOVE.W  (A1),D0         Move instruction to D0
00001FE8  243C 00003000           1966          MOVE.L  #$3000,D2       Extract size at 0011000000000000
00001FEE  6100 F5A2               1967          BSR     EXTMSK          Get the size to D1
00001FF2                          1968  
00001FF2  103C 00FF               1969          MOVE.B  #$FF,D0         Set size to null
00001FF6  B23C 0001               1970          CMP.B   #%01,D1         01 = Byte
00001FFA  6604                    1971          BNE.S   *+6             Branch to next test
00001FFC  103C 0000               1972          MOVE.B  #$0,D0          Set size to byte
00002000  B23C 0003               1973          CMP.B   #%11,D1         11 = Word
00002004  6604                    1974          BNE.S   *+6             Branch to next test
00002006  103C 0001               1975          MOVE.B  #$1,D0          Set size to word
0000200A  B23C 0002               1976          CMP.B   #%10,D1         10 = Long
0000200E  6604                    1977          BNE.S   *+6             Branch to next test
00002010  103C 0002               1978          MOVE.B  #$2,D0          Set size to long
00002014  B03C 00FF               1979          CMP.B   #$FF,D0         Test if size was found
00002018  6700 F40E               1980          BEQ     FLAGCL          If it was not found, branch to clear flag      
0000201C  11C0 100E               1981          MOVE.B  D0,(IOSIZE)     If it was found, store size in IOSIZE
00002020                          1982  
00002020  6100 FE6A               1983          BSR     EXDST           Extract dest EA mode & register
00002024  0C38 0001 10C0          1984          CMP.B   #1,(DMD)        Compare mode to An
0000202A  6700 002A               1985          BEQ     BRMOVEA         If ==, branch to BRMOVEA
0000202E                          1986          * Dest EA field: "Only data alterable addressing modes can be used [...]."
0000202E  303C 01FD               1987          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002032  6100 FCF6               1988          BSR     TSTAM           Test modes for validity
00002036  6600 F3F0               1989          BNE     FLAGCL          If not valid, return unsuccessful
0000203A  6100 FD16               1990          BSR     ADVBFR          Else, advance the buffer accordingly
0000203E  6100 FE7E               1991          BSR     EXSRC           Extract source EA mode & register
00002042                          1992          * Source EA field: "All addressing modes can be used [...]."
00002042  303C 0FFF               1993          MOVE.W  #M_ALL,D0       Set all modes as valid
00002046  6100 FCE2               1994          BSR     TSTAM           Test modes for validity
0000204A  6600 F3DC               1995          BNE     FLAGCL          If not valid, return unsuccessful
0000204E  6100 FD02               1996          BSR     ADVBFR          Else, advance the buffer accordingly
00002052                          1997  
00002052  6000 F3CE               1998          BRA     FLAGST          Return successful
00002056                          1999  
00002056                          2000  
00002056                          2001  * MOVEA: 00|SZ|DRG|001|SMD|SRG
00002056                          2002  * Syntax: MOVEA     <ea>,An
00002056                          2003  
00002056  11FC 0005 100C          2004  BRMOVEA MOVE.B  #$05,(IOOPCD)   Set Op-code name
0000205C  0C38 0000 100E          2005          CMP.B   #0,(IOSIZE)     Compare size to byte
00002062  6700 F3C4               2006          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002066  6100 FCEA               2007          BSR     ADVBFR          Else, advance the buffer accordingly
0000206A  6100 FE52               2008          BSR     EXSRC           Extract source EA mode & register
0000206E                          2009          * Source EA field: "All addressing modes can be used [...]."
0000206E  303C 0FFF               2010          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002072  6100 FCB6               2011          BSR     TSTAM           Test modes for validity
00002076  6600 F3B0               2012          BNE     FLAGCL          If not valid, return unsuccessful
0000207A  6100 FCD6               2013          BSR     ADVBFR          Advance the buffer accordingly
0000207E  6000 F3A2               2014          BRA     FLAGST          Return successful
00002082                          2015  
00002082                          2016  * MOVEM: 01001|D|001|S|EMD|ERG
00002082                          2017  * Syntax: MOVEM     <list>,<ea>
00002082                          2018  *         MOVEM     <ea>,<list>
00002082                          2019  
00002082  11FC 000B 100C          2020  BRMOVEM MOVE.B  #$0B,(IOOPCD)   Set OP-code name
00002088  6000 F398               2021          BRA     FLAGST          Return successful
0000208C                          2022  
0000208C                          2023  * MOVEQ: 0111|REG|0|__DATA__
0000208C                          2024  * Syntax: MOVEQ     #<data>,Dn
0000208C                          2025  
0000208C  11FC 008B 100C          2026  BRMOVEQ MOVE.B  #$8B,(IOOPCD)   Set OP-code name
00002092  6600 F38E               2027          BNE     FLAGST          Return unsuccessful
00002096                          2028  
00002096                          2029  * ASd: 1110000|d|11|EMD|ERG (memory shifts)
00002096                          2030  *      1110|CRG|d|SZ|i|00|REG (register shifts)
00002096                          2031  * Syntax: ASd       Dx,Dy
00002096                          2032  *         ASd       #<data>,Dy
00002096                          2033  *         ASd       <ea>
00002096                          2034  
00002096                          2035  BRASd   *MOVE.B  #$50,(IOOPCD)   ASL
00002096                          2036          *MOVE.B  #$95,(IOOPCD)   ASR
00002096  6000 F38A               2037          BRA     FLAGST          Return successful
0000209A                          2038  
0000209A                          2039  * LSd: 1110001|d|11|EMD|ERG (memory shifts)
0000209A                          2040  *      1110|CRG|d|SZ|i|01|REG (register shifts)
0000209A                          2041  * Syntax: LSd       Dx,Dy
0000209A                          2042  *         LSd       #<data>,Dy
0000209A                          2043  *         LSd       <ea>
0000209A                          2044  
0000209A                          2045  BRLSd   *MOVE.B  #$91,(IOOPCD)   LSL
0000209A                          2046          *MOVE.B  #$54,(IOOPCD)   LSR
0000209A  6000 F386               2047          BRA     FLAGST          Return successful
0000209E                          2048  
0000209E                          2049  * MULU: 1100|REG|011|EMD|ERG (WORD)
0000209E                          2050  *       0100110000|EMD|ERG  0|RDI|0|SZ|0000000|RDH (LONG)
0000209E                          2051  * Syntax: MULU.W    <ea>,Dn    16x16 -> 32
0000209E                          2052  *         MULU.L    <ea>,Dl    32x32 -> 32
0000209E                          2053  *         MULU.L    <ea>,DhDl 32x32 -> 64 
0000209E                          2054  
0000209E  11FC 002D 100C          2055  BRMULU  MOVE.B  #$2D,(IOOPCD)   Set OP-code name
000020A4  6000 F37C               2056          BRA     FLAGST          Return successful
000020A8                          2057  
000020A8                          2058  * DIVS: 1000|REG|111|EMD|ERG (WORD)
000020A8                          2059  *       0100110001|EMD|ERG  0|RDQ|1|S|0000000|RDR (LONG)
000020A8                          2060  * Synax: DIVS.W     <ea>,Dn     32/16 -> 16r  16q
000020A8                          2061  *        DIVS.L     <ea>,Dq     32/32 -> 32q
000020A8                          2062  *        DIVS.L     <ea>,Dr:Dq  64/32 -> 32r  32q
000020A8                          2063  *        DIVSL.L    <ea>,Dr:Dq 32/32 -> 32r  32q
000020A8                          2064  
000020A8  11FC 0032 100C          2065  BRDIVS  MOVE.B  #$32,(IOOPCD)   Set OP-code name     
000020AE  6000 F372               2066          BRA     FLAGST          Return successful
000020B2                          2067  
000020B2                          2068  * EOR: 1011|REG|OPM|EMD|ERG
000020B2                          2069  * Syntax: EOR       Dn,<ea>
000020B2                          2070  * Note: Memory-to-data-register operations are not allowed.
000020B2                          2071  *       Most assemblers use EORI when the source is immediate data.
000020B2                          2072  
000020B2  11FC 0043 100C          2073  BREOR   MOVE.B  #$43,(IOOPCD)   Set OP-code name
000020B8  6000 F368               2074          BRA     FLAGST          Return successful
000020BC                          2075  
000020BC                          2076  * ORI: 00000000|SZ|EMD|ERG
000020BC                          2077  * Syntax: ORI       #<data>,<ea>
000020BC                          2078  
000020BC  11FC 003F 100C          2079  BRORI   MOVE.B  #$3F,(IOOPCD)   Set OP-code name
000020C2  6000 F35E               2080          BRA     FLAGST          Return successful
000020C6                          2081  
000020C6                          2082  * EORI: 00001010|SZ|EMD|ERG
000020C6                          2083  * Syntax: EORI      #<data>,<ea>
000020C6                          2084  
000020C6  11FC 0047 100C          2085  BREORI  MOVE.B  #$47,(IOOPCD)   Set OP-code name
000020CC  6000 F354               2086          BRA     FLAGST          Return successful
000020D0                          2087  
000020D0                          2088  * NOT: 01000110|SZ|EMD|ERG
000020D0                          2089  * Syntax:  NOT      <ea>
000020D0                          2090  
000020D0  11FC 004C 100C          2091  BRNOT   MOVE.B  #$4C,(IOOPCD)   Set OP-code name
000020D6  6000 F34A               2092          BRA     FLAGST          Return successful
000020DA                          2093  
000020DA                          2094  * SUB: 1001|REG|OPM|EMD|ERG
000020DA                          2095  * Syntax: SUB       <ea>,Dn
000020DA                          2096  *         SUB       Dn,<ea>
000020DA                          2097  * Note: Most assemblers use SUBA when the destination is an address register
000020DA                          2098  *       and SUBI or SUBQ when the source is immediate data.
000020DA                          2099  
000020DA  11FC 001F 100C          2100  BRSUB   MOVE.B  #$1F,(IOOPCD)   Set OP-code name
000020E0  6000 F340               2101          BRA     FLAGST          Else, return successful
000020E4                          2102  
000020E4                          2103  * SUBA: 1001|REG|OPM|EMD|ERG
000020E4                          2104  * Syntax: SUBA      <ea>,An
000020E4                          2105  
000020E4  11FC 0023 100C          2106  BRSUBA  MOVE.B  #$23,(IOOPCD)   Set OP-code name 
000020EA  6000 F336               2107          BRA     FLAGST          Else, return successful
000020EE                          2108  
000020EE                          2109  * SUBI: 0000|0100|SZ|EMD|ERG
000020EE                          2110  * Syntax: SUBI      #<data>,<ea> 
000020EE                          2111  
000020EE  11FC 0028 100C          2112  BRSUBI  MOVE.B  #$28,(IOOPCD)   Set OP-code name
000020F4  6000 F32C               2113          BRA     FLAGST          Else, return successful
000020F8                          2114  
000020F8                          2115  * SUBQ: 0101|DAT|1|SZ|EMD|ERG
000020F8                          2116  * Syntax: SUBQ      #<data>,<ea>
000020F8                          2117  
000020F8                          2118          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 1460
A2H11               1498
A2H12               149E
A2H13               14A4
A2H14               14AA
A2H15               14B0
A2H16               14B6
A2HADV              1490
ADVBFR              1D52
ADVBSZ              1D88
ASCII2HEX           142E
B1A                 7452
B2A                 7458
B3                  745E
B4                  7464
B5                  746A
BA1                 748C
BA2                 7492
BA3                 7498
BA4                 749E
BB1                 74C0
BB2                 74C8
BB3                 74D2
BB4                 74E2
BRADD               1EE8
BRADDA              1F1E
BRADDI              1F44
BRADDQ              1F3A
BRAND               1F4E
BRASD               2096
BRBAD               1926
BRBCC               1F62
BRBEQ               1F6C
BRBHI               1F8A
BRBLT               1F76
BRBNE               1F80
BRBTST              1F58
BRCMP               1F94
BRCMPA              1F9E
BRCMPI              1FA8
BRDIVS              20A8
BREOR               20B2
BREORI              20C6
BRJSR               1FD6
BRLEA               1FBC
BRLSD               209A
BRMOVE              1FE0
BRMOVEA             2056
BRMOVEM             2082
BRMOVEQ             208C
BRMULU              209E
BRNOT               20D0
BRORI               20BC
BRRTS               1FB2
BRSUB               20DA
BRSUBA              20E4
BRSUBI              20EE
CBITS               0
CMPMSK              1564
CR                  D
DIS                 10C5
DISP0               178A
DISP1               179A
DISP2               17AA
DISP3               17CA
DISP4               17F0
DISP5               1816
DISP6               1832
DISP7               185A
DISP8               1876
DISP9               1892
DISPA               18AE
DISPB               18D0
DISPC               18FE
DISPD               1920
DISPOP              175A
DMD                 10C0
DMDTBL              176A
DONE                1AE0
DRG                 10C1
DRGTBL              1862
DSPAX               15AA
DSPHADV             160A
DSPHDR              1AC4
DSPHST              15F6
DSPHXA              15B4
DSPHXL              1614
DSPHXLP             15B8
DSPHXN              15DA
DSPHXRT             15D4
DSPHXW              15EE
DSPOFLP             1740
DSPOFRT             1754
DSPOFS              1736
DSPSTLP             1706
DSPSTR              16FC
DSPSTRT             1722
ELOC                1008
ERR0                13CA
ERR1                13ED
EXDST               1E8C
EXSRC               1EBE
EXTADV              15A4
EXTLP               1598
EXTMSK              1592
FLAGCL              1428
FLAGST              1422
GBUFF               1000
H2A                 14EE
H2AA                1526
H2AADV              151E
H2AB                152C
H2AC                1532
H2AD                1538
H2AE                153E
H2AF                1544
HEADR               13A8
HEX2ASCII           14BC
ILL0                161E
ILL1                162C
ILL2                1686
ILL3                1694
IOADDR              1010
IOBDCD              100D
IOLC                1014
IOOPCD              100C
IOOPSZ              10B4
IOSIZE              100E
JMPMSK              1AF0
JUMP                7526
LF                  A
MASK                154A
MNADDR              7000
MSSG0               10C6
MSSG1               1290
MSSG2               12F9
MSSG4               135E
MSSG5               137F
MXADDR              FFFFFF
M_ALL               FFF
M_ALT               7F
M_CTR               7E4
M_DALT              1FD
M_DAT               FFD
M_MALT              1FC
M_MEM               FFC
NODST               1A3E
NOSRC               1A0C
OP                  1B08
OP0                 1DF2
OP1                 1E04
OP2                 1E16
OP3                 1E28
OP4                 1E3A
OP5                 1E4C
OP6                 1E5E
OP7                 1E70
OP8                 1E82
OPNAME              1016
OPSIZE              1DC0
OPTBL               1DD2
PAUSE               1AA0
PRINT               1950
PRMPT1              1636
PRMPT2              169E
PRMPTDN             16F2
QDATA               1015
RGMD                10C4
SLOC                1004
SMD                 10C2
SRG                 10C3
START               140E
TB                  9
TSTAM               1D2A
TSTMSK              1550
VBIN1               FFCFCFCF
VHEX1               FA
VHEX2               DADA
VHEX3               ADADDADA
VHEX4               45
